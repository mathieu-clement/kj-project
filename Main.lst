CCS PCH C Compiler, Version 4.136, 4828               22-nov.-12 14:53

               Filename: C:\Users\lucy\Desktop\Dropbox\TIC\KJ_Project\Main.lst

               ROM used: 20282 bytes (43%)
                         Largest free fragment is 27250
               RAM used: 404 (10%) at main() level
                         473 (12%) worst case
               Stack:    10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   4D16
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   12BE
0060:  BTFSS  FA3.5
0062:  GOTO   006C
0066:  BTFSC  FA4.5
0068:  GOTO   1332
006C:  BTFSS  FF2.5
006E:  GOTO   0078
0072:  BTFSC  FF2.2
0074:  GOTO   0E86
0078:  BTFSS  FF2.4
007A:  GOTO   0084
007E:  BTFSC  FF2.1
0080:  GOTO   0D8E
0084:  BTFSS  F9D.0
0086:  GOTO   0090
008A:  BTFSC  F9E.0
008C:  GOTO   0BAA
0090:  BTFSS  FA0.1
0092:  GOTO   009C
0096:  BTFSC  FA1.1
0098:  GOTO   0D66
009C:  BTFSS  F9D.6
009E:  GOTO   00A8
00A2:  BTFSC  F9E.6
00A4:  GOTO   01CA
00A8:  MOVFF  0E,00
00AC:  MOVFF  0F,01
00B0:  MOVFF  10,02
00B4:  MOVFF  11,03
00B8:  MOVFF  0C,FE9
00BC:  MOVFF  07,FEA
00C0:  BSF    07.7
00C2:  MOVFF  08,FE1
00C6:  MOVFF  09,FE2
00CA:  MOVFF  0A,FD9
00CE:  MOVFF  0B,FDA
00D2:  MOVFF  12,FF3
00D6:  MOVFF  13,FF4
00DA:  MOVFF  14,FFA
00DE:  MOVFF  15,FF5
00E2:  MOVFF  16,FF6
00E6:  MOVFF  17,FF7
00EA:  MOVF   04,W
00EC:  MOVFF  06,FE0
00F0:  MOVFF  05,FD8
00F4:  RETFIE 0
.................... //============================================================================// 
.................... //==                                                                        ==// 
.................... //==                         K-Junior Main Template                         ==// 
.................... //==                                                                        ==// 
.................... //============================================================================// 
.................... #include "KJunior.h" 
.................... //--------------------------------------------------------------------------------// 
.................... //-                   KJOs ( K-Junior Operating System )                         -// 
.................... //                                                                               -// 
.................... //-  Copyright (C) Frédéric Lambercy, K-Team S.A. 2008                           -// 
.................... //-  This library is free software; you can redistribute it and/or               -// 
.................... //-  modify it under the terms of the GNU Lesser General Public                  -// 
.................... //-  License as published by the Free Software Foundation; either                -// 
.................... //-  version 2.1 of the License, or any later version.                           -// 
.................... //-                                                                              -// 
.................... //-  This library is distributed in the hope that it will be useful,             -// 
.................... //-  but WITHOUT ANY WARRANTY; without even the implied warranty of              -// 
.................... //-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           -// 
.................... //-  Lesser General Public License for more details.                             -// 
.................... //-                                                                              -// 
.................... //-  You should have received a copy of the GNU Lesser General Public            -// 
.................... //-  License along with this library; if not, write to the Free Software         -// 
.................... //-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   -// 
.................... //-                                                                              -// 
.................... //-                               __  __  ________                               -// 
.................... //- K-Team S.A.                  |  |/  /|__    __|___  _____  ___  ___          -// 
.................... //- Z.I. les Plans-Praz          |     / __ |  | _____|/  _  \|   \/   |         -// 
.................... //- 1337 Vallorbe                |  |  \    |  | ____|/  /_\  |        |         -// 
.................... //- Switzerland                  |__|\__\   |__|______|_/   \_|__|\/|__|         -// 
.................... //- lambercy@k-team.com   tel:+41 24 423 89 73 fax:+41 24 423 8960               -// 
.................... //-                                                                              -// 
.................... //--------------------------------------------------------------------------------// 
....................  
....................  
.................... #include "18f66k22.h" 
.................... //////// Standard Header file for the PIC18F66K22 device //////////////// 
.................... #device PIC18F66K22 
.................... #list 
....................  
.................... #device *=16 ADC=10  
....................  
....................  
.................... #fuses INTRC,NOWDT,NOPROTECT,BROWNOUT,NOWDT,NOCPD,SOSC_DIG                      // Configuration Bits 
.................... #use   delay(clock=16000000)                                                    // Clock @ 16 MHz 
*
13F2:  MOVLW  01
13F4:  MOVWF  FEA
13F6:  MOVLW  99
13F8:  MOVWF  FE9
13FA:  MOVF   FEF,W
13FC:  BZ    141A
13FE:  MOVLW  05
1400:  MOVWF  01
1402:  CLRF   00
1404:  DECFSZ 00,F
1406:  BRA    1404
1408:  DECFSZ 01,F
140A:  BRA    1402
140C:  MOVLW  2E
140E:  MOVWF  00
1410:  DECFSZ 00,F
1412:  BRA    1410
1414:  BRA    1416
1416:  DECFSZ FEF,F
1418:  BRA    13FE
141A:  RETURN 0
.................... #use   rs232(stream=USB, baud=57600,parity=N,bits=8,xmit=PIN_C6,rcv=PIN_C7)     // USB Serial Config. 57600,8,N,1 
.................... #use   rs232(stream=BT, baud=57600,parity=N,bits=8,xmit=PIN_G1,rcv=PIN_G2)      // Bluetooth Serial Config. 57600,8,N,1 
.................... #use   i2c(master,sda=PIN_C4,scl=PIN_C3,FORCE_HW,SLOW)                          // I2C Master Configuration 
*
2C4A:  BCF    FC6.7
2C4C:  BCF    F9E.3
2C4E:  MOVFF  1CE,FC9
2C52:  MOVLW  02
2C54:  BTFSC  FC6.7
2C56:  BRA    2C62
2C58:  BTFSS  F9E.3
2C5A:  BRA    2C58
2C5C:  MOVLW  00
2C5E:  BTFSC  FC5.6
2C60:  MOVLW  01
2C62:  MOVWF  01
2C64:  RETURN 0
2C66:  BCF    FC6.6
2C68:  BSF    FC5.3
2C6A:  BTFSC  FC5.3
2C6C:  BRA    2C6A
2C6E:  BTFSC  00.0
2C70:  BCF    FC5.5
2C72:  BTFSS  00.0
2C74:  BSF    FC5.5
2C76:  BSF    FC5.4
2C78:  BTFSC  FC5.4
2C7A:  BRA    2C78
2C7C:  MOVFF  FC9,01
2C80:  RETURN 0
.................... #use   fast_io(A) 
.................... #use   fast_io(B) 
.................... #use   fast_io(C) 
.................... #use   fast_io(D) 
.................... #use   fast_io(E) 
.................... #use   fast_io(F) 
.................... #use   fast_io(G) 
....................  
....................  
....................  
.................... #include "constants.h" 
.................... //--------------------------------------------------------------------------------// 
.................... //-                   KJOs ( K-Junior Operating System )                         -// 
.................... //                                                                               -// 
.................... //-  Copyright (C) Frédéric Lambercy, K-Team S.A. 2008                           -// 
.................... //-  This library is free software; you can redistribute it and/or               -// 
.................... //-  modify it under the terms of the GNU Lesser General Public                  -// 
.................... //-  License as published by the Free Software Foundation; either                -// 
.................... //-  version 2.1 of the License, or any later version.                           -// 
.................... //-                                                                              -// 
.................... //-  This library is distributed in the hope that it will be useful,             -// 
.................... //-  but WITHOUT ANY WARRANTY; without even the implied warranty of              -// 
.................... //-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           -// 
.................... //-  Lesser General Public License for more details.                             -// 
.................... //-                                                                              -// 
.................... //-  You should have received a copy of the GNU Lesser General Public            -// 
.................... //-  License along with this library; if not, write to the Free Software         -// 
.................... //-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   -// 
.................... //-                                                                              -// 
.................... //-                               __  __  ________                               -// 
.................... //- K-Team S.A.                  |  |/  /|__    __|___  _____  ___  ___          -// 
.................... //- Z.I. les Plans-Praz          |     / __ |  | _____|/  _  \|   \/   |         -// 
.................... //- 1337 Vallorbe                |  |  \    |  | ____|/  /_\  |        |         -// 
.................... //- Switzerland                  |__|\__\   |__|______|_/   \_|__|\/|__|         -// 
.................... //- lambercy@k-team.com   tel:+41 24 423 89 73 fax:+41 24 423 8960               -// 
.................... //-                                                                              -// 
.................... //--------------------------------------------------------------------------------// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \file constants.h 
....................       \brief In this file all constants are defined 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define INIT_TRISA            0x2F   // b0010 1111 
.................... #define INIT_PORTA            0x00   // b0000 0000 
....................  
.................... #define INIT_TRISB            0xC1   // b1100 0001 
.................... #define INIT_PORTB            0x00   // b0000 0000 
....................  
.................... //#define INIT_TRISC            0x87   // b1000 0111 
.................... #define INIT_TRISC            0x9F   // b1001 1111 
.................... #define INIT_PORTC            0x00   // b0000 0000 
....................  
.................... #define INIT_TRISD            0x00   // b0000 0000 
.................... #define INIT_PORTD            0x00   // b0000 0000 
....................  
.................... #define INIT_TRISE            0x00   // b0000 0000 
.................... #define INIT_PORTE            0x00   // b0000 0000 
....................  
.................... #define INIT_TRISF            0xBF   // b1011 1111 
.................... #define INIT_PORTF            0x00   // b0000 0000 
....................  
.................... #define INIT_TRISG            0x04   // b0000 0100 
.................... #define INIT_PORTG            0x00   // b0000 0000 
....................  
....................  
.................... #BIT BOR = 0x8E.0 
.................... #BIT POR = 0x8E.1 
....................  
.................... #define SERIAL_BUFFER_SIZE  80 
.................... #define SERIAL_USB      0 
.................... #define SERIAL_BT       1 
....................  
.................... #define NB_IR                 10 
....................  
.................... #locate ADCON0      =       0x0FC2 
.................... #locate ADCON1      =       0x0FC1 
.................... #locate ADCON2      =       0x0FC0 
.................... #locate OSCCON      =       0x0FD3 
.................... #locate RCON        =       0x0FD0 
.................... #define IPEN        0x80 
....................  
.................... #locate IPR1        =       0x0F9F 
.................... #define RC1IP       0x20 
.................... #locate IPR2        =       0x0FA2 
.................... #locate IPR3        =       0x0FA5 
.................... #define RC2IP       0x20 
.................... #locate IPR4        =       0x0FB8 
.................... #locate IPR5        =       0x0FD2 
.................... #locate IPR6        =       0x0FA9 
....................  
.................... #define LEFT                  0 
.................... #define FRONTLEFT             1 
.................... #define FRONT                 2 
.................... #define FRONTRIGHT            3 
.................... #define RIGHT                 4 
.................... #define REAR                  5 
.................... #define GROUNDLEFT            9 
.................... #define GROUNDFRONTLEFT       7  
.................... #define GROUNDFRONTRIGHT      8 
.................... #define GROUNDRIGHT           10 
....................  
.................... #define VBAT_AN               6 
....................  
.................... #define EEPROM_ADD            10 
....................  
.................... #define IR_GROUP1             PIN_D1 
.................... #define IR_GROUP2             PIN_D2 
.................... #define IR_GROUP3             PIN_D3 
....................  
.................... #define IR_CALIB_TH           20 
....................  
.................... #define LEFT_EMITTER                  PIN_D1 
.................... #define FRONTLEFT_EMITTER             PIN_D2 
.................... #define FRONT_EMITTER                 PIN_D1 
.................... #define FRONTRIGHT_EMITTER            PIN_D3 
.................... #define RIGHT_EMITTER                 PIN_D1 
.................... #define REAR_EMITTER                  PIN_D3 
.................... #define GROUNDLEFT_EMITTER            PIN_D2 
.................... #define GROUNDFRONTLEFT_EMITTER       PIN_D3 
.................... #define GROUNDFRONTRIGHT_EMITTER      PIN_D2 
.................... #define GROUNDRIGHT_EMITTER           PIN_D3 
....................  
....................  
.................... #define ENABLE                1 
.................... #define DISABLE               0 
.................... #define FAST                  1 
.................... #define NORMAL                0 
.................... #define MANUAL                0 
.................... #define REFRESH               1 
.................... #define ON                    1 
.................... #define OFF                   0 
....................  
.................... #define KJ_FW_VERSION   "B" 
.................... #define KJ_FW_REVISION  1                                                       // Please set revision! 
.................... #define KJ_FW_REFERENCE "510.0055" 
....................  
.................... #define RC5_HEADER       0xC0 
.................... #define RC5_TOGGLE       0x20 
.................... #define MANCHESTER_0     0x2 
.................... #define MANCHESTER_1     0x1 
....................  
.................... #define RC5_KJ_ADDR      0x00             // RC5 address of the K-Junior robot ! it's a TV! 
.................... #define RC5_KJ_CMD_GO    0x02 
.................... #define RC5_KJ_CMD_BACK  0x00 
.................... #define RC5_KJ_CMD_LEFT  0x04 
.................... #define RC5_KJ_CMD_RIGHT 0x06 
.................... #define RC5_KJ_CMD_STOP  0x05 
.................... #define RC5_KJ_CMD_Sp    0x10             // Speed+ = Vol + 
.................... #define RC5_KJ_CMD_Sm    0x11             // Speed- = Vol - 
....................  
.................... #define StartBit1        0 
.................... #define StartBit2        1 
.................... #define ToggleBit        2 
.................... #define AddrBit4       3 
.................... #define AddrBit3       4 
.................... #define AddrBit2       5 
.................... #define AddrBit1       6 
.................... #define AddrBit0       7 
.................... #define DataBit5         8 
.................... #define DataBit4         9 
.................... #define DataBit3         10 
.................... #define DataBit2         11 
.................... #define DataBit1         12 
.................... #define DataBit0         13 
....................  
.................... #define MotD1           PIN_E6 
.................... #define MotD2           PIN_E5 
.................... #define MotG1           PIN_E4 
.................... #define MotG2           PIN_E3 
....................  
.................... #define BUZZER          PIN_E2 
....................  
.................... #define IR_IN           PIN_B0 
.................... #define IR_OUT          PIN_D4 
....................  
.................... #define VBAT_M          PIN_F1 
....................  
.................... #define LED0            PIN_B1 
.................... #define LED1            PIN_B2 
.................... #define LED2            PIN_B3 
.................... #define LED3            PIN_B4 
.................... #define LED4            PIN_B5 
....................  
.................... #define MODE1           PIN_C0 
.................... #define MODE2           PIN_C1 
.................... #define MODE3           PIN_C2 
....................  
.................... #define TIMER1_VALUE    64585 
.................... #locate INTCON =        0x0FF2 
.................... #locate PIR1   =        0x0F9E 
....................  
.................... // Timer 0 is used for the rc5 decoding      
.................... #define TIMER0_1780     58415                                                   // = 1.78ms 
.................... #define TIMER0_1140     60975                                                   // = 1.14ms 
.................... #define TIMER0_2100     57135                                                   // = 2.10ms 
.................... #define TIMER0_886      61991                                                   // = 886us 
....................  
.................... // Timer 2 used for the Buzzer, Timer4 For the motors 
.................... #define MOTOR_MAX       200                                                     // Define the frequency of the PWM motor (=20kHz) 
.................... #define MOTOR_MIN       60                                                      // Minimum PWM set on the motor 
.................... #define MOTOR_CONV      7                                                       // value to convert the 0-20 speed value to the PWM 
.................... #define SPEED_MIN       15                                                      // Define the speed where an acceleration is needed 
.................... #define ACCEL           30                                                      // Time of the acceleration in us 
....................  
.................... #locate CCP1CON   =     0x0FBB 
.................... #locate CCP2CON   =     0x0F4E 
.................... #locate CCP3CON   =     0x0F49 
.................... #locate CCPTMRS0  =     0x0F2D 
.................... #locate PSTR1CON  =     0x0F9C     
.................... #locate PSTR2CON  =     0x0F1B 
.................... #locate PSTR3CON  =     0x0F1A 
.................... #locate SSP1CON1  =     0x0FC6 
....................  
.................... // Timer3 value for the note frequency 
.................... #define BUZ_NUMBER      48                                                      // Number of available notes 
.................... #define BUZ_DO          63626                                                   // = 262Hz (if Timer3/4) 
.................... #define BUZ_RE_BEMOL    63729                                                   // = 277Hz (if Timer3/4) 
.................... #define BUZ_RE          63834                                                   // = 294Hz (if Timer3/4) 
.................... #define BUZ_MI_BEMOL    63927                                                   // = 311Hz (if Timer3/4) 
.................... #define BUZ_MI          64019                                                   // = 330Hz (if Timer3/4) 
.................... #define BUZ_FA          64115                                                   // = 349Hz (if Timer3/4) 
.................... #define BUZ_SOL_BEMOL   64183                                                   // = 370Hz (if Timer3/4) 
.................... #define BUZ_SOL         64259                                                   // = 392Hz (if Timer3/4) 
.................... #define BUZ_LA_BEMOL    64330                                                   // = 415Hz (if Timer3/4) 
.................... #define BUZ_LA          64398                                                   // = 440Hz (if Timer3/4) 
.................... #define BUZ_SI_BEMOL    64462                                                   // = 466Hz (if Timer3/4) 
.................... #define BUZ_SI          64522                                                   // = 494Hz (if Timer3/4) 
....................  
....................  
....................  
....................  
.................... #include "variables.c" 
.................... //--------------------------------------------------------------------------------// 
.................... //-                   KJOs ( K-Junior Operating System )                         -// 
.................... //                                                                               -// 
.................... //-  Copyright (C) Frédéric Lambercy, K-Team S.A. 2008                           -// 
.................... //-  This library is free software; you can redistribute it and/or               -// 
.................... //-  modify it under the terms of the GNU Lesser General Public                  -// 
.................... //-  License as published by the Free Software Foundation; either                -// 
.................... //-  version 2.1 of the License, or any later version.                           -// 
.................... //-                                                                              -// 
.................... //-  This library is distributed in the hope that it will be useful,             -// 
.................... //-  but WITHOUT ANY WARRANTY; without even the implied warranty of              -// 
.................... //-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           -// 
.................... //-  Lesser General Public License for more details.                             -// 
.................... //-                                                                              -// 
.................... //-  You should have received a copy of the GNU Lesser General Public            -// 
.................... //-  License along with this library; if not, write to the Free Software         -// 
.................... //-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   -// 
.................... //-                                                                              -// 
.................... //-                               __  __  ________                               -// 
.................... //- K-Team S.A.                  |  |/  /|__    __|___  _____  ___  ___          -// 
.................... //- Z.I. les Plans-Praz          |     / __ |  | _____|/  _  \|   \/   |         -// 
.................... //- 1337 Vallorbe                |  |  \    |  | ____|/  /_\  |        |         -// 
.................... //- Switzerland                  |__|\__\   |__|______|_/   \_|__|\/|__|         -// 
.................... //- lambercy@k-team.com   tel:+41 24 423 89 73 fax:+41 24 423 8960               -// 
.................... //-                                                                              -// 
.................... //--------------------------------------------------------------------------------// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \file variables.c 
....................       \brief Definition of all global functions 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //- Motors 
.................... signed int8 PwmMotLeft = 0;                                                     // 0 : Stop ; 20 : Max Speed 
.................... signed int8 PwmMotRight = 0;                                                    // 0 : Stop ; 20 : Max Speed 
.................... signed int8 Old_PwmMotRight = 0;                                                // Save the speed value to compare with the new one 
.................... signed int8 Old_PwmMotLeft = 0;                                                 // Save the speed value to compare with the new one 
.................... signed int8 TimerMotLeft = 0;                                                   // Value which will be set in the PWM timer register 
.................... signed int8 TimerMotRight = 0;                                                  // Value which will be set in the PWM timer register 
.................... unsigned char Acceleration_Timer = 0; 
.................... unsigned char Acceleration_flag = 0;                                            // flag to indicate if an acceleration is needed 
.................... #define   ACCEL_LEFT      0x01 
.................... #define   ACCEL_RIGHT     0x02 
....................  
....................  
....................  
.................... //- Configuration Bits 
.................... int1 Auto_Refresh_Sensors = 1;                                                  // 1 : Auto   ; 0 : Manual 
.................... int1 Auto_Refresh_TV_Remote = 1;                                                // 1 : Auto   ; 0 : Never 
.................... int1 Enable_RS232_Control = 1;                                                  // 1 : Enable ; 0 : Disable 
.................... int1 Enable_TV_Remote_Control = 1;                                              // 1 : Enable ; 0 : Disable 
....................  
....................  
....................  
.................... //- RS232 
.................... char SerialBuffer[ SERIAL_BUFFER_SIZE ]; 
.................... int1 SerialCommandOK = 0; 
.................... char SerialCounter = 0; 
.................... char SerialPort = 0; 
....................  
.................... //- Flag 
.................... int1 Sensors_Refreshed_Flag = 0; 
....................  
.................... //- TV Remote Control Bit 
.................... int8 TV_table[14]; 
.................... int8 TV_ADDR = 0;                                                               // Address of the received RC5 code 
.................... int8 TV_DATA = 0;                                                               // Data of the received RC5 code 
.................... int8 TV_Counter = 0;                                                            // Counter for the RC5 code 
.................... int1 TV_Counter_flag = 0;                                                       // Flag to know if the emitting is in the first phase (=0) or the second (=1) of the bit to send 
.................... int8 TV_Data_send = 0;                                                          // Value of the rc5 code to send 
.................... int8 TV_Addr_send = 0;                                                          // Address of the rc5 code to send 
.................... int1 TV_Data_Available = 0;                                                     // Flag to indicate that a Data is available 
.................... int1 TV_Data_pending = 0;                                                       // Flag indicate that a data is coming on the IR receiver 
.................... int1 TV_Data_emitting = 0;                                                      // Flag indicate that a data must be send via the IR emitter 
.................... int1 TV_Data_loop = 0;                                                          // Flag to loop when a 1 is following by a zero 
.................... char TV_RX_Toggle_Bit = 0;                                                      // Flag to identify the tag of the message, only a different toggle bit means that the message is different than before 
.................... int1 TV_TX_Toggle_Bit = 0;                                                      // Flag to identify the tag of the message, only a different toggle bit means that the message is different than before 
....................  
....................  
....................  
.................... //- Time 
.................... unsigned int32 TimeTip = 0; 
.................... char TimeTipDivider = 0; 
.................... unsigned char MotorTime = 0; 
.................... unsigned char MotorTimeDivider = 0; 
....................  
.................... //- Irs Sensors 
.................... signed int16 IR_Light[ 12 ]; 
.................... signed int16 IR_Proximity[ 12 ];                                                // 0 : nothing detected ; 4096 : obstacle near KJunior 
.................... signed int16 IR_Calibrate[ 12 ];                                                 // Value of the calibrated sensor 
.................... signed int16 IR_Temp_Proximity[ 12 ];                                           // 0 : nothing detected ; 4096 : obstacle near KJunior 
.................... unsigned char IR_Counter = 0 ;                                                  // counter to manage the refresh of the IR sensor 
.................... unsigned char IR_ADC_Flag = 0;                                                  // Flag to indicate when a sensor is completely refreshed 
.................... unsigned char IR_AN_Table[12];                                                  // Table where the analog pin map of the IR sensor are saved 
.................... int1 Manual_Refresh_sensors = 0;                                                // Flag to refresh manually the sensor 
....................  
.................... //- Battery voltage 
.................... unsigned int16  BatteryVoltage = 0;                                             // Analog value of the battery voltage 
....................  
.................... //- Switchs 
.................... char Switchs; 
....................  
....................  
.................... //- LED state (0 = Normal, 1 = Mode auto activate (chenillard)) 
.................... unsigned char LED_mode = 0x10;                                                  // Start with the LED4 in auto mode 
.................... unsigned int16 LED_counter = 0; 
....................  
.................... //- Buzzer variable 
.................... unsigned char buzzValue   = 0;                                                  // Value of the Buzzer frequency  
.................... unsigned int16 Buzzer_Timer = 0; 
.................... unsigned int16 Buzzer_Table[13]; 
....................  
.................... // Variable for Bluetooth configuration 
.................... unsigned char BT_config = 0; 
....................  
.................... //- TRIS 
.................... #locate TRISB = 0x0F93 
....................  
....................  
....................  
....................  
.................... #include "KJunior.c" 
.................... //--------------------------------------------------------------------------------// 
.................... //-                   KJOs ( K-Junior Operating System )                         -// 
.................... //                                                                               -// 
.................... //-  Copyright (C) Frédéric Lambercy, K-Team S.A. 2008                           -// 
.................... //-  This library is free software; you can redistribute it and/or               -// 
.................... //-  modify it under the terms of the GNU Lesser General Public                  -// 
.................... //-  License as published by the Free Software Foundation; either                -// 
.................... //-  version 2.1 of the License, or any later version.                           -// 
.................... //-                                                                              -// 
.................... //-  This library is distributed in the hope that it will be useful,             -// 
.................... //-  but WITHOUT ANY WARRANTY; without even the implied warranty of              -// 
.................... //-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           -// 
.................... //-  Lesser General Public License for more details.                             -// 
.................... //-                                                                              -// 
.................... //-  You should have received a copy of the GNU Lesser General Public            -// 
.................... //-  License along with this library; if not, write to the Free Software         -// 
.................... //-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   -// 
.................... //-                                                                              -// 
.................... //-                               __  __  ________                               -// 
.................... //- K-Team S.A.                  |  |/  /|__    __|___  _____  ___  ___          -// 
.................... //- Z.I. les Plans-Praz          |     / __ |  | _____|/  _  \|   \/   |         -// 
.................... //- 1337 Vallorbe                |  |  \    |  | ____|/  /_\  |        |         -// 
.................... //- Switzerland                  |__|\__\   |__|______|_/   \_|__|\/|__|         -// 
.................... //- lambercy@k-team.com   tel:+41 24 423 89 73 fax:+41 24 423 8960               -// 
.................... //-                                                                              -// 
.................... //--------------------------------------------------------------------------------// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \file KJunior.c 
....................       \brief The Os functions, all functions are called through an interrupt 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
1A3E:  MOVLB  1
1A40:  CLRF   xA4
....................    sign = 0; 
1A42:  CLRF   xA2
....................    base = 10; 
1A44:  MOVLW  0A
1A46:  MOVWF  xA3
....................    result = 0; 
1A48:  CLRF   xA1
....................  
....................    if (!s) 
1A4A:  MOVF   x9F,W
1A4C:  IORWF  xA0,W
1A4E:  BNZ   1A56
....................       return 0; 
1A50:  MOVLW  00
1A52:  MOVWF  01
1A54:  BRA    1BEA
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
1A56:  MOVF   xA4,W
1A58:  INCF   xA4,F
1A5A:  CLRF   03
1A5C:  ADDWF  x9F,W
1A5E:  MOVWF  FE9
1A60:  MOVF   xA0,W
1A62:  ADDWFC 03,W
1A64:  MOVWF  FEA
1A66:  MOVFF  FEF,1A5
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
1A6A:  MOVF   xA5,W
1A6C:  SUBLW  2D
1A6E:  BNZ   1A8A
....................    { 
....................       sign = 1;         // Set the sign to negative 
1A70:  MOVLW  01
1A72:  MOVWF  xA2
....................       c = s[index++]; 
1A74:  MOVF   xA4,W
1A76:  INCF   xA4,F
1A78:  CLRF   03
1A7A:  ADDWF  x9F,W
1A7C:  MOVWF  FE9
1A7E:  MOVF   xA0,W
1A80:  ADDWFC 03,W
1A82:  MOVWF  FEA
1A84:  MOVFF  FEF,1A5
....................    } 
....................    else if (c == '+') 
1A88:  BRA    1AA4
1A8A:  MOVF   xA5,W
1A8C:  SUBLW  2B
1A8E:  BNZ   1AA4
....................    { 
....................       c = s[index++]; 
1A90:  MOVF   xA4,W
1A92:  INCF   xA4,F
1A94:  CLRF   03
1A96:  ADDWF  x9F,W
1A98:  MOVWF  FE9
1A9A:  MOVF   xA0,W
1A9C:  ADDWFC 03,W
1A9E:  MOVWF  FEA
1AA0:  MOVFF  FEF,1A5
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1AA4:  MOVF   xA5,W
1AA6:  SUBLW  2F
1AA8:  BTFSC  FD8.0
1AAA:  BRA    1BDA
1AAC:  MOVF   xA5,W
1AAE:  SUBLW  39
1AB0:  BTFSS  FD8.0
1AB2:  BRA    1BDA
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1AB4:  MOVF   xA5,W
1AB6:  SUBLW  30
1AB8:  BNZ   1AFC
1ABA:  CLRF   03
1ABC:  MOVF   xA4,W
1ABE:  ADDWF  x9F,W
1AC0:  MOVWF  FE9
1AC2:  MOVF   xA0,W
1AC4:  ADDWFC 03,W
1AC6:  MOVWF  FEA
1AC8:  MOVF   FEF,W
1ACA:  SUBLW  78
1ACC:  BZ    1AE2
1ACE:  CLRF   03
1AD0:  MOVF   xA4,W
1AD2:  ADDWF  x9F,W
1AD4:  MOVWF  FE9
1AD6:  MOVF   xA0,W
1AD8:  ADDWFC 03,W
1ADA:  MOVWF  FEA
1ADC:  MOVF   FEF,W
1ADE:  SUBLW  58
1AE0:  BNZ   1AFC
....................       { 
....................          base = 16; 
1AE2:  MOVLW  10
1AE4:  MOVWF  xA3
....................          index++; 
1AE6:  INCF   xA4,F
....................          c = s[index++]; 
1AE8:  MOVF   xA4,W
1AEA:  INCF   xA4,F
1AEC:  CLRF   03
1AEE:  ADDWF  x9F,W
1AF0:  MOVWF  FE9
1AF2:  MOVF   xA0,W
1AF4:  ADDWFC 03,W
1AF6:  MOVWF  FEA
1AF8:  MOVFF  FEF,1A5
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1AFC:  MOVF   xA3,W
1AFE:  SUBLW  0A
1B00:  BNZ   1B4A
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
1B02:  MOVF   xA5,W
1B04:  SUBLW  2F
1B06:  BC    1B48
1B08:  MOVF   xA5,W
1B0A:  SUBLW  39
1B0C:  BNC   1B48
1B0E:  CLRF   19
1B10:  BTFSC  FF2.7
1B12:  BSF    19.7
1B14:  BCF    FF2.7
....................             result = 10*result + (c - '0'); 
1B16:  MOVLW  0A
1B18:  MOVWF  xD6
1B1A:  MOVFF  1A1,1D7
1B1E:  MOVLB  0
1B20:  CALL   09E8
1B24:  BTFSC  19.7
1B26:  BSF    FF2.7
1B28:  MOVLW  30
1B2A:  MOVLB  1
1B2C:  SUBWF  xA5,W
1B2E:  ADDWF  01,W
1B30:  MOVWF  xA1
....................             c = s[index++]; 
1B32:  MOVF   xA4,W
1B34:  INCF   xA4,F
1B36:  CLRF   03
1B38:  ADDWF  x9F,W
1B3A:  MOVWF  FE9
1B3C:  MOVF   xA0,W
1B3E:  ADDWFC 03,W
1B40:  MOVWF  FEA
1B42:  MOVFF  FEF,1A5
....................          } 
1B46:  BRA    1B02
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
1B48:  BRA    1BDA
1B4A:  MOVF   xA3,W
1B4C:  SUBLW  10
1B4E:  BNZ   1BDA
....................       { 
....................          c = toupper(c); 
1B50:  MOVF   xA5,W
1B52:  SUBLW  60
1B54:  BC    1B62
1B56:  MOVF   xA5,W
1B58:  SUBLW  7A
1B5A:  BNC   1B62
1B5C:  MOVF   xA5,W
1B5E:  ANDLW  DF
1B60:  BRA    1B64
1B62:  MOVF   xA5,W
1B64:  MOVWF  xA5
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
1B66:  MOVF   xA5,W
1B68:  SUBLW  2F
1B6A:  BC    1B72
1B6C:  MOVF   xA5,W
1B6E:  SUBLW  39
1B70:  BC    1B7E
1B72:  MOVF   xA5,W
1B74:  SUBLW  40
1B76:  BC    1BDA
1B78:  MOVF   xA5,W
1B7A:  SUBLW  46
1B7C:  BNC   1BDA
....................             if (c >= '0' && c <= '9') 
1B7E:  MOVF   xA5,W
1B80:  SUBLW  2F
1B82:  BC    1B9C
1B84:  MOVF   xA5,W
1B86:  SUBLW  39
1B88:  BNC   1B9C
....................                result = (result << 4) + (c - '0'); 
1B8A:  SWAPF  xA1,W
1B8C:  MOVWF  xA6
1B8E:  MOVLW  F0
1B90:  ANDWF  xA6,F
1B92:  MOVLW  30
1B94:  SUBWF  xA5,W
1B96:  ADDWF  xA6,W
1B98:  MOVWF  xA1
....................             else 
1B9A:  BRA    1BAE
....................                result = (result << 4) + (c - 'A' + 10); 
1B9C:  SWAPF  xA1,W
1B9E:  MOVWF  xA6
1BA0:  MOVLW  F0
1BA2:  ANDWF  xA6,F
1BA4:  MOVLW  41
1BA6:  SUBWF  xA5,W
1BA8:  ADDLW  0A
1BAA:  ADDWF  xA6,W
1BAC:  MOVWF  xA1
....................  
....................             c = s[index++]; 
1BAE:  MOVF   xA4,W
1BB0:  INCF   xA4,F
1BB2:  CLRF   03
1BB4:  ADDWF  x9F,W
1BB6:  MOVWF  FE9
1BB8:  MOVF   xA0,W
1BBA:  ADDWFC 03,W
1BBC:  MOVWF  FEA
1BBE:  MOVFF  FEF,1A5
....................             c = toupper(c); 
1BC2:  MOVF   xA5,W
1BC4:  SUBLW  60
1BC6:  BC    1BD4
1BC8:  MOVF   xA5,W
1BCA:  SUBLW  7A
1BCC:  BNC   1BD4
1BCE:  MOVF   xA5,W
1BD0:  ANDLW  DF
1BD2:  BRA    1BD6
1BD4:  MOVF   xA5,W
1BD6:  MOVWF  xA5
....................          } 
1BD8:  BRA    1B66
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
1BDA:  DECFSZ xA2,W
1BDC:  BRA    1BE6
1BDE:  MOVF   xA3,W
1BE0:  SUBLW  0A
1BE2:  BNZ   1BE6
....................        result = -result; 
1BE4:  NEGF   xA1
....................  
....................    return(result); 
1BE6:  MOVFF  1A1,01
.................... } 
1BEA:  MOVLB  0
1BEC:  RETURN 0
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #PRIORITY RDA,RDA2,TIMER0,EXT 
....................  
.................... //----------------------------------------------------------------// 
.................... //-                Conversion Function                           -// 
.................... char chartohex( char valuetoconvert ) 
.................... { 
....................    char convertedval; 
....................       if( valuetoconvert >= 'A' ) 
*
352C:  MOVLB  1
352E:  MOVF   xD1,W
3530:  SUBLW  40
3532:  BC    353E
....................       { 
....................             convertedval = valuetoconvert-'A'+10; 
3534:  MOVLW  41
3536:  SUBWF  xD1,W
3538:  ADDLW  0A
353A:  MOVWF  xD2
....................       }    
....................       else 
353C:  BRA    3544
....................       { 
....................             convertedval = valuetoconvert -'0'; 
353E:  MOVLW  30
3540:  SUBWF  xD1,W
3542:  MOVWF  xD2
....................       } 
....................       return convertedval; 
3544:  MOVFF  1D2,01
.................... } 
3548:  MOVLB  0
354A:  RETURN 0
....................  
.................... //----------------------------------------------------------------// 
.................... //-                Robot Initialisation                          -// 
....................  
.................... void KJunior_init(void) 
.................... { 
*
1670:  MOVLB  1
1672:  CLRF   x97
....................  unsigned int i=0; 
....................  // configure ports direction 
....................  set_tris_a(INIT_TRISA); 
1674:  MOVLW  2F
1676:  MOVWF  F92
....................  set_tris_b(INIT_TRISB); 
1678:  MOVLW  C1
167A:  MOVWF  F93
....................  set_tris_c(INIT_TRISC); 
167C:  MOVLW  9F
167E:  MOVWF  F94
....................  set_tris_d(INIT_TRISD); 
1680:  MOVLW  00
1682:  MOVWF  F95
....................  set_tris_e(INIT_TRISE); 
1684:  MOVWF  F96
....................  set_tris_f(INIT_TRISF); 
1686:  MOVLW  BF
1688:  MOVWF  F97
....................  set_tris_g(INIT_TRISG); 
168A:  MOVLW  04
168C:  MOVWF  F98
....................  
....................  // set default value for each pin 
....................  output_a(INIT_PORTA); 
168E:  CLRF   F89
....................  output_b(INIT_PORTB); 
1690:  CLRF   F8A
....................  output_c(INIT_PORTC); 
1692:  CLRF   F8B
....................  output_d(INIT_PORTD); 
1694:  CLRF   F8C
....................  output_e(INIT_PORTE); 
1696:  CLRF   F8D
....................  output_f(INIT_PORTF); 
1698:  CLRF   F8E
....................  output_g(INIT_PORTG); 
169A:  CLRF   F8F
....................     
....................  
....................  
....................    
....................  setup_oscillator(OSC_16MHZ);                                                   // use internal osc@16 MHz, no clockout 
169C:  MOVLW  70
169E:  MOVWF  FD3
16A0:  CLRF   F9B
16A2:  CLRF   F64
....................  for (i=0;i<=GROUNDRIGHT;i++)                                                   // Init the IR table values and the read the calibrate value in the EEPROM 
16A4:  CLRF   x97
16A6:  MOVF   x97,W
16A8:  SUBLW  0A
16AA:  BTFSS  FD8.0
16AC:  BRA    17D2
....................              { 
....................    IR_Light[i]= 0; 
16AE:  BCF    FD8.0
16B0:  RLCF   x97,W
16B2:  CLRF   03
16B4:  ADDLW  91
16B6:  MOVWF  FE9
16B8:  MOVLW  00
16BA:  ADDWFC 03,W
16BC:  MOVWF  FEA
16BE:  CLRF   FEC
16C0:  MOVF   FED,F
16C2:  CLRF   FEF
....................    IR_Proximity[i] = 0; 
16C4:  BCF    FD8.0
16C6:  RLCF   x97,W
16C8:  CLRF   03
16CA:  ADDLW  A9
16CC:  MOVWF  FE9
16CE:  MOVLW  00
16D0:  ADDWFC 03,W
16D2:  MOVWF  FEA
16D4:  CLRF   FEC
16D6:  MOVF   FED,F
16D8:  CLRF   FEF
....................    IR_Calibrate[i] = read_eeprom((EEPROM_ADD*2*i)+1); 
16DA:  BCF    FD8.0
16DC:  RLCF   x97,W
16DE:  CLRF   03
16E0:  ADDLW  C1
16E2:  MOVWF  FE9
16E4:  MOVLW  00
16E6:  ADDWFC 03,W
16E8:  MOVWF  FEA
16EA:  MOVF   x97,W
16EC:  MULLW  14
16EE:  MOVF   FF3,W
16F0:  ADDLW  01
16F2:  MOVWF  x9A
16F4:  MOVFF  FF2,19B
16F8:  BCF    FF2.7
16FA:  CLRF   F63
16FC:  MOVFF  19A,F62
1700:  BCF    F7F.6
1702:  BCF    F7F.7
1704:  BSF    F7F.0
1706:  MOVF   F61,W
1708:  BTFSC  x9B.7
170A:  BSF    FF2.7
170C:  CLRF   03
170E:  MOVWF  FEF
1710:  MOVFF  03,FEC
1714:  MOVF   FED,F
....................    IR_Calibrate[i] = (signed int16)(IR_Calibrate[i]<<8) + read_eeprom(EEPROM_ADD*2*i); 
1716:  BCF    FD8.0
1718:  RLCF   x97,W
171A:  CLRF   03
171C:  ADDLW  C1
171E:  MOVWF  01
1720:  MOVLW  00
1722:  ADDWFC 03,F
1724:  MOVF   01,W
1726:  MOVWF  x98
1728:  MOVFF  03,199
172C:  BCF    FD8.0
172E:  RLCF   x97,W
1730:  CLRF   03
1732:  ADDLW  C1
1734:  MOVWF  FE9
1736:  MOVLW  00
1738:  ADDWFC 03,W
173A:  MOVWF  FEA
173C:  MOVFF  FEC,19B
1740:  MOVF   FED,F
1742:  MOVFF  FEF,19A
1746:  MOVFF  19A,03
174A:  MOVLW  00
174C:  MOVWF  x9A
174E:  MOVFF  03,19B
1752:  MOVF   x97,W
1754:  MULLW  14
1756:  MOVF   FF3,W
1758:  MOVWF  x9C
175A:  MOVFF  FF2,19D
175E:  BCF    FF2.7
1760:  CLRF   F63
1762:  MOVFF  19C,F62
1766:  BCF    F7F.6
1768:  BCF    F7F.7
176A:  BSF    F7F.0
176C:  MOVF   F61,W
176E:  BTFSC  x9D.7
1770:  BSF    FF2.7
1772:  ADDWF  x9A,W
1774:  MOVWF  01
1776:  MOVLW  00
1778:  ADDWFC x9B,W
177A:  MOVWF  03
177C:  MOVF   01,W
177E:  MOVWF  x9A
1780:  MOVFF  03,19B
1784:  MOVFF  199,FEA
1788:  MOVFF  198,FE9
178C:  MOVFF  19B,FEC
1790:  MOVF   FED,F
1792:  MOVFF  19A,FEF
....................    if(IR_Calibrate[i] == 0xFFFF)                                                // If the Eeprom has not been initialize, reset the value 
1796:  BCF    FD8.0
1798:  RLCF   x97,W
179A:  CLRF   03
179C:  ADDLW  C1
179E:  MOVWF  FE9
17A0:  MOVLW  00
17A2:  ADDWFC 03,W
17A4:  MOVWF  FEA
17A6:  MOVFF  FEC,199
17AA:  MOVF   FED,F
17AC:  MOVFF  FEF,198
17B0:  INCFSZ x98,W
17B2:  BRA    17CE
17B4:  INCFSZ x99,W
17B6:  BRA    17CE
....................      IR_Calibrate[i] = 0; 
17B8:  BCF    FD8.0
17BA:  RLCF   x97,W
17BC:  CLRF   03
17BE:  ADDLW  C1
17C0:  MOVWF  FE9
17C2:  MOVLW  00
17C4:  ADDWFC 03,W
17C6:  MOVWF  FEA
17C8:  CLRF   FEC
17CA:  MOVF   FED,F
17CC:  CLRF   FEF
....................     
....................  }   
17CE:  INCF   x97,F
17D0:  BRA    16A6
....................  PwmMotLeft = 0;                                                                // Init the Speed to 0 
17D2:  CLRF   1A
....................  PwmMotRight = 0; 
17D4:  CLRF   1B
....................   
....................  // Disable IR sensor emitter 
....................  output_low(IR_GROUP1); 
17D6:  BCF    F8C.1
....................  output_low(IR_GROUP2); 
17D8:  BCF    F8C.2
....................  output_low(IR_GROUP3); 
17DA:  BCF    F8C.3
....................   
....................  // init the pin map table for the IR sensor 
....................  // Emitter E0 
....................  IR_AN_Table[0]       = LEFT; 
17DC:  MOVLB  0
17DE:  CLRF   xF3
....................  IR_AN_Table[1]       = FRONT; 
17E0:  MOVLW  02
17E2:  MOVWF  xF4
....................  IR_AN_Table[2]       = RIGHT; 
17E4:  MOVLW  04
17E6:  MOVWF  xF5
....................  // Emitter E1 
....................  IR_AN_Table[3]       = FRONTLEFT; 
17E8:  MOVLW  01
17EA:  MOVWF  xF6
....................  IR_AN_Table[4]       = GROUNDFRONTRIGHT; 
17EC:  MOVLW  08
17EE:  MOVWF  xF7
....................  IR_AN_Table[5]       = GROUNDLEFT; 
17F0:  MOVLW  09
17F2:  MOVWF  xF8
....................  // Emitter E2 
....................  IR_AN_Table[6]       = FRONTRIGHT; 
17F4:  MOVLW  03
17F6:  MOVWF  xF9
....................  IR_AN_Table[7]       = REAR; 
17F8:  MOVLW  05
17FA:  MOVWF  xFA
....................  IR_AN_Table[8]       = GROUNDFRONTLEFT; 
17FC:  MOVLW  07
17FE:  MOVWF  xFB
....................  IR_AN_Table[9]       = GROUNDRIGHT; 
1800:  MOVLW  0A
1802:  MOVWF  xFC
....................   
....................   
....................   
....................    
....................   
....................  
....................  // Setup the adc converter to start with the LEFT IR sensor 
....................  setup_adc_ports(sAN0 | sAN1 | sAN2 | sAN3 | sAN4 | sAN5 | sAN6 | sAN7 | sAN8| sAN9 | sAN10 ); 
1804:  MOVLW  00
1806:  MOVLB  F
1808:  MOVWF  x23
180A:  MOVLW  07
180C:  MOVWF  x24
180E:  MOVLW  FF
1810:  MOVWF  x25
1812:  BCF    FC1.3
1814:  BCF    FC1.4
1816:  BCF    FC1.5
....................  ADCON1 = 0x00;                                                                 // Set the ADC reference to AVdd and AVss 
1818:  CLRF   FC1
....................  //ADCON1 = 0x30;                                                                 // Set the ADC reference to AVdd and AVss 
....................  set_adc_channel( IR_AN_Table[0] ); 
181A:  MOVLB  0
181C:  RLCF   xF3,W
181E:  MOVWF  00
1820:  RLCF   00,F
1822:  MOVLW  FC
1824:  ANDWF  00,F
1826:  MOVF   FC2,W
1828:  ANDLW  83
182A:  IORWF  00,W
182C:  MOVWF  FC2
182E:  MOVLW  00
1830:  MOVWF  01
1832:  MOVF   FC1,W
1834:  ANDLW  F8
1836:  IORWF  01,W
1838:  MOVWF  FC1
....................  ADCON2 = 0xA5;                                                                 // Configure the ADC clock DIV/16 with 8TAD 
183A:  MOVLW  A5
183C:  MOVWF  FC0
....................  ADCON0 |= 0x01;                                                                // Turn on the AD module 
183E:  BSF    FC2.0
....................  enable_interrupts(INT_AD); 
1840:  BSF    F9D.6
....................  
....................  
....................  
....................  // Set the timer 1 used for the internal tasks management 
....................  set_timer1(TIMER1_VALUE);                                                      // set default value to get an interrupt each 250us 
1842:  MOVLW  FC
1844:  MOVWF  FCF
1846:  MOVLW  49
1848:  MOVWF  FCE
....................  setup_timer_1(T1_INTERNAL);                                                    // used for scheduler 
184A:  MOVLW  07
184C:  MOVWF  FCD
184E:  CLRF   FAA
....................  // Activate the interrupts 
....................  enable_interrupts(INT_TIMER1); 
1850:  BSF    F9D.0
....................  if( Enable_RS232_Control == 1 ) 
1852:  BTFSS  22.2
1854:  BRA    185A
....................  { 
....................     enable_interrupts(INT_RDA); 
1856:  BSF    F9D.5
....................     enable_interrupts(INT_RDA2); 
1858:  BSF    FA3.5
.................... //    RCON |= IPEN;                                                               // Enable the level interrupt 
....................  } 
....................  while(kbhit(BT)) fgetc(BT);                                                    // Flush the RS232 buffer 
185A:  BTFSS  FA4.5
185C:  BRA    186A
185E:  BTFSS  FA4.5
1860:  BRA    185E
1862:  MOVLB  F
1864:  MOVF   x1D,W
1866:  MOVLB  0
1868:  BRA    185A
....................  while(kbhit(USB)) fgetc(USB); 
186A:  BTFSS  F9E.5
186C:  BRA    1876
186E:  BTFSS  F9E.5
1870:  BRA    186E
1872:  MOVF   FAE,W
1874:  BRA    186A
....................   
....................  // Read the Switch the first time 
....................  Switchs  =   !input(MODE1);         
1876:  MOVLB  1
1878:  CLRF   x01
187A:  BTFSS  F82.0
187C:  INCF   x01,F
....................  Switchs |= ((!input(MODE2))<<1);    
187E:  MOVLW  00
1880:  BTFSS  F82.1
1882:  MOVLW  01
1884:  MOVWF  00
1886:  BCF    FD8.0
1888:  RLCF   00,F
188A:  MOVF   00,W
188C:  IORWF  x01,F
....................  Switchs |= ((!input(MODE3))<<2);    
188E:  MOVLW  00
1890:  BTFSS  F82.2
1892:  MOVLW  01
1894:  MOVWF  00
1896:  RLCF   00,F
1898:  RLCF   00,F
189A:  MOVLW  FC
189C:  ANDWF  00,F
189E:  MOVF   00,W
18A0:  IORWF  x01,F
....................   
....................  setup_timer_0(T0_OFF);                                                         // used for Rc5 decoding, Initially OFF 
18A2:  CLRF   FD5
....................   
....................  setup_timer_3(T3_DISABLED | T3_DIV_BY_4);                                      // Configure the Timer3 for the buzzer, initially OFF 
18A4:  CLRF   FB0
18A6:  MOVLW  20
18A8:  MOVWF  FB1
....................  Buzzer_Table[1] = BUZ_DO;                                                      // Configure the frequency note table 
18AA:  MOVLW  F8
18AC:  MOVWF  x0B
18AE:  MOVLW  8A
18B0:  MOVWF  x0A
....................  Buzzer_Table[2] = BUZ_RE_BEMOL; 
18B2:  MOVLW  F8
18B4:  MOVWF  x0D
18B6:  MOVLW  F1
18B8:  MOVWF  x0C
....................  Buzzer_Table[3] = BUZ_RE; 
18BA:  MOVLW  F9
18BC:  MOVWF  x0F
18BE:  MOVLW  5A
18C0:  MOVWF  x0E
....................  Buzzer_Table[4] = BUZ_MI_BEMOL; 
18C2:  MOVLW  F9
18C4:  MOVWF  x11
18C6:  MOVLW  B7
18C8:  MOVWF  x10
....................  Buzzer_Table[5] = BUZ_MI; 
18CA:  MOVLW  FA
18CC:  MOVWF  x13
18CE:  MOVLW  13
18D0:  MOVWF  x12
....................  Buzzer_Table[6] = BUZ_FA; 
18D2:  MOVLW  FA
18D4:  MOVWF  x15
18D6:  MOVLW  73
18D8:  MOVWF  x14
....................  Buzzer_Table[7] = BUZ_SOL_BEMOL; 
18DA:  MOVLW  FA
18DC:  MOVWF  x17
18DE:  MOVLW  B7
18E0:  MOVWF  x16
....................  Buzzer_Table[8] = BUZ_SOL; 
18E2:  MOVLW  FB
18E4:  MOVWF  x19
18E6:  MOVLW  03
18E8:  MOVWF  x18
....................  Buzzer_Table[9] = BUZ_LA_BEMOL; 
18EA:  MOVLW  FB
18EC:  MOVWF  x1B
18EE:  MOVLW  4A
18F0:  MOVWF  x1A
....................  Buzzer_Table[10] = BUZ_LA; 
18F2:  MOVLW  FB
18F4:  MOVWF  x1D
18F6:  MOVLW  8E
18F8:  MOVWF  x1C
....................  Buzzer_Table[11] = BUZ_SI_BEMOL; 
18FA:  MOVLW  FB
18FC:  MOVWF  x1F
18FE:  MOVLW  CE
1900:  MOVWF  x1E
....................  Buzzer_Table[12] = BUZ_SI; 
1902:  MOVLW  FC
1904:  MOVWF  x21
1906:  MOVLW  0A
1908:  MOVWF  x20
....................   
....................  
....................  setup_timer_4(T4_DIV_BY_1,MOTOR_MAX,1);                                        // Configure the PWM motor at 20kHz 
190A:  MOVLW  00
190C:  IORLW  04
190E:  MOVWF  F6B
1910:  MOVLW  C8
1912:  MOVWF  F6C
....................   
....................  CCP1CON = 0x0C;                                                                // Configure the ECCP1 module in single PWM mode 
1914:  MOVLW  0C
1916:  MOVWF  FBB
....................  CCP3CON = 0x0C;                                                                // Configure the ECCP3 module in single PWM mode 
1918:  MOVLB  F
191A:  MOVWF  x49
....................   
....................  CCPTMRS0 = 0x41;                                                               // Select the Timer4 for the Motor, and the Timer2 for the Buzzer 
191C:  MOVLW  41
191E:  MOVWF  x2D
....................  PSTR1CON = 0x00;                                                               // Set M1_A and M1_B as standard output 
1920:  CLRF   F9C
....................  PSTR3CON = 0x00;                                                               // Set M2_A and M2_B as standard output 
1922:  CLRF   x1A
....................   
....................  // Configure the I2C bus 
....................  SSP1CON1 = 0x28;                                                               // Configure the I2C bus as Master and enable it 
1924:  MOVLW  28
1926:  MOVWF  FC6
....................  
....................  
....................  // Enable and configure the interrupts 
....................  ext_int_edge(H_TO_L);                                                          
1928:  BCF    FF1.6
....................  enable_interrupts(INT_EXT); 
192A:  BSF    FF2.4
....................  enable_interrupts(GLOBAL); 
192C:  MOVLW  C0
192E:  IORWF  FF2,F
....................  
....................  
....................  // Display boot message 
....................  delay_ms(50); 
1930:  MOVLW  32
1932:  MOVLB  1
1934:  MOVWF  x99
1936:  MOVLB  0
1938:  RCALL  13F2
....................   
....................  fprintf(USB,"\r\nK-Junior v2 Operating System\r\n"); 
193A:  MOVLW  F6
193C:  MOVWF  FF6
193E:  MOVLW  00
1940:  MOVWF  FF7
1942:  RCALL  141C
....................  fprintf(USB,"kJOS %s-%02d (%s), K-Team SA\r\n",KJ_FW_VERSION,KJ_FW_REVISION, KJ_FW_REFERENCE ); 
1944:  MOVLW  18
1946:  MOVWF  FF6
1948:  MOVLW  01
194A:  MOVWF  FF7
194C:  MOVLW  05
194E:  MOVLB  1
1950:  MOVWF  xA1
1952:  MOVLB  0
1954:  RCALL  143E
1956:  MOVLW  38
1958:  MOVWF  FF6
195A:  MOVLW  01
195C:  MOVWF  FF7
195E:  RCALL  141C
1960:  MOVLW  2D
1962:  BTFSS  F9E.4
1964:  BRA    1962
1966:  MOVWF  FAD
1968:  MOVLW  01
196A:  MOVLB  1
196C:  MOVWF  x98
196E:  MOVWF  x99
1970:  MOVLB  0
1972:  RCALL  1494
1974:  MOVLW  20
1976:  BTFSS  F9E.4
1978:  BRA    1976
197A:  MOVWF  FAD
197C:  MOVLW  28
197E:  BTFSS  F9E.4
1980:  BRA    197E
1982:  MOVWF  FAD
1984:  MOVLW  3A
1986:  MOVWF  FF6
1988:  MOVLW  01
198A:  MOVWF  FF7
198C:  RCALL  141C
198E:  MOVLW  28
1990:  MOVWF  FF6
1992:  MOVLW  01
1994:  MOVWF  FF7
1996:  MOVLW  0E
1998:  MOVLB  1
199A:  MOVWF  xA1
199C:  MOVLB  0
199E:  RCALL  143E
....................  fprintf(USB,"E-Mail : info@k-team.com\r\n"); 
19A0:  MOVLW  44
19A2:  MOVWF  FF6
19A4:  MOVLW  01
19A6:  MOVWF  FF7
19A8:  RCALL  141C
....................  fprintf(BT,"\r\nK-Junior v2 Operating System\r\n"); 
19AA:  MOVLW  60
19AC:  MOVWF  FF6
19AE:  MOVLW  01
19B0:  MOVWF  FF7
19B2:  RCALL  1552
....................  fprintf(BT,"kJOS %s-%02d (%s), K-Team SA\r\n",KJ_FW_VERSION,KJ_FW_REVISION, KJ_FW_REFERENCE ); 
19B4:  MOVLW  82
19B6:  MOVWF  FF6
19B8:  MOVLW  01
19BA:  MOVWF  FF7
19BC:  MOVLW  05
19BE:  MOVLB  1
19C0:  MOVWF  x98
19C2:  MOVLB  0
19C4:  RCALL  1578
19C6:  MOVLW  A2
19C8:  MOVWF  FF6
19CA:  MOVLW  01
19CC:  MOVWF  FF7
19CE:  RCALL  1552
19D0:  MOVLW  2D
19D2:  BTFSS  FA4.4
19D4:  BRA    19D2
19D6:  MOVLB  F
19D8:  MOVWF  x1C
19DA:  MOVLW  01
19DC:  MOVLB  1
19DE:  MOVWF  x98
19E0:  MOVWF  x99
19E2:  MOVLB  0
19E4:  RCALL  15A4
19E6:  MOVLW  20
19E8:  BTFSS  FA4.4
19EA:  BRA    19E8
19EC:  MOVLB  F
19EE:  MOVWF  x1C
19F0:  MOVLW  28
19F2:  BTFSS  FA4.4
19F4:  BRA    19F2
19F6:  MOVWF  x1C
19F8:  MOVLW  A4
19FA:  MOVWF  FF6
19FC:  MOVLW  01
19FE:  MOVWF  FF7
1A00:  MOVLB  0
1A02:  RCALL  1552
1A04:  MOVLW  92
1A06:  MOVWF  FF6
1A08:  MOVLW  01
1A0A:  MOVWF  FF7
1A0C:  MOVLW  0E
1A0E:  MOVLB  1
1A10:  MOVWF  x98
1A12:  MOVLB  0
1A14:  RCALL  1578
....................  fprintf(BT,"E-Mail : info@k-team.com\r\n"); 
1A16:  MOVLW  AE
1A18:  MOVWF  FF6
1A1A:  MOVLW  01
1A1C:  MOVWF  FF7
1A1E:  RCALL  1552
....................  
....................  
....................  
.................... } 
1A20:  GOTO   4DF4 (RETURN)
....................  
.................... //---------------------------------------------------------------// 
.................... // Convert the intial motor value (0-20) to the final PWM (0-100%) 
.................... //---------------------------------------------------------------// 
.................... void Set_left_motor(void) 
.................... { 
....................       if(PwmMotLeft == 0)                                                       // Stop the motor left 
*
0AD4:  MOVF   1A,F
0AD6:  BNZ   0AE4
....................       { 
....................         set_pwm3_duty(0);                                                       // Set the duty cycle to 0 
0AD8:  MOVLB  F
0ADA:  CLRF   x4A
....................         PSTR3CON = 0x00;                                                        // Set M2_A and M2_B as standard output 
0ADC:  CLRF   x1A
....................         return; 
0ADE:  BRA    0B7A
....................       } 
....................       else if(PwmMotLeft > 0) 
0AE0:  BRA    0B76
0AE2:  MOVLB  0
0AE4:  BTFSC  1A.7
0AE6:  BRA    0B28
0AE8:  MOVF   1A,W
0AEA:  SUBLW  00
0AEC:  BC    0B28
....................       { 
....................         if((PwmMotLeft < SPEED_MIN) && (Old_PwmMotLeft <= 0) && (PwmMotLeft != Old_PwmMotLeft))            // If the actual and new speed is too low 
0AEE:  BTFSC  1A.7
0AF0:  BRA    0AF8
0AF2:  MOVF   1A,W
0AF4:  SUBLW  0E
0AF6:  BNC   0B0A
0AF8:  BTFSC  1D.7
0AFA:  BRA    0B02
0AFC:  MOVF   1D,W
0AFE:  SUBLW  00
0B00:  BNC   0B0A
0B02:  MOVF   1D,W
0B04:  SUBWF  1A,W
0B06:  BZ    0B0A
....................          Acceleration_flag |= ACCEL_LEFT; 
0B08:  BSF    21.0
....................         TimerMotLeft = (MOTOR_CONV * PwmMotLeft)+MOTOR_MIN;                     // calculate the duty cycle 
0B0A:  MOVLW  07
0B0C:  MOVLB  1
0B0E:  MOVWF  xD6
0B10:  MOVFF  1A,1D7
0B14:  MOVLB  0
0B16:  RCALL  09E8
0B18:  MOVLW  3C
0B1A:  ADDWF  01,W
0B1C:  MOVWF  1E
....................         PSTR3CON = 0x04;                                                        // Enable M2_A as PWM output 
0B1E:  MOVLW  04
0B20:  MOVLB  F
0B22:  MOVWF  x1A
....................       } 
....................       else 
0B24:  BRA    0B76
0B26:  MOVLB  0
....................       { 
....................         if((-PwmMotLeft < SPEED_MIN) && (-Old_PwmMotLeft <= 0) && (PwmMotLeft != Old_PwmMotLeft))          // If the actual and new speed is too low 
0B28:  MOVLW  00
0B2A:  BSF    FD8.0
0B2C:  SUBFWB 1A,W
0B2E:  MOVWF  00
0B30:  BTFSC  FE8.7
0B32:  BRA    0B3A
0B34:  MOVF   00,W
0B36:  SUBLW  0E
0B38:  BNC   0B54
0B3A:  MOVLW  00
0B3C:  BSF    FD8.0
0B3E:  SUBFWB 1D,W
0B40:  MOVWF  00
0B42:  BTFSC  FE8.7
0B44:  BRA    0B4C
0B46:  MOVF   00,W
0B48:  SUBLW  00
0B4A:  BNC   0B54
0B4C:  MOVF   1D,W
0B4E:  SUBWF  1A,W
0B50:  BZ    0B54
....................          Acceleration_flag |= ACCEL_LEFT; 
0B52:  BSF    21.0
....................         TimerMotLeft = (MOTOR_CONV * -PwmMotLeft)+MOTOR_MIN;                    // calculate the duty cycle 
0B54:  MOVLW  00
0B56:  BSF    FD8.0
0B58:  SUBFWB 1A,W
0B5A:  MOVLB  1
0B5C:  MOVWF  xD5
0B5E:  MOVLW  07
0B60:  MOVWF  xD6
0B62:  MOVFF  1D5,1D7
0B66:  MOVLB  0
0B68:  RCALL  09E8
0B6A:  MOVLW  3C
0B6C:  ADDWF  01,W
0B6E:  MOVWF  1E
....................         PSTR3CON = 0x02;                                                        // And enable M2_B as PWM output 
0B70:  MOVLW  02
0B72:  MOVLB  F
0B74:  MOVWF  x1A
....................       } 
....................       set_pwm3_duty(TimerMotLeft);                                              // Set the duty cycle 
0B76:  MOVFF  1E,F4A
....................  
.................... } 
0B7A:  MOVLB  0
0B7C:  RETURN 0
....................  
.................... void Set_right_motor(void) 
.................... { 
....................       if(PwmMotRight == 0)                                                       // Stop the motor right 
*
0A36:  MOVF   1B,F
0A38:  BNZ   0A42
....................       { 
....................         set_pwm1_duty(0);                                                       // Set the duty cycle to 0 
0A3A:  CLRF   FBC
....................         PSTR1CON = 0x00;                                                        // Set M2_A and M2_B as standard output 
0A3C:  CLRF   F9C
....................         return; 
0A3E:  BRA    0AD2
....................       } 
....................       else if(PwmMotRight > 0) 
0A40:  BRA    0ACE
0A42:  BTFSC  1B.7
0A44:  BRA    0A82
0A46:  MOVF   1B,W
0A48:  SUBLW  00
0A4A:  BC    0A82
....................       { 
....................         if((PwmMotRight < SPEED_MIN) && (Old_PwmMotRight <= 0) && (PwmMotRight != Old_PwmMotRight))            // If the actual and new speed is too low 
0A4C:  BTFSC  1B.7
0A4E:  BRA    0A56
0A50:  MOVF   1B,W
0A52:  SUBLW  0E
0A54:  BNC   0A68
0A56:  BTFSC  1C.7
0A58:  BRA    0A60
0A5A:  MOVF   1C,W
0A5C:  SUBLW  00
0A5E:  BNC   0A68
0A60:  MOVF   1C,W
0A62:  SUBWF  1B,W
0A64:  BZ    0A68
....................          Acceleration_flag |= ACCEL_RIGHT; 
0A66:  BSF    21.1
....................         TimerMotRight = (MOTOR_CONV * PwmMotRight)+MOTOR_MIN;                   // Calculate the duty cycle 
0A68:  MOVLW  07
0A6A:  MOVLB  1
0A6C:  MOVWF  xD6
0A6E:  MOVFF  1B,1D7
0A72:  MOVLB  0
0A74:  RCALL  09E8
0A76:  MOVLW  3C
0A78:  ADDWF  01,W
0A7A:  MOVWF  1F
....................         PSTR1CON = 0x04;                                                        // And enable M1_A as PWM output 
0A7C:  MOVLW  04
0A7E:  MOVWF  F9C
....................       } 
....................       else 
0A80:  BRA    0ACE
....................       { 
....................         if((-PwmMotRight < SPEED_MIN) && (-Old_PwmMotRight <= 0) && (PwmMotRight != Old_PwmMotRight))            // If the actual and new speed is too low 
0A82:  MOVLW  00
0A84:  BSF    FD8.0
0A86:  SUBFWB 1B,W
0A88:  MOVWF  00
0A8A:  BTFSC  FE8.7
0A8C:  BRA    0A94
0A8E:  MOVF   00,W
0A90:  SUBLW  0E
0A92:  BNC   0AAE
0A94:  MOVLW  00
0A96:  BSF    FD8.0
0A98:  SUBFWB 1C,W
0A9A:  MOVWF  00
0A9C:  BTFSC  FE8.7
0A9E:  BRA    0AA6
0AA0:  MOVF   00,W
0AA2:  SUBLW  00
0AA4:  BNC   0AAE
0AA6:  MOVF   1C,W
0AA8:  SUBWF  1B,W
0AAA:  BZ    0AAE
....................          Acceleration_flag |= ACCEL_RIGHT; 
0AAC:  BSF    21.1
....................         TimerMotRight = (MOTOR_CONV * -PwmMotRight)+MOTOR_MIN;                  // Calculate the duty cycle 
0AAE:  MOVLW  00
0AB0:  BSF    FD8.0
0AB2:  SUBFWB 1B,W
0AB4:  MOVLB  1
0AB6:  MOVWF  xD5
0AB8:  MOVLW  07
0ABA:  MOVWF  xD6
0ABC:  MOVFF  1D5,1D7
0AC0:  MOVLB  0
0AC2:  RCALL  09E8
0AC4:  MOVLW  3C
0AC6:  ADDWF  01,W
0AC8:  MOVWF  1F
....................         PSTR1CON = 0x02;                                                        // And enable M1_B as PWM output 
0ACA:  MOVLW  02
0ACC:  MOVWF  F9C
....................       }  
....................       set_pwm1_duty(TimerMotRight); 
0ACE:  MOVFF  1F,FBC
....................  
.................... } 
0AD2:  RETURN 0
....................  
....................  
.................... void  Motor_Conversion(void) 
.................... { 
....................    Acceleration_flag = 0;                                                       // reset the flag 
*
0B7E:  CLRF   21
....................    Set_right_motor();                                                           // Set the right motor PWM 
0B80:  RCALL  0A36
....................    Set_left_motor();                                                            // Set the left motor PWM 
0B82:  RCALL  0AD4
....................    if(Acceleration_flag != 0)                                                   // If too low speed is set, make a small acceleration on the desired motor 
0B84:  MOVF   21,F
0B86:  BZ    0BA0
....................    { 
....................      if(Acceleration_flag & ACCEL_RIGHT) 
0B88:  BTFSS  21.1
0B8A:  BRA    0B90
....................      { 
....................        set_pwm1_duty(MOTOR_MAX);                                                // make a small acceleration to start the rotation of the motor 
0B8C:  MOVLW  C8
0B8E:  MOVWF  FBC
....................      } 
....................      if(Acceleration_flag & ACCEL_LEFT) 
0B90:  BTFSS  21.0
0B92:  BRA    0B9C
....................      { 
....................        set_pwm3_duty(MOTOR_MAX);                                                // make a small acceleration to start the rotation of the motor 
0B94:  MOVLW  C8
0B96:  MOVLB  F
0B98:  MOVWF  x4A
0B9A:  MOVLB  0
....................      } 
....................      Acceleration_Timer = ACCEL;                                                // Set the timer to stop the acceleration after x ms 
0B9C:  MOVLW  1E
0B9E:  MOVWF  20
....................    } 
....................    Old_PwmMotLeft = PwmMotLeft;                                                 // Save the speed value  
0BA0:  MOVFF  1A,1D
....................    Old_PwmMotRight = PwmMotRight; 
0BA4:  MOVFF  1B,1C
.................... } 
0BA8:  RETURN 0
....................  
.................... //---------------------------------------------------------------// 
.................... // Convert the intial buzzer value (0-48) to the corresponding frequency note 
.................... //---------------------------------------------------------------// 
.................... void Set_Freq_note(void) 
.................... { 
....................   if(buzzValue == 0)                                                            // Turn off the buzzer 
*
273C:  MOVLB  1
273E:  MOVF   x05,F
2740:  BNZ   274E
....................   { 
....................     disable_interrupts(INT_TIMER3); 
2742:  BCF    FA0.1
....................     setup_timer_3(T3_DISABLED | T3_DIV_BY_4); 
2744:  CLRF   FB0
2746:  MOVLW  20
2748:  MOVWF  FB1
....................     output_low(BUZZER); 
274A:  BCF    F8D.2
....................   } 
....................   else 
274C:  BRA    2810
....................   { 
....................     if(buzzValue <= 12 )                                                        // Octave n°2 (131Hz-247Hz) 
274E:  MOVF   x05,W
2750:  SUBLW  0C
2752:  BNC   277A
....................     { 
....................       Buzzer_Timer = Buzzer_Table[buzzValue];                                   // Set the timer3 to the frequency of the selected note 
2754:  BCF    FD8.0
2756:  RLCF   x05,W
2758:  CLRF   03
275A:  ADDLW  08
275C:  MOVWF  FE9
275E:  MOVLW  01
2760:  ADDWFC 03,W
2762:  MOVWF  FEA
2764:  MOVFF  FEC,03
2768:  MOVF   FED,F
276A:  MOVFF  FEF,106
276E:  MOVFF  03,107
....................       setup_timer_3(T3_INTERNAL | T3_DIV_BY_8);                                 // Set the timer to play on the second Octave 
2772:  CLRF   FB0
2774:  MOVLW  37
2776:  MOVWF  FB1
....................     } 
....................     else if(buzzValue <= 24 )                                                   // Octave n°3 (262Hz-494Hz) 
2778:  BRA    280E
277A:  MOVF   x05,W
277C:  SUBLW  18
277E:  BNC   27AE
....................     { 
....................       Buzzer_Timer = Buzzer_Table[buzzValue-12];                                // Set the timer3 to the frequency of the selected note 
2780:  MOVLW  0C
2782:  SUBWF  x05,W
2784:  MOVWF  00
2786:  BCF    FD8.0
2788:  RLCF   00,F
278A:  MOVF   00,W
278C:  CLRF   03
278E:  ADDLW  08
2790:  MOVWF  FE9
2792:  MOVLW  01
2794:  ADDWFC 03,W
2796:  MOVWF  FEA
2798:  MOVFF  FEC,03
279C:  MOVF   FED,F
279E:  MOVFF  FEF,106
27A2:  MOVFF  03,107
....................       setup_timer_3(T3_INTERNAL | T3_DIV_BY_4);                                 // Set the timer to play on the third Octave 
27A6:  CLRF   FB0
27A8:  MOVLW  27
27AA:  MOVWF  FB1
....................     } 
....................     else if(buzzValue <= 36 )                                                   // Octave n°4 (523Hz-988Hz) 
27AC:  BRA    280E
27AE:  MOVF   x05,W
27B0:  SUBLW  24
27B2:  BNC   27E2
....................     { 
....................       Buzzer_Timer = Buzzer_Table[buzzValue-24];                                // Set the timer3 to the frequency of the selected note 
27B4:  MOVLW  18
27B6:  SUBWF  x05,W
27B8:  MOVWF  00
27BA:  BCF    FD8.0
27BC:  RLCF   00,F
27BE:  MOVF   00,W
27C0:  CLRF   03
27C2:  ADDLW  08
27C4:  MOVWF  FE9
27C6:  MOVLW  01
27C8:  ADDWFC 03,W
27CA:  MOVWF  FEA
27CC:  MOVFF  FEC,03
27D0:  MOVF   FED,F
27D2:  MOVFF  FEF,106
27D6:  MOVFF  03,107
....................       setup_timer_3(T3_INTERNAL | T3_DIV_BY_2);                                 // Set the timer to play on the fourth Octave 
27DA:  CLRF   FB0
27DC:  MOVLW  17
27DE:  MOVWF  FB1
....................     } 
....................     else                                                                        // Octave n°5 (1046.5Hz-1975Hz) 
27E0:  BRA    280E
....................     { 
....................       Buzzer_Timer = Buzzer_Table[buzzValue-36];                                // Set the timer3 to the frequency of the selected note 
27E2:  MOVLW  24
27E4:  SUBWF  x05,W
27E6:  MOVWF  00
27E8:  BCF    FD8.0
27EA:  RLCF   00,F
27EC:  MOVF   00,W
27EE:  CLRF   03
27F0:  ADDLW  08
27F2:  MOVWF  FE9
27F4:  MOVLW  01
27F6:  ADDWFC 03,W
27F8:  MOVWF  FEA
27FA:  MOVFF  FEC,03
27FE:  MOVF   FED,F
2800:  MOVFF  FEF,106
2804:  MOVFF  03,107
....................       setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);                                 // Set the timer to play on the fifth Octave 
2808:  CLRF   FB0
280A:  MOVLW  07
280C:  MOVWF  FB1
....................     } 
....................     enable_interrupts(INT_TIMER3); 
280E:  BSF    FA0.1
....................   } 
....................  
.................... } 
2810:  MOVLB  0
2812:  GOTO   28AC (RETURN)
....................  
....................  
.................... //---------------------------------------------------------------// 
.................... //-                        TV Remote                            -// 
....................  
.................... // TV Remote Control 
.................... void TV_Remote_Control( void ) 
.................... { 
....................    switch( TV_DATA ) 
....................    { 
*
0DC2:  MOVF   x84,W
0DC4:  XORLW  01
0DC6:  BZ    0DF6
0DC8:  XORLW  03
0DCA:  BZ    0E00
0DCC:  XORLW  01
0DCE:  BZ    0E08
0DD0:  XORLW  07
0DD2:  BZ    0E12
0DD4:  XORLW  01
0DD6:  BZ    0E1C
0DD8:  XORLW  03
0DDA:  BZ    0E22
0DDC:  XORLW  01
0DDE:  BZ    0E2C
0DE0:  XORLW  0F
0DE2:  BZ    0E36
0DE4:  XORLW  01
0DE6:  BZ    0E3E
0DE8:  XORLW  05
0DEA:  BZ    0E48
0DEC:  XORLW  1C
0DEE:  BZ    0E4C
0DF0:  XORLW  01
0DF2:  BZ    0E50
0DF4:  BRA    0E54
....................       case 1 : 
....................          PwmMotLeft = 5; 
0DF6:  MOVLW  05
0DF8:  MOVWF  1A
....................          PwmMotRight = 18; 
0DFA:  MOVLW  12
0DFC:  MOVWF  1B
....................          break; 
0DFE:  BRA    0E56
....................       case 2 : 
....................          PwmMotLeft = 14; 
0E00:  MOVLW  0E
0E02:  MOVWF  1A
....................          PwmMotRight = 14; 
0E04:  MOVWF  1B
....................          break; 
0E06:  BRA    0E56
....................       case 3 : 
....................          PwmMotLeft = 18; 
0E08:  MOVLW  12
0E0A:  MOVWF  1A
....................          PwmMotRight = 5; 
0E0C:  MOVLW  05
0E0E:  MOVWF  1B
....................          break; 
0E10:  BRA    0E56
....................       case 4: 
....................          PwmMotLeft = -14; 
0E12:  MOVLW  F2
0E14:  MOVWF  1A
....................          PwmMotRight = 14; 
0E16:  MOVLW  0E
0E18:  MOVWF  1B
....................          break; 
0E1A:  BRA    0E56
....................       case 5 : 
....................          PwmMotLeft = 0; 
0E1C:  CLRF   1A
....................          PwmMotRight = 0; 
0E1E:  CLRF   1B
....................          break; 
0E20:  BRA    0E56
....................       case 6 : 
....................          PwmMotLeft = 14; 
0E22:  MOVLW  0E
0E24:  MOVWF  1A
....................          PwmMotRight = -14; 
0E26:  MOVLW  F2
0E28:  MOVWF  1B
....................          break; 
0E2A:  BRA    0E56
....................       case 7 : 
....................          PwmMotLeft = -5; 
0E2C:  MOVLW  FB
0E2E:  MOVWF  1A
....................          PwmMotRight = -18; 
0E30:  MOVLW  EE
0E32:  MOVWF  1B
....................          break; 
0E34:  BRA    0E56
....................       case 8: 
....................          PwmMotLeft = -14; 
0E36:  MOVLW  F2
0E38:  MOVWF  1A
....................          PwmMotRight = -14; 
0E3A:  MOVWF  1B
....................          break; 
0E3C:  BRA    0E56
....................       case 9 : 
....................          PwmMotLeft = -18; 
0E3E:  MOVLW  EE
0E40:  MOVWF  1A
....................          PwmMotRight = -5; 
0E42:  MOVLW  FB
0E44:  MOVWF  1B
....................          break; 
0E46:  BRA    0E56
....................       case 12 :            // Touche On/Off 
....................          return; 
0E48:  BRA    0E58
....................          break; 
0E4A:  BRA    0E56
....................       case 16 :            // Touche Son + 
....................          return; 
0E4C:  BRA    0E58
....................          break; 
0E4E:  BRA    0E56
....................       case 17 :            // Touche Son - 
....................          return; 
0E50:  BRA    0E58
....................          break; 
0E52:  BRA    0E56
....................       default: 
....................         return; 
0E54:  BRA    0E58
....................         break; 
....................    } 
....................    Motor_Conversion();   
0E56:  RCALL  0B7E
.................... } 
0E58:  GOTO   0F6E (RETURN)
.................... #INT_AD 
.................... void Analog_Interrupt(void) 
.................... { 
....................     
....................    // Read the battery voltage 
....................    if(IR_ADC_flag == 0) 
*
01CA:  MOVF   xF2,F
01CC:  BNZ   0214
....................    {    
....................      BatteryVoltage = read_adc(ADC_READ_ONLY);                                // Read the battery voltage 
01CE:  BTFSC  FC2.1
01D0:  BRA    01CE
01D2:  MOVFF  FC3,FF
01D6:  MOVFF  FC4,100
....................      IR_ADC_flag++; 
01DA:  INCF   xF2,F
....................      set_adc_channel(IR_AN_Table[ IR_Counter ]);                                // Set the analog input to the first sensor 
01DC:  CLRF   03
01DE:  MOVF   xF1,W
01E0:  ADDLW  F3
01E2:  MOVWF  FE9
01E4:  MOVLW  00
01E6:  ADDWFC 03,W
01E8:  MOVWF  FEA
01EA:  MOVFF  FEF,1D4
01EE:  MOVLB  1
01F0:  RLCF   xD4,W
01F2:  MOVWF  00
01F4:  RLCF   00,F
01F6:  MOVLW  FC
01F8:  ANDWF  00,F
01FA:  MOVF   FC2,W
01FC:  ANDLW  83
01FE:  IORWF  00,W
0200:  MOVWF  FC2
0202:  MOVLW  00
0204:  MOVWF  01
0206:  MOVF   FC1,W
0208:  ANDLW  F8
020A:  IORWF  01,W
020C:  MOVWF  FC1
....................    } 
....................   
....................     // Read all the ambiant value 
....................    else if(IR_ADC_flag == 1) 
020E:  GOTO   09E0
0212:  MOVLB  0
0214:  DECFSZ xF2,W
0216:  BRA    02C6
....................    { 
....................      IR_light[IR_AN_Table[ IR_Counter ]] = read_adc(ADC_READ_ONLY);             // Read the ambiant light value 
0218:  CLRF   03
021A:  MOVF   xF1,W
021C:  ADDLW  F3
021E:  MOVWF  FE9
0220:  MOVLW  00
0222:  ADDWFC 03,W
0224:  MOVWF  FEA
0226:  BCF    FD8.0
0228:  RLCF   FEF,W
022A:  CLRF   03
022C:  ADDLW  91
022E:  MOVWF  FE9
0230:  MOVLW  00
0232:  ADDWFC 03,W
0234:  MOVWF  FEA
0236:  BTFSC  FC2.1
0238:  BRA    0236
023A:  MOVFF  FC3,FEF
023E:  MOVFF  FC4,FEC
....................      if(++IR_Counter >= NB_IR)                                                   // If all the ambiant light value are readed 
0242:  INCF   xF1,F
0244:  MOVF   xF1,W
0246:  SUBLW  09
0248:  BC    0284
....................      { 
....................        IR_Counter = 0;                                                          // Reset the counter 
024A:  CLRF   xF1
....................        set_adc_channel(IR_AN_Table[ IR_Counter ]);                              // And set the Analog input to the first IR 
024C:  CLRF   03
024E:  MOVF   xF1,W
0250:  ADDLW  F3
0252:  MOVWF  FE9
0254:  MOVLW  00
0256:  ADDWFC 03,W
0258:  MOVWF  FEA
025A:  MOVFF  FEF,1D4
025E:  MOVLB  1
0260:  RLCF   xD4,W
0262:  MOVWF  00
0264:  RLCF   00,F
0266:  MOVLW  FC
0268:  ANDWF  00,F
026A:  MOVF   FC2,W
026C:  ANDLW  83
026E:  IORWF  00,W
0270:  MOVWF  FC2
0272:  MOVLW  00
0274:  MOVWF  01
0276:  MOVF   FC1,W
0278:  ANDLW  F8
027A:  IORWF  01,W
027C:  MOVWF  FC1
....................        IR_ADC_flag++; 
027E:  MOVLB  0
0280:  INCF   xF2,F
....................      } 
....................      else 
0282:  BRA    02C4
....................      { 
....................        set_adc_channel(IR_AN_Table[ IR_Counter ]);                              // Set the analog input to next sensor 
0284:  CLRF   03
0286:  MOVF   xF1,W
0288:  ADDLW  F3
028A:  MOVWF  FE9
028C:  MOVLW  00
028E:  ADDWFC 03,W
0290:  MOVWF  FEA
0292:  MOVFF  FEF,1D4
0296:  MOVLB  1
0298:  RLCF   xD4,W
029A:  MOVWF  00
029C:  RLCF   00,F
029E:  MOVLW  FC
02A0:  ANDWF  00,F
02A2:  MOVF   FC2,W
02A4:  ANDLW  83
02A6:  IORWF  00,W
02A8:  MOVWF  FC2
02AA:  MOVLW  00
02AC:  MOVWF  01
02AE:  MOVF   FC1,W
02B0:  ANDLW  F8
02B2:  IORWF  01,W
02B4:  MOVWF  FC1
....................        delay_us(2); 
02B6:  MOVLW  02
02B8:  MOVWF  00
02BA:  DECFSZ 00,F
02BC:  BRA    02BA
02BE:  NOP   
....................        read_adc(ADC_START_ONLY);                                                // Start the new conversion 
02C0:  BSF    FC2.1
02C2:  MOVLB  0
....................      } 
....................    } 
....................    // Read distance value of the first group 
....................    else if(IR_ADC_flag == 3) 
02C4:  BRA    09DE
02C6:  MOVF   xF2,W
02C8:  SUBLW  03
02CA:  BTFSS  FD8.2
02CC:  BRA    051A
....................    { 
....................      IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] = read_adc(ADC_READ_ONLY);    // Read the Distance 
02CE:  CLRF   03
02D0:  MOVF   xF1,W
02D2:  ADDLW  F3
02D4:  MOVWF  FE9
02D6:  MOVLW  00
02D8:  ADDWFC 03,W
02DA:  MOVWF  FEA
02DC:  BCF    FD8.0
02DE:  RLCF   FEF,W
02E0:  CLRF   03
02E2:  ADDLW  D9
02E4:  MOVWF  FE9
02E6:  MOVLW  00
02E8:  ADDWFC 03,W
02EA:  MOVWF  FEA
02EC:  BTFSC  FC2.1
02EE:  BRA    02EC
02F0:  MOVFF  FC3,FEF
02F4:  MOVFF  FC4,FEC
....................      IR_Temp_Proximity[ IR_AN_Table[ IR_Counter ]] = abs(IR_light[IR_AN_Table[ IR_Counter ]] - IR_Temp_Proximity[ IR_AN_Table[ IR_Counter ] ]); // Substract the proximity to the ambiant value to obtain the correct distance value 
02F8:  CLRF   03
02FA:  MOVF   xF1,W
02FC:  ADDLW  F3
02FE:  MOVWF  FE9
0300:  MOVLW  00
0302:  ADDWFC 03,W
0304:  MOVWF  FEA
0306:  BCF    FD8.0
0308:  RLCF   FEF,W
030A:  CLRF   03
030C:  ADDLW  D9
030E:  MOVWF  01
0310:  MOVLW  00
0312:  ADDWFC 03,F
0314:  MOVFF  01,1D4
0318:  MOVLB  1
031A:  MOVFF  03,1D5
031E:  CLRF   03
0320:  MOVLB  0
0322:  MOVF   xF1,W
0324:  ADDLW  F3
0326:  MOVWF  FE9
0328:  MOVLW  00
032A:  ADDWFC 03,W
032C:  MOVWF  FEA
032E:  BCF    FD8.0
0330:  RLCF   FEF,W
0332:  CLRF   03
0334:  ADDLW  91
0336:  MOVWF  FE9
0338:  MOVLW  00
033A:  ADDWFC 03,W
033C:  MOVWF  FEA
033E:  MOVFF  FEC,1D7
0342:  MOVF   FED,F
0344:  MOVFF  FEF,1D6
0348:  CLRF   03
034A:  MOVF   xF1,W
034C:  ADDLW  F3
034E:  MOVWF  FE9
0350:  MOVLW  00
0352:  ADDWFC 03,W
0354:  MOVWF  FEA
0356:  BCF    FD8.0
0358:  RLCF   FEF,W
035A:  CLRF   03
035C:  ADDLW  D9
035E:  MOVWF  FE9
0360:  MOVLW  00
0362:  ADDWFC 03,W
0364:  MOVWF  FEA
0366:  MOVFF  FEC,03
036A:  MOVF   FED,F
036C:  MOVF   FEF,W
036E:  MOVLB  1
0370:  SUBWF  xD6,F
0372:  MOVF   03,W
0374:  SUBWFB xD7,F
0376:  MOVFF  1D7,03
037A:  MOVF   xD6,W
037C:  BTFSS  xD7.7
037E:  BRA    0390
0380:  MOVLW  00
0382:  BSF    FD8.0
0384:  SUBFWB xD6,W
0386:  MOVWF  00
0388:  MOVLW  00
038A:  SUBFWB xD7,W
038C:  MOVWF  03
038E:  MOVF   00,W
0390:  MOVFF  1D5,FEA
0394:  MOVFF  1D4,FE9
0398:  MOVFF  03,FEC
039C:  MOVF   FED,F
039E:  MOVWF  FEF
....................      if(IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] < IR_Calibrate[IR_AN_Table[ IR_Counter ]])  // Check if the value is greater than the calibrated value 
03A0:  CLRF   03
03A2:  MOVLB  0
03A4:  MOVF   xF1,W
03A6:  ADDLW  F3
03A8:  MOVWF  FE9
03AA:  MOVLW  00
03AC:  ADDWFC 03,W
03AE:  MOVWF  FEA
03B0:  BCF    FD8.0
03B2:  RLCF   FEF,W
03B4:  CLRF   03
03B6:  ADDLW  D9
03B8:  MOVWF  FE9
03BA:  MOVLW  00
03BC:  ADDWFC 03,W
03BE:  MOVWF  FEA
03C0:  MOVFF  FEC,1D5
03C4:  MOVF   FED,F
03C6:  MOVFF  FEF,1D4
03CA:  CLRF   03
03CC:  MOVF   xF1,W
03CE:  ADDLW  F3
03D0:  MOVWF  FE9
03D2:  MOVLW  00
03D4:  ADDWFC 03,W
03D6:  MOVWF  FEA
03D8:  BCF    FD8.0
03DA:  RLCF   FEF,W
03DC:  CLRF   03
03DE:  ADDLW  C1
03E0:  MOVWF  FE9
03E2:  MOVLW  00
03E4:  ADDWFC 03,W
03E6:  MOVWF  FEA
03E8:  MOVFF  FEC,03
03EC:  MOVF   FED,F
03EE:  MOVFF  FEF,01
03F2:  MOVLB  1
03F4:  BTFSS  xD5.7
03F6:  BRA    03FE
03F8:  BTFSS  03.7
03FA:  BRA    0410
03FC:  BRA    0402
03FE:  BTFSC  03.7
0400:  BRA    043A
0402:  MOVF   xD5,W
0404:  SUBWF  03,W
0406:  BNC   043A
0408:  BNZ   0410
040A:  MOVF   01,W
040C:  SUBWF  xD4,W
040E:  BC    043A
....................        IR_Proximity[IR_AN_Table[ IR_Counter ]] = 0; 
0410:  CLRF   03
0412:  MOVLB  0
0414:  MOVF   xF1,W
0416:  ADDLW  F3
0418:  MOVWF  FE9
041A:  MOVLW  00
041C:  ADDWFC 03,W
041E:  MOVWF  FEA
0420:  BCF    FD8.0
0422:  RLCF   FEF,W
0424:  CLRF   03
0426:  ADDLW  A9
0428:  MOVWF  FE9
042A:  MOVLW  00
042C:  ADDWFC 03,W
042E:  MOVWF  FEA
0430:  CLRF   FEC
0432:  MOVF   FED,F
0434:  CLRF   FEF
....................      else 
0436:  BRA    04CA
0438:  MOVLB  1
....................        IR_Proximity[IR_AN_Table[ IR_Counter ]] = IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] - IR_Calibrate[IR_AN_Table[ IR_Counter ]]; 
043A:  CLRF   03
043C:  MOVLB  0
043E:  MOVF   xF1,W
0440:  ADDLW  F3
0442:  MOVWF  FE9
0444:  MOVLW  00
0446:  ADDWFC 03,W
0448:  MOVWF  FEA
044A:  BCF    FD8.0
044C:  RLCF   FEF,W
044E:  CLRF   03
0450:  ADDLW  A9
0452:  MOVWF  01
0454:  MOVLW  00
0456:  ADDWFC 03,F
0458:  MOVLB  1
045A:  MOVFF  03,1D5
045E:  CLRF   03
0460:  MOVLB  0
0462:  MOVF   xF1,W
0464:  ADDLW  F3
0466:  MOVWF  FE9
0468:  MOVLW  00
046A:  ADDWFC 03,W
046C:  MOVWF  FEA
046E:  BCF    FD8.0
0470:  RLCF   FEF,W
0472:  CLRF   03
0474:  ADDLW  D9
0476:  MOVWF  FE9
0478:  MOVLW  00
047A:  ADDWFC 03,W
047C:  MOVWF  FEA
047E:  MOVFF  FEC,1D7
0482:  MOVF   FED,F
0484:  MOVFF  FEF,1D6
0488:  CLRF   03
048A:  MOVF   xF1,W
048C:  ADDLW  F3
048E:  MOVWF  FE9
0490:  MOVLW  00
0492:  ADDWFC 03,W
0494:  MOVWF  FEA
0496:  BCF    FD8.0
0498:  RLCF   FEF,W
049A:  CLRF   03
049C:  ADDLW  C1
049E:  MOVWF  FE9
04A0:  MOVLW  00
04A2:  ADDWFC 03,W
04A4:  MOVWF  FEA
04A6:  MOVFF  FEC,03
04AA:  MOVF   FED,F
04AC:  MOVF   FEF,W
04AE:  MOVLB  1
04B0:  SUBWF  xD6,W
04B2:  MOVWF  00
04B4:  MOVF   03,W
04B6:  SUBWFB xD7,W
04B8:  MOVFF  1D5,FEA
04BC:  MOVFF  01,FE9
04C0:  MOVWF  FEC
04C2:  MOVF   FED,F
04C4:  MOVFF  00,FEF
04C8:  MOVLB  0
....................      IR_Counter++; 
04CA:  INCF   xF1,F
....................      set_adc_channel(IR_AN_Table[ IR_Counter ]);                                 // Set the analog input to next sensor 
04CC:  CLRF   03
04CE:  MOVF   xF1,W
04D0:  ADDLW  F3
04D2:  MOVWF  FE9
04D4:  MOVLW  00
04D6:  ADDWFC 03,W
04D8:  MOVWF  FEA
04DA:  MOVFF  FEF,1D4
04DE:  MOVLB  1
04E0:  RLCF   xD4,W
04E2:  MOVWF  00
04E4:  RLCF   00,F
04E6:  MOVLW  FC
04E8:  ANDWF  00,F
04EA:  MOVF   FC2,W
04EC:  ANDLW  83
04EE:  IORWF  00,W
04F0:  MOVWF  FC2
04F2:  MOVLW  00
04F4:  MOVWF  01
04F6:  MOVF   FC1,W
04F8:  ANDLW  F8
04FA:  IORWF  01,W
04FC:  MOVWF  FC1
....................      delay_us(2); 
04FE:  MOVLW  02
0500:  MOVWF  00
0502:  DECFSZ 00,F
0504:  BRA    0502
0506:  NOP   
....................     if(IR_Counter > 2) 
0508:  MOVLB  0
050A:  MOVF   xF1,W
050C:  SUBLW  02
050E:  BC    0516
....................     { 
....................       output_low(IR_GROUP1);                                                    // Turn off the IR emitter of the first Group 
0510:  BCF    F8C.1
....................       IR_ADC_flag++; 
0512:  INCF   xF2,F
....................     } 
....................     else 
0514:  BRA    0518
....................       read_adc(ADC_START_ONLY);                                                 // Start the new conversion 
0516:  BSF    FC2.1
....................  
....................    
....................    } 
....................    // Read distance value of the second group 
....................    else if(IR_ADC_flag == 5) 
0518:  BRA    09DE
051A:  MOVF   xF2,W
051C:  SUBLW  05
051E:  BTFSS  FD8.2
0520:  BRA    076E
....................    { 
....................       IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] = read_adc(ADC_READ_ONLY);    // Read the Distance 
0522:  CLRF   03
0524:  MOVF   xF1,W
0526:  ADDLW  F3
0528:  MOVWF  FE9
052A:  MOVLW  00
052C:  ADDWFC 03,W
052E:  MOVWF  FEA
0530:  BCF    FD8.0
0532:  RLCF   FEF,W
0534:  CLRF   03
0536:  ADDLW  D9
0538:  MOVWF  FE9
053A:  MOVLW  00
053C:  ADDWFC 03,W
053E:  MOVWF  FEA
0540:  BTFSC  FC2.1
0542:  BRA    0540
0544:  MOVFF  FC3,FEF
0548:  MOVFF  FC4,FEC
....................      IR_Temp_Proximity[ IR_AN_Table[ IR_Counter ]] = abs(IR_light[IR_AN_Table[ IR_Counter ]] - IR_Temp_Proximity[ IR_AN_Table[ IR_Counter ] ]); // Substract the proximity to the ambiant value to obtain the correct distance value 
054C:  CLRF   03
054E:  MOVF   xF1,W
0550:  ADDLW  F3
0552:  MOVWF  FE9
0554:  MOVLW  00
0556:  ADDWFC 03,W
0558:  MOVWF  FEA
055A:  BCF    FD8.0
055C:  RLCF   FEF,W
055E:  CLRF   03
0560:  ADDLW  D9
0562:  MOVWF  01
0564:  MOVLW  00
0566:  ADDWFC 03,F
0568:  MOVFF  01,1D4
056C:  MOVLB  1
056E:  MOVFF  03,1D5
0572:  CLRF   03
0574:  MOVLB  0
0576:  MOVF   xF1,W
0578:  ADDLW  F3
057A:  MOVWF  FE9
057C:  MOVLW  00
057E:  ADDWFC 03,W
0580:  MOVWF  FEA
0582:  BCF    FD8.0
0584:  RLCF   FEF,W
0586:  CLRF   03
0588:  ADDLW  91
058A:  MOVWF  FE9
058C:  MOVLW  00
058E:  ADDWFC 03,W
0590:  MOVWF  FEA
0592:  MOVFF  FEC,1D7
0596:  MOVF   FED,F
0598:  MOVFF  FEF,1D6
059C:  CLRF   03
059E:  MOVF   xF1,W
05A0:  ADDLW  F3
05A2:  MOVWF  FE9
05A4:  MOVLW  00
05A6:  ADDWFC 03,W
05A8:  MOVWF  FEA
05AA:  BCF    FD8.0
05AC:  RLCF   FEF,W
05AE:  CLRF   03
05B0:  ADDLW  D9
05B2:  MOVWF  FE9
05B4:  MOVLW  00
05B6:  ADDWFC 03,W
05B8:  MOVWF  FEA
05BA:  MOVFF  FEC,03
05BE:  MOVF   FED,F
05C0:  MOVF   FEF,W
05C2:  MOVLB  1
05C4:  SUBWF  xD6,F
05C6:  MOVF   03,W
05C8:  SUBWFB xD7,F
05CA:  MOVFF  1D7,03
05CE:  MOVF   xD6,W
05D0:  BTFSS  xD7.7
05D2:  BRA    05E4
05D4:  MOVLW  00
05D6:  BSF    FD8.0
05D8:  SUBFWB xD6,W
05DA:  MOVWF  00
05DC:  MOVLW  00
05DE:  SUBFWB xD7,W
05E0:  MOVWF  03
05E2:  MOVF   00,W
05E4:  MOVFF  1D5,FEA
05E8:  MOVFF  1D4,FE9
05EC:  MOVFF  03,FEC
05F0:  MOVF   FED,F
05F2:  MOVWF  FEF
....................      if(IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] < IR_Calibrate[IR_AN_Table[ IR_Counter ]])  // Check if the value is greater than the calibrated value 
05F4:  CLRF   03
05F6:  MOVLB  0
05F8:  MOVF   xF1,W
05FA:  ADDLW  F3
05FC:  MOVWF  FE9
05FE:  MOVLW  00
0600:  ADDWFC 03,W
0602:  MOVWF  FEA
0604:  BCF    FD8.0
0606:  RLCF   FEF,W
0608:  CLRF   03
060A:  ADDLW  D9
060C:  MOVWF  FE9
060E:  MOVLW  00
0610:  ADDWFC 03,W
0612:  MOVWF  FEA
0614:  MOVFF  FEC,1D5
0618:  MOVF   FED,F
061A:  MOVFF  FEF,1D4
061E:  CLRF   03
0620:  MOVF   xF1,W
0622:  ADDLW  F3
0624:  MOVWF  FE9
0626:  MOVLW  00
0628:  ADDWFC 03,W
062A:  MOVWF  FEA
062C:  BCF    FD8.0
062E:  RLCF   FEF,W
0630:  CLRF   03
0632:  ADDLW  C1
0634:  MOVWF  FE9
0636:  MOVLW  00
0638:  ADDWFC 03,W
063A:  MOVWF  FEA
063C:  MOVFF  FEC,03
0640:  MOVF   FED,F
0642:  MOVFF  FEF,01
0646:  MOVLB  1
0648:  BTFSS  xD5.7
064A:  BRA    0652
064C:  BTFSS  03.7
064E:  BRA    0664
0650:  BRA    0656
0652:  BTFSC  03.7
0654:  BRA    068E
0656:  MOVF   xD5,W
0658:  SUBWF  03,W
065A:  BNC   068E
065C:  BNZ   0664
065E:  MOVF   01,W
0660:  SUBWF  xD4,W
0662:  BC    068E
....................        IR_Proximity[IR_AN_Table[ IR_Counter ]] = 0; 
0664:  CLRF   03
0666:  MOVLB  0
0668:  MOVF   xF1,W
066A:  ADDLW  F3
066C:  MOVWF  FE9
066E:  MOVLW  00
0670:  ADDWFC 03,W
0672:  MOVWF  FEA
0674:  BCF    FD8.0
0676:  RLCF   FEF,W
0678:  CLRF   03
067A:  ADDLW  A9
067C:  MOVWF  FE9
067E:  MOVLW  00
0680:  ADDWFC 03,W
0682:  MOVWF  FEA
0684:  CLRF   FEC
0686:  MOVF   FED,F
0688:  CLRF   FEF
....................      else 
068A:  BRA    071E
068C:  MOVLB  1
....................        IR_Proximity[IR_AN_Table[ IR_Counter ]] = IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] - IR_Calibrate[IR_AN_Table[ IR_Counter ]]; 
068E:  CLRF   03
0690:  MOVLB  0
0692:  MOVF   xF1,W
0694:  ADDLW  F3
0696:  MOVWF  FE9
0698:  MOVLW  00
069A:  ADDWFC 03,W
069C:  MOVWF  FEA
069E:  BCF    FD8.0
06A0:  RLCF   FEF,W
06A2:  CLRF   03
06A4:  ADDLW  A9
06A6:  MOVWF  01
06A8:  MOVLW  00
06AA:  ADDWFC 03,F
06AC:  MOVLB  1
06AE:  MOVFF  03,1D5
06B2:  CLRF   03
06B4:  MOVLB  0
06B6:  MOVF   xF1,W
06B8:  ADDLW  F3
06BA:  MOVWF  FE9
06BC:  MOVLW  00
06BE:  ADDWFC 03,W
06C0:  MOVWF  FEA
06C2:  BCF    FD8.0
06C4:  RLCF   FEF,W
06C6:  CLRF   03
06C8:  ADDLW  D9
06CA:  MOVWF  FE9
06CC:  MOVLW  00
06CE:  ADDWFC 03,W
06D0:  MOVWF  FEA
06D2:  MOVFF  FEC,1D7
06D6:  MOVF   FED,F
06D8:  MOVFF  FEF,1D6
06DC:  CLRF   03
06DE:  MOVF   xF1,W
06E0:  ADDLW  F3
06E2:  MOVWF  FE9
06E4:  MOVLW  00
06E6:  ADDWFC 03,W
06E8:  MOVWF  FEA
06EA:  BCF    FD8.0
06EC:  RLCF   FEF,W
06EE:  CLRF   03
06F0:  ADDLW  C1
06F2:  MOVWF  FE9
06F4:  MOVLW  00
06F6:  ADDWFC 03,W
06F8:  MOVWF  FEA
06FA:  MOVFF  FEC,03
06FE:  MOVF   FED,F
0700:  MOVF   FEF,W
0702:  MOVLB  1
0704:  SUBWF  xD6,W
0706:  MOVWF  00
0708:  MOVF   03,W
070A:  SUBWFB xD7,W
070C:  MOVFF  1D5,FEA
0710:  MOVFF  01,FE9
0714:  MOVWF  FEC
0716:  MOVF   FED,F
0718:  MOVFF  00,FEF
071C:  MOVLB  0
....................       IR_Counter++; 
071E:  INCF   xF1,F
....................       set_adc_channel(IR_AN_Table[ IR_Counter ]);                                 // Set the analog input to next sensor 
0720:  CLRF   03
0722:  MOVF   xF1,W
0724:  ADDLW  F3
0726:  MOVWF  FE9
0728:  MOVLW  00
072A:  ADDWFC 03,W
072C:  MOVWF  FEA
072E:  MOVFF  FEF,1D4
0732:  MOVLB  1
0734:  RLCF   xD4,W
0736:  MOVWF  00
0738:  RLCF   00,F
073A:  MOVLW  FC
073C:  ANDWF  00,F
073E:  MOVF   FC2,W
0740:  ANDLW  83
0742:  IORWF  00,W
0744:  MOVWF  FC2
0746:  MOVLW  00
0748:  MOVWF  01
074A:  MOVF   FC1,W
074C:  ANDLW  F8
074E:  IORWF  01,W
0750:  MOVWF  FC1
....................       delay_us(2); 
0752:  MOVLW  02
0754:  MOVWF  00
0756:  DECFSZ 00,F
0758:  BRA    0756
075A:  NOP   
....................       if(IR_Counter > 5) 
075C:  MOVLB  0
075E:  MOVF   xF1,W
0760:  SUBLW  05
0762:  BC    076A
....................       { 
....................         output_low(IR_GROUP2);                                                    // Turn off the IR emitter of the second Group 
0764:  BCF    F8C.2
....................         IR_ADC_flag++; 
0766:  INCF   xF2,F
....................       } 
....................       else 
0768:  BRA    076C
....................         read_adc(ADC_START_ONLY);                                                 // Start the new conversion 
076A:  BSF    FC2.1
....................    } 
....................    // Read distance value of the third group 
....................    else if(IR_ADC_flag == 7) 
076C:  BRA    09DE
076E:  MOVF   xF2,W
0770:  SUBLW  07
0772:  BTFSS  FD8.2
0774:  BRA    09DE
....................    { 
....................     IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] = read_adc(ADC_READ_ONLY);    // Read the Distance 
0776:  CLRF   03
0778:  MOVF   xF1,W
077A:  ADDLW  F3
077C:  MOVWF  FE9
077E:  MOVLW  00
0780:  ADDWFC 03,W
0782:  MOVWF  FEA
0784:  BCF    FD8.0
0786:  RLCF   FEF,W
0788:  CLRF   03
078A:  ADDLW  D9
078C:  MOVWF  FE9
078E:  MOVLW  00
0790:  ADDWFC 03,W
0792:  MOVWF  FEA
0794:  BTFSC  FC2.1
0796:  BRA    0794
0798:  MOVFF  FC3,FEF
079C:  MOVFF  FC4,FEC
....................      IR_Temp_Proximity[ IR_AN_Table[ IR_Counter ]] = abs(IR_light[IR_AN_Table[ IR_Counter ]] - IR_Temp_Proximity[ IR_AN_Table[ IR_Counter ] ]); // Substract the proximity to the ambiant value to obtain the correct distance value 
07A0:  CLRF   03
07A2:  MOVF   xF1,W
07A4:  ADDLW  F3
07A6:  MOVWF  FE9
07A8:  MOVLW  00
07AA:  ADDWFC 03,W
07AC:  MOVWF  FEA
07AE:  BCF    FD8.0
07B0:  RLCF   FEF,W
07B2:  CLRF   03
07B4:  ADDLW  D9
07B6:  MOVWF  01
07B8:  MOVLW  00
07BA:  ADDWFC 03,F
07BC:  MOVFF  01,1D4
07C0:  MOVLB  1
07C2:  MOVFF  03,1D5
07C6:  CLRF   03
07C8:  MOVLB  0
07CA:  MOVF   xF1,W
07CC:  ADDLW  F3
07CE:  MOVWF  FE9
07D0:  MOVLW  00
07D2:  ADDWFC 03,W
07D4:  MOVWF  FEA
07D6:  BCF    FD8.0
07D8:  RLCF   FEF,W
07DA:  CLRF   03
07DC:  ADDLW  91
07DE:  MOVWF  FE9
07E0:  MOVLW  00
07E2:  ADDWFC 03,W
07E4:  MOVWF  FEA
07E6:  MOVFF  FEC,1D7
07EA:  MOVF   FED,F
07EC:  MOVFF  FEF,1D6
07F0:  CLRF   03
07F2:  MOVF   xF1,W
07F4:  ADDLW  F3
07F6:  MOVWF  FE9
07F8:  MOVLW  00
07FA:  ADDWFC 03,W
07FC:  MOVWF  FEA
07FE:  BCF    FD8.0
0800:  RLCF   FEF,W
0802:  CLRF   03
0804:  ADDLW  D9
0806:  MOVWF  FE9
0808:  MOVLW  00
080A:  ADDWFC 03,W
080C:  MOVWF  FEA
080E:  MOVFF  FEC,03
0812:  MOVF   FED,F
0814:  MOVF   FEF,W
0816:  MOVLB  1
0818:  SUBWF  xD6,F
081A:  MOVF   03,W
081C:  SUBWFB xD7,F
081E:  MOVFF  1D7,03
0822:  MOVF   xD6,W
0824:  BTFSS  xD7.7
0826:  BRA    0838
0828:  MOVLW  00
082A:  BSF    FD8.0
082C:  SUBFWB xD6,W
082E:  MOVWF  00
0830:  MOVLW  00
0832:  SUBFWB xD7,W
0834:  MOVWF  03
0836:  MOVF   00,W
0838:  MOVFF  1D5,FEA
083C:  MOVFF  1D4,FE9
0840:  MOVFF  03,FEC
0844:  MOVF   FED,F
0846:  MOVWF  FEF
....................      if(IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] < IR_Calibrate[IR_AN_Table[ IR_Counter ]])  // Check if the value is greater than the calibrated value 
0848:  CLRF   03
084A:  MOVLB  0
084C:  MOVF   xF1,W
084E:  ADDLW  F3
0850:  MOVWF  FE9
0852:  MOVLW  00
0854:  ADDWFC 03,W
0856:  MOVWF  FEA
0858:  BCF    FD8.0
085A:  RLCF   FEF,W
085C:  CLRF   03
085E:  ADDLW  D9
0860:  MOVWF  FE9
0862:  MOVLW  00
0864:  ADDWFC 03,W
0866:  MOVWF  FEA
0868:  MOVFF  FEC,1D5
086C:  MOVF   FED,F
086E:  MOVFF  FEF,1D4
0872:  CLRF   03
0874:  MOVF   xF1,W
0876:  ADDLW  F3
0878:  MOVWF  FE9
087A:  MOVLW  00
087C:  ADDWFC 03,W
087E:  MOVWF  FEA
0880:  BCF    FD8.0
0882:  RLCF   FEF,W
0884:  CLRF   03
0886:  ADDLW  C1
0888:  MOVWF  FE9
088A:  MOVLW  00
088C:  ADDWFC 03,W
088E:  MOVWF  FEA
0890:  MOVFF  FEC,03
0894:  MOVF   FED,F
0896:  MOVFF  FEF,01
089A:  MOVLB  1
089C:  BTFSS  xD5.7
089E:  BRA    08A6
08A0:  BTFSS  03.7
08A2:  BRA    08B8
08A4:  BRA    08AA
08A6:  BTFSC  03.7
08A8:  BRA    08E2
08AA:  MOVF   xD5,W
08AC:  SUBWF  03,W
08AE:  BNC   08E2
08B0:  BNZ   08B8
08B2:  MOVF   01,W
08B4:  SUBWF  xD4,W
08B6:  BC    08E2
....................        IR_Proximity[IR_AN_Table[ IR_Counter ]] = 0; 
08B8:  CLRF   03
08BA:  MOVLB  0
08BC:  MOVF   xF1,W
08BE:  ADDLW  F3
08C0:  MOVWF  FE9
08C2:  MOVLW  00
08C4:  ADDWFC 03,W
08C6:  MOVWF  FEA
08C8:  BCF    FD8.0
08CA:  RLCF   FEF,W
08CC:  CLRF   03
08CE:  ADDLW  A9
08D0:  MOVWF  FE9
08D2:  MOVLW  00
08D4:  ADDWFC 03,W
08D6:  MOVWF  FEA
08D8:  CLRF   FEC
08DA:  MOVF   FED,F
08DC:  CLRF   FEF
....................      else 
08DE:  BRA    0972
08E0:  MOVLB  1
....................        IR_Proximity[IR_AN_Table[ IR_Counter ]] = IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] - IR_Calibrate[IR_AN_Table[ IR_Counter ]]; 
08E2:  CLRF   03
08E4:  MOVLB  0
08E6:  MOVF   xF1,W
08E8:  ADDLW  F3
08EA:  MOVWF  FE9
08EC:  MOVLW  00
08EE:  ADDWFC 03,W
08F0:  MOVWF  FEA
08F2:  BCF    FD8.0
08F4:  RLCF   FEF,W
08F6:  CLRF   03
08F8:  ADDLW  A9
08FA:  MOVWF  01
08FC:  MOVLW  00
08FE:  ADDWFC 03,F
0900:  MOVLB  1
0902:  MOVFF  03,1D5
0906:  CLRF   03
0908:  MOVLB  0
090A:  MOVF   xF1,W
090C:  ADDLW  F3
090E:  MOVWF  FE9
0910:  MOVLW  00
0912:  ADDWFC 03,W
0914:  MOVWF  FEA
0916:  BCF    FD8.0
0918:  RLCF   FEF,W
091A:  CLRF   03
091C:  ADDLW  D9
091E:  MOVWF  FE9
0920:  MOVLW  00
0922:  ADDWFC 03,W
0924:  MOVWF  FEA
0926:  MOVFF  FEC,1D7
092A:  MOVF   FED,F
092C:  MOVFF  FEF,1D6
0930:  CLRF   03
0932:  MOVF   xF1,W
0934:  ADDLW  F3
0936:  MOVWF  FE9
0938:  MOVLW  00
093A:  ADDWFC 03,W
093C:  MOVWF  FEA
093E:  BCF    FD8.0
0940:  RLCF   FEF,W
0942:  CLRF   03
0944:  ADDLW  C1
0946:  MOVWF  FE9
0948:  MOVLW  00
094A:  ADDWFC 03,W
094C:  MOVWF  FEA
094E:  MOVFF  FEC,03
0952:  MOVF   FED,F
0954:  MOVF   FEF,W
0956:  MOVLB  1
0958:  SUBWF  xD6,W
095A:  MOVWF  00
095C:  MOVF   03,W
095E:  SUBWFB xD7,W
0960:  MOVFF  1D5,FEA
0964:  MOVFF  01,FE9
0968:  MOVWF  FEC
096A:  MOVF   FED,F
096C:  MOVFF  00,FEF
0970:  MOVLB  0
....................     IR_Counter++; 
0972:  INCF   xF1,F
....................     set_adc_channel(IR_AN_Table[ IR_Counter ]);                                 // Set the analog input to next sensor 
0974:  CLRF   03
0976:  MOVF   xF1,W
0978:  ADDLW  F3
097A:  MOVWF  FE9
097C:  MOVLW  00
097E:  ADDWFC 03,W
0980:  MOVWF  FEA
0982:  MOVFF  FEF,1D4
0986:  MOVLB  1
0988:  RLCF   xD4,W
098A:  MOVWF  00
098C:  RLCF   00,F
098E:  MOVLW  FC
0990:  ANDWF  00,F
0992:  MOVF   FC2,W
0994:  ANDLW  83
0996:  IORWF  00,W
0998:  MOVWF  FC2
099A:  MOVLW  00
099C:  MOVWF  01
099E:  MOVF   FC1,W
09A0:  ANDLW  F8
09A2:  IORWF  01,W
09A4:  MOVWF  FC1
....................     delay_us(2); 
09A6:  MOVLW  02
09A8:  MOVWF  00
09AA:  DECFSZ 00,F
09AC:  BRA    09AA
09AE:  NOP   
....................     if(IR_Counter > 9) 
09B0:  MOVLB  0
09B2:  MOVF   xF1,W
09B4:  SUBLW  09
09B6:  BC    09DC
....................     { 
....................       output_low(IR_GROUP3);                                                    // Turn off the IR emitter of the third Group 
09B8:  BCF    F8C.3
....................       IR_Counter = 0; 
09BA:  CLRF   xF1
....................       Sensors_Refreshed_Flag = 1;                                               // Set the flag to indicate that all the sensor was refresh 
09BC:  BSF    22.5
....................       Manual_Refresh_sensors = 0;                                               // reset the manual refresh flag, to refresh only one time    
09BE:  BCF    x88.4
....................       IR_ADC_flag++; 
09C0:  INCF   xF2,F
....................       set_adc_channel(VBAT_AN);                                                 // Set the analog input to measure the battery voltage 
09C2:  MOVLW  18
09C4:  MOVWF  01
09C6:  MOVF   FC2,W
09C8:  ANDLW  83
09CA:  IORWF  01,W
09CC:  MOVWF  FC2
09CE:  MOVLW  00
09D0:  MOVWF  01
09D2:  MOVF   FC1,W
09D4:  ANDLW  F8
09D6:  IORWF  01,W
09D8:  MOVWF  FC1
....................     } 
....................     else 
09DA:  BRA    09DE
....................       read_adc(ADC_START_ONLY);                                                 // Start the new conversion 
09DC:  BSF    FC2.1
09DE:  MOVLB  1
....................    } 
....................  
.................... } 
....................  
....................  
.................... //-----------------------------------------------------------// 
.................... //                  Internal Interrupts                     -// 
....................  
....................  
09E0:  BCF    F9E.6
09E2:  MOVLB  0
09E4:  GOTO   00A8
.................... #INT_TIMER1 
.................... void Sheduler_Interrupt(void)                                                   // Internal Task Manager, Interrupt every 250 us 
.................... { 
....................     
....................    set_timer1(TIMER1_VALUE+get_timer1());                                       // set default value to get an interrupt each 250us 
*
0BAA:  MOVF   FCE,W
0BAC:  MOVFF  FCF,03
0BB0:  ADDLW  49
0BB2:  MOVLB  1
0BB4:  MOVWF  xD4
0BB6:  MOVLW  FC
0BB8:  ADDWFC FCF,W
0BBA:  MOVWF  FCF
0BBC:  MOVFF  1D4,FCE
....................  
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Time Function                                                                -// 
.................... //--------------------------------------------------------------------------------//   
....................    if(++TimeTipDivider >= 4) 
0BC0:  MOVLB  0
0BC2:  INCF   x8E,F
0BC4:  MOVF   x8E,W
0BC6:  SUBLW  03
0BC8:  BC    0C30
....................    { 
....................       TimeTipDivider = 0; 
0BCA:  CLRF   x8E
....................       TimeTip++;                                                                // TimeTip incremented every 1 ms (counter up to 4294967296 ms = 1193 hours ...) 
0BCC:  MOVLW  01
0BCE:  ADDWF  x8A,F
0BD0:  BTFSC  FD8.0
0BD2:  INCF   x8B,F
0BD4:  BTFSC  FD8.2
0BD6:  INCF   x8C,F
0BD8:  BTFSC  FD8.2
0BDA:  INCF   x8D,F
....................       if(MotorTime > 0)                                                         // If the motor must be stopped after n ms 
0BDC:  MOVF   x8F,F
0BDE:  BZ    0BF4
....................       { 
....................         if(++MotorTimeDivider >= 100)                                           // each unit is 10ms 
0BE0:  INCF   x90,F
0BE2:  MOVF   x90,W
0BE4:  SUBLW  63
0BE6:  BC    0BF4
....................         { 
....................           MotorTimeDivider = 0; 
0BE8:  CLRF   x90
....................           if(--MotorTime == 0)                                                  // If the time reach its end 
0BEA:  DECFSZ x8F,F
0BEC:  BRA    0BF4
....................           { 
....................            PwmMotRight = 0;                                                     // Stop the motor 
0BEE:  CLRF   1B
....................            PwmMotLeft = 0; 
0BF0:  CLRF   1A
....................            Motor_Conversion();                                                   
0BF2:  RCALL  0B7E
....................           } 
....................          
....................         } 
....................        
....................       } 
....................       if(Acceleration_Timer != 0)                                               // If an acceleration is in progress 
0BF4:  MOVF   20,F
0BF6:  BZ    0C04
....................       { 
....................         if(--Acceleration_Timer == 0)                                           // Decrement the timer untill it reach 0 
0BF8:  DECFSZ 20,F
0BFA:  BRA    0C04
....................         { 
....................          set_pwm1_duty(TimerMotRight);                                          // Reset the desired value of the two motors 
0BFC:  MOVFF  1F,FBC
....................          set_pwm3_duty(TimerMotLeft);  
0C00:  MOVFF  1E,F4A
....................         } 
....................       } 
....................        
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Read the value of the mode switches all the ms                               -// 
.................... //--------------------------------------------------------------------------------// 
....................       Switchs  =   !input(MODE1);        // MODE1 
0C04:  MOVLB  1
0C06:  CLRF   x01
0C08:  BTFSS  F82.0
0C0A:  INCF   x01,F
....................       Switchs |= ((!input(MODE2))<<1);   // MODE2 
0C0C:  MOVLW  00
0C0E:  BTFSS  F82.1
0C10:  MOVLW  01
0C12:  MOVWF  00
0C14:  BCF    FD8.0
0C16:  RLCF   00,F
0C18:  MOVF   00,W
0C1A:  IORWF  x01,F
....................       Switchs |= ((!input(MODE3))<<2);   // MODE3 
0C1C:  MOVLW  00
0C1E:  BTFSS  F82.2
0C20:  MOVLW  01
0C22:  MOVWF  00
0C24:  RLCF   00,F
0C26:  RLCF   00,F
0C28:  MOVLW  FC
0C2A:  ANDWF  00,F
0C2C:  MOVF   00,W
0C2E:  IORWF  x01,F
....................    } 
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- manage the Auto mode of the LED, each LED is ON during 100ms                 -// 
.................... //--------------------------------------------------------------------------------// 
....................    if(LED_mode != 0)                                                            // If one of the LED is in auto mode 
0C30:  MOVLB  1
0C32:  MOVF   x02,F
0C34:  BTFSC  FD8.2
0C36:  BRA    0CF6
....................    { 
....................       switch(LED_Counter) 
....................       { 
0C38:  MOVF   x03,W
0C3A:  MOVWF  00
0C3C:  MOVF   x04,W
0C3E:  MOVWF  03
0C40:  MOVF   03,W
0C42:  BNZ   0C4C
0C44:  MOVF   00,F
0C46:  MOVLB  0
0C48:  BZ    0C8E
0C4A:  MOVLB  1
0C4C:  MOVLW  01
0C4E:  SUBWF  03,W
0C50:  BNZ   0C5C
0C52:  MOVLW  F4
0C54:  SUBWF  00,W
0C56:  MOVLB  0
0C58:  BZ    0C9E
0C5A:  MOVLB  1
0C5C:  MOVLW  03
0C5E:  SUBWF  03,W
0C60:  BNZ   0C6C
0C62:  MOVLW  E8
0C64:  SUBWF  00,W
0C66:  MOVLB  0
0C68:  BZ    0CAE
0C6A:  MOVLB  1
0C6C:  MOVLW  05
0C6E:  SUBWF  03,W
0C70:  BNZ   0C7C
0C72:  MOVLW  DC
0C74:  SUBWF  00,W
0C76:  MOVLB  0
0C78:  BZ    0CBE
0C7A:  MOVLB  1
0C7C:  MOVLW  07
0C7E:  SUBWF  03,W
0C80:  BNZ   0C8C
0C82:  MOVLW  D0
0C84:  SUBWF  00,W
0C86:  MOVLB  0
0C88:  BZ    0CCE
0C8A:  MOVLB  1
0C8C:  BRA    0CDC
....................          case 0: 
....................             if(LED_mode & 0x10)                                                 // Check if the LED4 is in auto mode 
0C8E:  MOVLB  1
0C90:  BTFSS  x02.4
0C92:  BRA    0C96
....................                output_low(LED4);                                                // Turn OFF the LED4          
0C94:  BCF    F8A.5
....................             if(LED_mode & 0x01)                                                 // Check if the LED0 is in auto mode 
0C96:  BTFSS  x02.0
0C98:  BRA    0C9C
....................                output_high(LED0);                                               // Turn ON the LED0 
0C9A:  BSF    F8A.1
....................             break; 
0C9C:  BRA    0CDC
....................          case 500: 
....................             if(LED_mode & 0x01)                                                 // Check if the LED0 is in auto mode 
0C9E:  MOVLB  1
0CA0:  BTFSS  x02.0
0CA2:  BRA    0CA6
....................                output_low(LED0);                                                // Turn OFF the LED0 
0CA4:  BCF    F8A.1
....................             if(LED_mode &0x02)                                                  // Check if the LED1 is in auto mode 
0CA6:  BTFSS  x02.1
0CA8:  BRA    0CAC
....................                output_high(LED1);                                               // then turn ON the LED1 
0CAA:  BSF    F8A.2
....................             break; 
0CAC:  BRA    0CDC
....................          case 1000: 
....................             if(LED_mode & 0x02)                                                 // Check if the LED1 is in auto mode 
0CAE:  MOVLB  1
0CB0:  BTFSS  x02.1
0CB2:  BRA    0CB6
....................                output_low(LED1);                                                // Turn OFF the LED1 
0CB4:  BCF    F8A.2
....................             if(LED_mode &0x04)                                                  // Check if the LED2 is in auto mode 
0CB6:  BTFSS  x02.2
0CB8:  BRA    0CBC
....................                output_high(LED2);                                               // then turn ON the LED2 
0CBA:  BSF    F8A.3
....................             break;          
0CBC:  BRA    0CDC
....................          case 1500: 
....................             if(LED_mode & 0x04)                                                 // Check if the LED2is in auto mode 
0CBE:  MOVLB  1
0CC0:  BTFSS  x02.2
0CC2:  BRA    0CC6
....................                output_low(LED2);                                                // Turn OFF the LED2 
0CC4:  BCF    F8A.3
....................             if(LED_mode &0x08)                                                  // Check if the LED3is in auto mode 
0CC6:  BTFSS  x02.3
0CC8:  BRA    0CCC
....................                output_high(LED3);                                               // then turn ON the LED3 
0CCA:  BSF    F8A.4
....................             break;     
0CCC:  BRA    0CDC
....................          case 2000: 
....................             if(LED_mode & 0x08)                                                 // Check if the LED2is in auto mode 
0CCE:  MOVLB  1
0CD0:  BTFSS  x02.3
0CD2:  BRA    0CD6
....................                output_low(LED3);                                                // Turn OFF the LED2 
0CD4:  BCF    F8A.4
....................             if(LED_mode &0x10)                                                  // Check if the LED3is in auto mode 
0CD6:  BTFSS  x02.4
0CD8:  BRA    0CDC
....................                output_high(LED4);                                               // then turn ON the LED3 
0CDA:  BSF    F8A.5
....................             break;              
....................       } 
....................       if(++LED_Counter >= 2499) 
0CDC:  INCF   x03,F
0CDE:  BTFSC  FD8.2
0CE0:  INCF   x04,F
0CE2:  MOVF   x04,W
0CE4:  SUBLW  08
0CE6:  BC    0CF6
0CE8:  XORLW  FF
0CEA:  BNZ   0CF2
0CEC:  MOVF   x03,W
0CEE:  SUBLW  C2
0CF0:  BC    0CF6
....................          LED_Counter = 0; 
0CF2:  CLRF   x04
0CF4:  CLRF   x03
....................     
....................    } 
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- IR Sensor Management  (10ms to refresh all the IR sensor)                    -// 
.................... //--------------------------------------------------------------------------------//      
....................   
....................  if( (Auto_Refresh_Sensors == 1) || (Manual_Refresh_sensors == 1) ) 
0CF6:  BTFSC  22.0
0CF8:  BRA    0D02
0CFA:  MOVLB  0
0CFC:  BTFSS  x88.4
0CFE:  BRA    0D60
0D00:  MOVLB  1
....................  { 
....................        // Read the battery voltage 
....................       if(IR_ADC_Flag == 0) 
0D02:  MOVLB  0
0D04:  MOVF   xF2,F
0D06:  BNZ   0D0C
....................       { 
....................          read_adc(ADC_START_ONLY);                                              // read the analog value of the proximity 
0D08:  BSF    FC2.1
....................       } 
....................       // Read ambiant value 
....................       else if(IR_ADC_Flag == 1) 
0D0A:  BRA    0D60
0D0C:  DECFSZ xF2,W
0D0E:  BRA    0D14
....................       { 
....................          read_adc(ADC_START_ONLY);                                              // Start the AD conversion to read the whole ambiant light value 
0D10:  BSF    FC2.1
....................       } 
....................       // Turn on the IR emitter 
....................       else if(IR_ADC_Flag == 2) 
0D12:  BRA    0D60
0D14:  MOVF   xF2,W
0D16:  SUBLW  02
0D18:  BNZ   0D20
....................       { 
....................          IR_ADC_Flag++;   
0D1A:  INCF   xF2,F
....................          output_high(IR_GROUP1);                                                // Turn on the IR emitter of Group1 
0D1C:  BSF    F8C.1
....................           
....................       }       
....................       // Read proximity value of the first group 
....................       else if(IR_ADC_Flag == 3) 
0D1E:  BRA    0D60
0D20:  MOVF   xF2,W
0D22:  SUBLW  03
0D24:  BNZ   0D2A
....................       { 
....................          read_adc(ADC_START_ONLY);                                              // read the analog value of the proximity 
0D26:  BSF    FC2.1
....................       } 
....................       // Turn on the IR emitter 
....................       else if(IR_ADC_Flag == 4) 
0D28:  BRA    0D60
0D2A:  MOVF   xF2,W
0D2C:  SUBLW  04
0D2E:  BNZ   0D36
....................       { 
....................          IR_ADC_Flag++;   
0D30:  INCF   xF2,F
....................          output_high(IR_GROUP2);                                                // Turn on the IR emitter of Group2 
0D32:  BSF    F8C.2
....................           
....................       }       
....................       // Read proximity value of the second group 
....................       else if(IR_ADC_Flag == 5) 
0D34:  BRA    0D60
0D36:  MOVF   xF2,W
0D38:  SUBLW  05
0D3A:  BNZ   0D40
....................       { 
....................          read_adc(ADC_START_ONLY);                                              // read the analog value of the proximity 
0D3C:  BSF    FC2.1
....................       } 
....................       // Turn on the IR emitter 
....................       else if(IR_ADC_Flag == 6) 
0D3E:  BRA    0D60
0D40:  MOVF   xF2,W
0D42:  SUBLW  06
0D44:  BNZ   0D4C
....................       { 
....................          IR_ADC_Flag++;   
0D46:  INCF   xF2,F
....................          output_high(IR_GROUP3);                                                // Turn on the IR emitter of Group3 
0D48:  BSF    F8C.3
....................           
....................       }       
....................       // Read proximity value of the third group 
....................       else if(IR_ADC_Flag == 7) 
0D4A:  BRA    0D60
0D4C:  MOVF   xF2,W
0D4E:  SUBLW  07
0D50:  BNZ   0D56
....................       { 
....................          read_adc(ADC_START_ONLY);                                              // read the analog value of the proximity 
0D52:  BSF    FC2.1
....................       } 
....................  
....................  
....................       else 
0D54:  BRA    0D60
....................       { 
....................          if(++IR_ADC_Flag > 40)                                                 // Restart the refresh of the IR sensor 
0D56:  INCF   xF2,F
0D58:  MOVF   xF2,W
0D5A:  SUBLW  28
0D5C:  BC    0D60
....................            IR_ADC_Flag = 0; 
0D5E:  CLRF   xF2
....................       } 
....................  
....................    } 
.................... } 
....................  
0D60:  BCF    F9E.0
0D62:  GOTO   00A8
.................... #INT_TIMER3 
.................... void Buzzer_Interrupt(void)                                                     // Buzzer interrupt 
.................... { 
....................   set_timer3(Buzzer_Timer+ get_timer3());                                       // Set the timer to match the frequency note 
0D66:  MOVF   FB2,W
0D68:  MOVFF  FB3,03
0D6C:  MOVLB  1
0D6E:  ADDWF  x06,W
0D70:  MOVWF  xD4
0D72:  MOVF   FB3,W
0D74:  ADDWFC x07,W
0D76:  MOVWF  FB3
0D78:  MOVFF  1D4,FB2
....................   output_bit(BUZZER,!input(BUZZER));                                            // Toggle the buzzer output 
0D7C:  BTFSS  F84.2
0D7E:  BRA    0D84
0D80:  BCF    F8D.2
0D82:  BRA    0D86
0D84:  BSF    F8D.2
.................... } 
....................  
0D86:  BCF    FA1.1
0D88:  MOVLB  0
0D8A:  GOTO   00A8
.................... #INT_EXT 
.................... void TV_Remote_Interrupt(void) 
.................... { 
....................    if( Auto_Refresh_TV_Remote == 1 )                                            // Only if the Auto refresh TV flag is set 
0D8E:  BTFSS  22.1
0D90:  BRA    0DBC
....................    { 
....................        TV_Counter=0;                                                            // Reset the TV Counter 
0D92:  CLRF   x85
....................        TV_table[TV_Counter] = !input(IR_IN);                                    // read the first start bit, invert it to match with the modulation of the receiver 
0D94:  CLRF   03
0D96:  MOVF   x85,W
0D98:  ADDLW  75
0D9A:  MOVWF  FE9
0D9C:  MOVLW  00
0D9E:  ADDWFC 03,W
0DA0:  MOVWF  FEA
0DA2:  MOVLW  00
0DA4:  BTFSS  F81.0
0DA6:  MOVLW  01
0DA8:  MOVWF  FEF
....................        disable_interrupts(INT_EXT); 
0DAA:  BCF    FF2.4
....................        setup_timer_0(T0_DIV_1  | T0_INTERNAL );                                 // The first time is longer to read on the End of the coding 
0DAC:  MOVLW  88
0DAE:  MOVWF  FD5
....................        set_timer0(TIMER0_2100); 
0DB0:  MOVLW  DF
0DB2:  MOVWF  FD7
0DB4:  MOVLW  2F
0DB6:  MOVWF  FD6
....................        enable_interrupts(INT_TIMER0);   
0DB8:  BSF    FF2.5
....................        TV_Data_pending = 1;                                                     // Indicate that a reception of a TV Data is in progress 
0DBA:  BSF    x88.0
....................    } 
....................     
.................... } 
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Modulate at 36 kHz with 50 duty-cycle                                        -// 
.................... //--------------------------------------------------------------------------------// 
0DBC:  BCF    FF2.1
0DBE:  GOTO   00A8
.................... void KJunior_IR_Send32x(void) 
.................... { 
*
0E5C:  MOVLB  1
0E5E:  CLRF   xD5
....................  unsigned int i = 0; 
....................   
....................  for (i=0;i<32;i++) 
0E60:  CLRF   xD5
0E62:  MOVF   xD5,W
0E64:  SUBLW  1F
0E66:  BNC   0E82
....................   { 
....................    output_bit(IR_OUT,1); 
0E68:  BSF    F8C.4
....................    delay_us(13);                                                                 // This value was choose to match exactly with the rc5 timing 
0E6A:  MOVLW  11
0E6C:  MOVWF  00
0E6E:  DECFSZ 00,F
0E70:  BRA    0E6E
....................    output_bit(IR_OUT,0); 
0E72:  BCF    F8C.4
....................    delay_us(12);                                                                 // This value was choose to match exactly with the rc5 timing 
0E74:  MOVLW  0F
0E76:  MOVWF  00
0E78:  DECFSZ 00,F
0E7A:  BRA    0E78
0E7C:  BRA    0E7E
....................   } 
0E7E:  INCF   xD5,F
0E80:  BRA    0E62
.................... } 
0E82:  MOVLB  0
0E84:  RETURN 0
....................  
....................  
.................... #INT_TIMER0 
.................... void RC5_Decoding_Interrupt(void) 
.................... { 
0E86:  MOVLB  1
0E88:  BCF    xD4.0
....................    int1 RC5_Bit = 0; 
....................    if(TV_Data_pending == 1)                                                     // Verify if a data is coming on the receiver, or ... 
0E8A:  MOVLB  0
0E8C:  BTFSS  x88.0
0E8E:  BRA    0F7A
....................    { 
....................       set_timer0(TIMER0_1780+get_timer0());                                     // Interrupt every 1.780 ms 
0E90:  MOVF   FD6,W
0E92:  MOVFF  FD7,03
0E96:  ADDLW  2F
0E98:  MOVLB  1
0E9A:  MOVWF  xD5
0E9C:  MOVLW  E4
0E9E:  ADDWFC FD7,W
0EA0:  MOVWF  FD7
0EA2:  MOVFF  1D5,FD6
....................       if(++TV_Counter <= 13) 
0EA6:  MOVLB  0
0EA8:  INCF   x85,F
0EAA:  MOVF   x85,W
0EAC:  SUBLW  0D
0EAE:  BNC   0EC8
....................       { 
....................          TV_Table[TV_Counter] = !input(IR_IN);                                  // Read the bit of the manchester coding 
0EB0:  CLRF   03
0EB2:  MOVF   x85,W
0EB4:  ADDLW  75
0EB6:  MOVWF  FE9
0EB8:  MOVLW  00
0EBA:  ADDWFC 03,W
0EBC:  MOVWF  FEA
0EBE:  MOVLW  00
0EC0:  BTFSS  F81.0
0EC2:  MOVLW  01
0EC4:  MOVWF  FEF
....................       } 
....................       else 
0EC6:  BRA    0F78
....................       { 
....................          if(TV_Table[StartBit1] == 1 && TV_Table[StartBit2] == 1)               // Verify that the two start bit are correct (value must be 1) 
0EC8:  DECFSZ x75,W
0ECA:  BRA    0F6E
0ECC:  DECFSZ x76,W
0ECE:  BRA    0F6E
....................          { 
....................             // If correct, save the data and address of the receiveing command 
....................             TV_RX_Toggle_Bit = TV_Table[ToggleBit]; 
0ED0:  MOVFF  77,89
....................             TV_ADDR = (TV_Table[AddrBit4] << 4) |(TV_Table[AddrBit3] << 3) | (TV_Table[AddrBit2] << 2) | (TV_Table[AddrBit1] << 1) | (TV_Table[AddrBit0]); 
0ED4:  SWAPF  x78,W
0ED6:  MOVLB  1
0ED8:  MOVWF  xD5
0EDA:  MOVLW  F0
0EDC:  ANDWF  xD5,F
0EDE:  MOVLB  0
0EE0:  RLCF   x79,W
0EE2:  MOVWF  00
0EE4:  RLCF   00,F
0EE6:  RLCF   00,F
0EE8:  MOVLW  F8
0EEA:  ANDWF  00,F
0EEC:  MOVF   00,W
0EEE:  MOVLB  1
0EF0:  IORWF  xD5,F
0EF2:  MOVLB  0
0EF4:  RLCF   x7A,W
0EF6:  MOVWF  00
0EF8:  RLCF   00,F
0EFA:  MOVLW  FC
0EFC:  ANDWF  00,F
0EFE:  MOVF   00,W
0F00:  MOVLB  1
0F02:  IORWF  xD5,F
0F04:  BCF    FD8.0
0F06:  MOVLB  0
0F08:  RLCF   x7B,W
0F0A:  MOVLB  1
0F0C:  IORWF  xD5,W
0F0E:  MOVLB  0
0F10:  IORWF  x7C,W
0F12:  MOVWF  x83
....................             TV_DATA = (TV_Table[DataBit5] << 5) | (TV_Table[DataBit4] << 4) | (TV_Table[DataBit3] << 3) | (TV_Table[DataBit2] << 2) | (TV_Table[DataBit1] << 1) | (TV_Table[DataBit0]); 
0F14:  SWAPF  x7D,W
0F16:  MOVLB  1
0F18:  MOVWF  xD5
0F1A:  RLCF   xD5,F
0F1C:  MOVLW  E0
0F1E:  ANDWF  xD5,F
0F20:  MOVLB  0
0F22:  SWAPF  x7E,W
0F24:  MOVWF  00
0F26:  MOVLW  F0
0F28:  ANDWF  00,F
0F2A:  MOVF   00,W
0F2C:  MOVLB  1
0F2E:  IORWF  xD5,F
0F30:  MOVLB  0
0F32:  RLCF   x7F,W
0F34:  MOVWF  00
0F36:  RLCF   00,F
0F38:  RLCF   00,F
0F3A:  MOVLW  F8
0F3C:  ANDWF  00,F
0F3E:  MOVF   00,W
0F40:  MOVLB  1
0F42:  IORWF  xD5,F
0F44:  MOVLB  0
0F46:  RLCF   x80,W
0F48:  MOVWF  00
0F4A:  RLCF   00,F
0F4C:  MOVLW  FC
0F4E:  ANDWF  00,F
0F50:  MOVF   00,W
0F52:  MOVLB  1
0F54:  IORWF  xD5,F
0F56:  BCF    FD8.0
0F58:  MOVLB  0
0F5A:  RLCF   x81,W
0F5C:  MOVLB  1
0F5E:  IORWF  xD5,W
0F60:  MOVLB  0
0F62:  IORWF  x82,W
0F64:  MOVWF  x84
....................             TV_DATA_Available = 1;                                              // Set the flag to know that a TV data is available 
0F66:  BSF    22.7
....................             if(Enable_TV_Remote_Control == 1)                                   // If the control remote is activate 
0F68:  BTFSS  22.3
0F6A:  BRA    0F6E
....................                TV_Remote_Control();                                             // Set the speed for each motor 
0F6C:  BRA    0DC2
....................          } 
....................          enable_interrupts(INT_EXT);                                            // Enable the external interrupt after receiving a complete data 
0F6E:  BSF    FF2.4
....................          disable_interrupts(INT_TIMER0);                                        // Disable the timer 0 interrupt 
0F70:  BCF    FF2.5
....................          setup_timer_0(RTCC_OFF);                                               // stop the timer0 
0F72:  CLRF   FD5
....................          bit_clear(INTCON,1);                                                   // Clear the INTF bit to avoid a interrupt on the RB port 
0F74:  BCF    FF2.1
....................          TV_Data_pending = 0;                                                   // Clear the flag to indicate that the data is completely received 
0F76:  BCF    x88.0
....................       } 
....................    } 
....................    else if(TV_Data_emitting == 1)                                               // .. if a data must be send on the emitter 
0F78:  BRA    109A
0F7A:  BTFSS  x88.1
0F7C:  BRA    1092
....................    { 
....................       set_timer0(TIMER0_886 + get_timer0());                                    // Interrupt every 886 us    
0F7E:  MOVF   FD6,W
0F80:  MOVFF  FD7,03
0F84:  ADDLW  27
0F86:  MOVLB  1
0F88:  MOVWF  xD5
0F8A:  MOVLW  F2
0F8C:  ADDWFC FD7,W
0F8E:  MOVWF  FD7
0F90:  MOVFF  1D5,FD6
....................       do 
....................       { 
....................          TV_Data_loop = 0;                                                      // reset the flag, the loop can be done only one times 
0F94:  MOVLB  0
0F96:  BCF    x88.2
....................          if(TV_Counter < 2)                                                     // the first 2 bits are always 1 (start bit) 
0F98:  MOVF   x85,W
0F9A:  SUBLW  01
0F9C:  BNC   0FA6
....................             RC5_Bit = 1; 
0F9E:  MOVLB  1
0FA0:  BSF    xD4.0
....................          else if(TV_Counter == 2)                                               // Toggle bit 
0FA2:  BRA    1038
0FA4:  MOVLB  0
0FA6:  MOVF   x85,W
0FA8:  SUBLW  02
0FAA:  BNZ   0FBE
....................             RC5_Bit = TV_TX_Toggle_Bit; 
0FAC:  MOVLB  1
0FAE:  BCF    xD4.0
0FB0:  MOVLB  0
0FB2:  BTFSS  x88.3
0FB4:  BRA    0FBC
0FB6:  MOVLB  1
0FB8:  BSF    xD4.0
0FBA:  MOVLB  0
....................          else if(TV_Counter > 13)                                               // if all the bits are send,  
0FBC:  BRA    103A
0FBE:  MOVF   x85,W
0FC0:  SUBLW  0D
0FC2:  BC    0FDC
....................          { 
....................             TV_Data_emitting = 0;                                               // Stop the emitting 
0FC4:  BCF    x88.1
....................             TV_TX_Toggle_Bit = !TV_TX_Toggle_Bit;                               // Change the toggle Bit for the next emitting 
0FC6:  BTG    x88.3
....................             enable_interrupts(INT_EXT);                                         // Enable the external interrupt after emitting a complete rc5 code 
0FC8:  BSF    FF2.4
....................             disable_interrupts(INT_TIMER0);                                     // Disable the timer 0 interrupt 
0FCA:  BCF    FF2.5
....................             setup_timer_0(RTCC_OFF);                                            // stop the timer0 
0FCC:  CLRF   FD5
....................             enable_interrupts(INT_TIMER1); 
0FCE:  BSF    F9D.0
....................             bit_clear(INTCON,1);                                                // Clear the INTF bit to avoid a interrupt on the RB port 
0FD0:  BCF    FF2.1
....................             TV_Counter_flag = 0;                                                // Set the flag and the rc5 bit to ensure the output will be down 
0FD2:  BCF    22.6
....................             RC5_Bit = 1;                                                           
0FD4:  MOVLB  1
0FD6:  BSF    xD4.0
....................          } 
....................          else if((TV_Counter > 8) && (TV_Counter <= 13))                        // The last 6 bits are the Data 
0FD8:  BRA    1038
0FDA:  MOVLB  0
0FDC:  MOVF   x85,W
0FDE:  SUBLW  08
0FE0:  BC    1012
0FE2:  MOVF   x85,W
0FE4:  SUBLW  0D
0FE6:  BNC   1012
....................          { 
....................             if(TV_Data_send & (0x20 >> (TV_Counter - 8)))                       // Mask the Data to keep only the bit to send 
0FE8:  MOVLW  08
0FEA:  SUBWF  x85,W
0FEC:  MOVWF  01
0FEE:  MOVLW  20
0FF0:  MOVWF  00
0FF2:  MOVF   01,F
0FF4:  BZ    0FFE
0FF6:  BCF    FD8.0
0FF8:  RRCF   00,F
0FFA:  DECFSZ 01,F
0FFC:  BRA    0FF6
0FFE:  MOVF   00,W
1000:  ANDWF  x86,W
1002:  BZ    100A
....................                RC5_Bit = 1 ;                  
1004:  MOVLB  1
1006:  BSF    xD4.0
....................             else  
1008:  BRA    100E
....................                RC5_Bit = 0;          
100A:  MOVLB  1
100C:  BCF    xD4.0
....................          } 
....................          else                                                                   // Address Bits 
100E:  BRA    1038
1010:  MOVLB  0
....................          { 
....................             if(TV_Addr_send & (0x10 >> (TV_Counter - 3)))                       // Mask the Data to keep only the bit to send 
1012:  MOVLW  03
1014:  SUBWF  x85,W
1016:  MOVWF  01
1018:  MOVLW  10
101A:  MOVWF  00
101C:  MOVF   01,F
101E:  BZ    1028
1020:  BCF    FD8.0
1022:  RRCF   00,F
1024:  DECFSZ 01,F
1026:  BRA    1020
1028:  MOVF   00,W
102A:  ANDWF  x87,W
102C:  BZ    1034
....................                RC5_Bit = 1 ;                  
102E:  MOVLB  1
1030:  BSF    xD4.0
....................             else  
1032:  BRA    1038
....................                RC5_Bit = 0;          
1034:  MOVLB  1
1036:  BCF    xD4.0
1038:  MOVLB  0
....................          }       
....................          if((TV_Counter_flag == 0) && (RC5_bit == 0))                           // First phase of bit = 0 
103A:  BTFSC  22.6
103C:  BRA    105C
103E:  MOVLB  1
1040:  BTFSS  xD4.0
1042:  BRA    1048
1044:  MOVLB  0
1046:  BRA    105C
....................          { 
....................             KJunior_IR_Send32x();                                               // Modulate the bit at 36kHz to send on the emitter 
1048:  MOVLB  0
104A:  RCALL  0E5C
....................             TV_Counter_flag = 0;                                                // Clear the flag to go to the next bit,   
104C:  BCF    22.6
....................             TV_Counter++;                                                       // No need to make a second phase 
104E:  INCF   x85,F
....................             set_timer0(TIMER0_886);                                             // reset the timer0 to have a proper time 
1050:  MOVLW  F2
1052:  MOVWF  FD7
1054:  MOVLW  27
1056:  MOVWF  FD6
....................             bit_clear(PIR1,1);                                                  // clear the flag of the Timer2 interrupt 
1058:  BCF    F9E.1
....................          } 
....................          else if((TV_Counter_flag == 1) && (RC5_bit == 1))                      // Second phase when a bit is = 1 
105A:  BRA    108C
105C:  BTFSS  22.6
105E:  BRA    1080
1060:  MOVLB  1
1062:  BTFSC  xD4.0
1064:  BRA    106A
1066:  MOVLB  0
1068:  BRA    1080
....................          { 
....................             KJunior_IR_Send32x();                                               // Modulate the bit at 36kHz to send on the emitter 
106A:  MOVLB  0
106C:  RCALL  0E5C
....................             TV_Counter++;                                                       // Increment the Counter to send the next bit 
106E:  INCF   x85,F
....................             TV_Counter_flag = 0;  
1070:  BCF    22.6
....................             TV_Data_loop = 1; 
1072:  BSF    x88.2
....................             set_timer0(TIMER0_886);                                             // reset the timer0 to have a proper time 
1074:  MOVLW  F2
1076:  MOVWF  FD7
1078:  MOVLW  27
107A:  MOVWF  FD6
....................             bit_clear(PIR1,1);                                                  // clear the flag of the Timer2 interrupt          
107C:  BCF    F9E.1
....................          } 
....................          else 
107E:  BRA    108C
....................          { 
....................             TV_Counter += TV_Counter_Flag;                                      // If the flag is set (second phase) increment the counter 
1080:  MOVLW  00
1082:  BTFSC  22.6
1084:  MOVLW  01
1086:  ADDWF  x85,F
....................             TV_Counter_flag = !TV_Counter_flag;                                 // Change phase of bit 
1088:  BTG    22.6
....................             output_low(IR_OUT);                                                 // Clear the IR output 
108A:  BCF    F8C.4
....................           
....................          } 
....................        
....................       }while(TV_Data_loop == 1);                                                // loop to manage the case when a 1 is following by a zero (emitting two times with no interruption) 
108C:  BTFSC  x88.2
108E:  BRA    0F96
....................    } 
....................    else                                                                         // Otherwise  
1090:  BRA    109A
....................    { 
....................       enable_interrupts(INT_EXT);                                               // Enable the external interrupt  
1092:  BSF    FF2.4
....................       disable_interrupts(INT_TIMER0);                                           // Disable the timer 0 interrupt 
1094:  BCF    FF2.5
....................       setup_timer_0(RTCC_OFF);                                                  // stop the timer0 
1096:  CLRF   FD5
....................       bit_clear(INTCON,1);                                                      // Clear the INTF bit to avoid a interrupt on the RB port 
1098:  BCF    FF2.1
....................  
....................    } 
....................     
.................... } 
....................  
109A:  BCF    FF2.2
109C:  GOTO   00A8
.................... void __default() 
.................... { 
....................   if(SerialPort == SERIAL_USB) 
*
4570:  MOVF   x74,F
4572:  BNZ   4582
....................    fprintf(USB, "Unknown Command ?!\r\n" ); 
4574:  MOVLW  A0
4576:  MOVWF  FF6
4578:  MOVLW  10
457A:  MOVWF  FF7
457C:  CALL   141C
....................   else 
4580:  BRA    458E
....................    fprintf(BT, "Unknown Command ?!\r\n" ); 
4582:  MOVLW  B6
4584:  MOVWF  FF6
4586:  MOVLW  10
4588:  MOVWF  FF7
458A:  CALL   1552
.................... } 
458E:  GOTO   4832 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Reset the KJunior uC                                                         -// 
.................... //--------------------------------------------------------------------------------//   
.................... void __Z() 
.................... { 
....................   if(SerialPort == SERIAL_USB) 
*
4530:  MOVF   x74,F
4532:  BNZ   454E
....................    fprintf(USB,"z\r\n"); 
4534:  MOVLW  7A
4536:  BTFSS  F9E.4
4538:  BRA    4536
453A:  MOVWF  FAD
453C:  MOVLW  0D
453E:  BTFSS  F9E.4
4540:  BRA    453E
4542:  MOVWF  FAD
4544:  MOVLW  0A
4546:  BTFSS  F9E.4
4548:  BRA    4546
454A:  MOVWF  FAD
....................   else 
454C:  BRA    456A
....................    fprintf(BT,"z\r\n"); 
454E:  MOVLW  7A
4550:  BTFSS  FA4.4
4552:  BRA    4550
4554:  MOVLB  F
4556:  MOVWF  x1C
4558:  MOVLW  0D
455A:  BTFSS  FA4.4
455C:  BRA    455A
455E:  MOVWF  x1C
4560:  MOVLW  0A
4562:  BTFSS  FA4.4
4564:  BRA    4562
4566:  MOVWF  x1C
4568:  MOVLB  0
....................    
....................   reset_cpu(); 
456A:  RESET
.................... } 
456C:  GOTO   4832 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Set the speed of the 2 motors during n second. Value are +/- 20 for the speed // 
.................... //  and 0-255 for the time (unit base is the ms)  
.................... //--------------------------------------------------------------------------------// 
.................... void __A(void) 
.................... { 
....................    unsigned char Arg[5]; 
....................    unsigned char i, j; 
....................    signed int8 MotG_temp; 
....................    i = 2;                                                                       // Begin with the 3 char (after the first ",") 
*
1BEE:  MOVLW  02
1BF0:  MOVLB  1
1BF2:  MOVWF  x9C
....................    j = 0; 
1BF4:  CLRF   x9D
....................    // While there no END of line "\n" or End of Char ",", place the value in a table to convert it  
....................    while((SerialBuffer[ i ] != ',') &&  (SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................    { 
1BF6:  CLRF   03
1BF8:  MOVF   x9C,W
1BFA:  ADDLW  23
1BFC:  MOVWF  FE9
1BFE:  MOVLW  00
1C00:  ADDWFC 03,W
1C02:  MOVWF  FEA
1C04:  MOVF   FEF,W
1C06:  SUBLW  2C
1C08:  BZ    1C66
1C0A:  CLRF   03
1C0C:  MOVF   x9C,W
1C0E:  ADDLW  23
1C10:  MOVWF  FE9
1C12:  MOVLW  00
1C14:  ADDWFC 03,W
1C16:  MOVWF  FEA
1C18:  MOVF   FEF,W
1C1A:  SUBLW  0A
1C1C:  BZ    1C66
1C1E:  CLRF   03
1C20:  MOVF   x9C,W
1C22:  ADDLW  23
1C24:  MOVWF  FE9
1C26:  MOVLW  00
1C28:  ADDWFC 03,W
1C2A:  MOVWF  FEA
1C2C:  MOVF   FEF,W
1C2E:  SUBLW  0D
1C30:  BZ    1C66
....................       Arg[j] = SerialBuffer[ i ]; 
1C32:  CLRF   03
1C34:  MOVF   x9D,W
1C36:  ADDLW  97
1C38:  MOVWF  01
1C3A:  MOVLW  01
1C3C:  ADDWFC 03,F
1C3E:  MOVFF  03,1A0
1C42:  CLRF   03
1C44:  MOVF   x9C,W
1C46:  ADDLW  23
1C48:  MOVWF  FE9
1C4A:  MOVLW  00
1C4C:  ADDWFC 03,W
1C4E:  MOVWF  FEA
1C50:  MOVFF  FEF,1A1
1C54:  MOVFF  1A0,FEA
1C58:  MOVFF  01,FE9
1C5C:  MOVFF  1A1,FEF
....................       i++;      
1C60:  INCF   x9C,F
....................       j++; 
1C62:  INCF   x9D,F
....................    } 
1C64:  BRA    1BF6
....................    Arg[j] ='\0';                                                                // PLace a End of sentence at the end of the values 
1C66:  CLRF   03
1C68:  MOVF   x9D,W
1C6A:  ADDLW  97
1C6C:  MOVWF  FE9
1C6E:  MOVLW  01
1C70:  ADDWFC 03,W
1C72:  MOVWF  FEA
1C74:  CLRF   FEF
....................    MotG_Temp = atoi(Arg);                                                       // Convert the table of value into a signed int8 
1C76:  MOVLW  01
1C78:  MOVWF  xA0
1C7A:  MOVLW  97
1C7C:  MOVWF  x9F
1C7E:  MOVLB  0
1C80:  RCALL  1A3E
1C82:  MOVFF  01,19E
....................    if((SerialBuffer[ i ] == 10) || (SerialBuffer[ i ] == 13))                   // If the second argument is not set (i.e. "D,20\r\n") return a error 
1C86:  CLRF   03
1C88:  MOVLB  1
1C8A:  MOVF   x9C,W
1C8C:  ADDLW  23
1C8E:  MOVWF  FE9
1C90:  MOVLW  00
1C92:  ADDWFC 03,W
1C94:  MOVWF  FEA
1C96:  MOVF   FEF,W
1C98:  SUBLW  0A
1C9A:  BZ    1CB0
1C9C:  CLRF   03
1C9E:  MOVF   x9C,W
1CA0:  ADDLW  23
1CA2:  MOVWF  FE9
1CA4:  MOVLW  00
1CA6:  ADDWFC 03,W
1CA8:  MOVWF  FEA
1CAA:  MOVF   FEF,W
1CAC:  SUBLW  0D
1CAE:  BNZ   1CD2
....................    { 
....................      if(SerialPort == SERIAL_USB) 
1CB0:  MOVLB  0
1CB2:  MOVF   x74,F
1CB4:  BNZ   1CC4
....................       fprintf(USB,"Unknown Command ?!\r\n" ); 
1CB6:  MOVLW  CC
1CB8:  MOVWF  FF6
1CBA:  MOVLW  10
1CBC:  MOVWF  FF7
1CBE:  CALL   141C
....................      else 
1CC2:  BRA    1CCE
....................       fprintf(BT,"Unknown Command ?!\r\n" ); 
1CC4:  MOVLW  E2
1CC6:  MOVWF  FF6
1CC8:  MOVLW  10
1CCA:  MOVWF  FF7
1CCC:  RCALL  1552
....................    } 
....................    else 
1CCE:  BRA    1EB8
1CD0:  MOVLB  1
....................    { 
....................       i++; 
1CD2:  INCF   x9C,F
....................       j = 0; 
1CD4:  CLRF   x9D
....................       // While there no END of line "\n" place the value in a table to convert it  
....................       while((SerialBuffer[ i ] != ',') &&  (SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................       { 
1CD6:  CLRF   03
1CD8:  MOVF   x9C,W
1CDA:  ADDLW  23
1CDC:  MOVWF  FE9
1CDE:  MOVLW  00
1CE0:  ADDWFC 03,W
1CE2:  MOVWF  FEA
1CE4:  MOVF   FEF,W
1CE6:  SUBLW  2C
1CE8:  BZ    1D46
1CEA:  CLRF   03
1CEC:  MOVF   x9C,W
1CEE:  ADDLW  23
1CF0:  MOVWF  FE9
1CF2:  MOVLW  00
1CF4:  ADDWFC 03,W
1CF6:  MOVWF  FEA
1CF8:  MOVF   FEF,W
1CFA:  SUBLW  0A
1CFC:  BZ    1D46
1CFE:  CLRF   03
1D00:  MOVF   x9C,W
1D02:  ADDLW  23
1D04:  MOVWF  FE9
1D06:  MOVLW  00
1D08:  ADDWFC 03,W
1D0A:  MOVWF  FEA
1D0C:  MOVF   FEF,W
1D0E:  SUBLW  0D
1D10:  BZ    1D46
....................          Arg[j] = SerialBuffer[ i ]; 
1D12:  CLRF   03
1D14:  MOVF   x9D,W
1D16:  ADDLW  97
1D18:  MOVWF  01
1D1A:  MOVLW  01
1D1C:  ADDWFC 03,F
1D1E:  MOVFF  03,1A0
1D22:  CLRF   03
1D24:  MOVF   x9C,W
1D26:  ADDLW  23
1D28:  MOVWF  FE9
1D2A:  MOVLW  00
1D2C:  ADDWFC 03,W
1D2E:  MOVWF  FEA
1D30:  MOVFF  FEF,1A1
1D34:  MOVFF  1A0,FEA
1D38:  MOVFF  01,FE9
1D3C:  MOVFF  1A1,FEF
....................          i++;      
1D40:  INCF   x9C,F
....................          j++; 
1D42:  INCF   x9D,F
....................       } 
1D44:  BRA    1CD6
....................       Arg[j] ='\0';                                                             // PLace a End of sentence at the end of the values 
1D46:  CLRF   03
1D48:  MOVF   x9D,W
1D4A:  ADDLW  97
1D4C:  MOVWF  FE9
1D4E:  MOVLW  01
1D50:  ADDWFC 03,W
1D52:  MOVWF  FEA
1D54:  CLRF   FEF
....................       if((SerialBuffer[ i ] == 10) || (SerialBuffer[ i ] == 13))                // If the second argument is not set (i.e. "D,20\r\n") return a error 
1D56:  CLRF   03
1D58:  MOVF   x9C,W
1D5A:  ADDLW  23
1D5C:  MOVWF  FE9
1D5E:  MOVLW  00
1D60:  ADDWFC 03,W
1D62:  MOVWF  FEA
1D64:  MOVF   FEF,W
1D66:  SUBLW  0A
1D68:  BZ    1D7E
1D6A:  CLRF   03
1D6C:  MOVF   x9C,W
1D6E:  ADDLW  23
1D70:  MOVWF  FE9
1D72:  MOVLW  00
1D74:  ADDWFC 03,W
1D76:  MOVWF  FEA
1D78:  MOVF   FEF,W
1D7A:  SUBLW  0D
1D7C:  BNZ   1DA2
....................       { 
....................         if(SerialPort == SERIAL_USB) 
1D7E:  MOVLB  0
1D80:  MOVF   x74,F
1D82:  BNZ   1D92
....................           fprintf(USB,"Unknown Command ?!\r\n" ); 
1D84:  MOVLW  F8
1D86:  MOVWF  FF6
1D88:  MOVLW  10
1D8A:  MOVWF  FF7
1D8C:  CALL   141C
....................         else 
1D90:  BRA    1D9E
....................           fprintf(BT,"Unknown Command ?!\r\n" ); 
1D92:  MOVLW  0E
1D94:  MOVWF  FF6
1D96:  MOVLW  11
1D98:  MOVWF  FF7
1D9A:  CALL   1552
....................       } 
....................       else 
1D9E:  BRA    1EB8
1DA0:  MOVLB  1
....................       { 
....................         PwmMotLeft = MotG_Temp; 
1DA2:  MOVFF  19E,1A
....................         PwmMotRight = atoi(Arg);   
1DA6:  MOVLW  01
1DA8:  MOVWF  xA0
1DAA:  MOVLW  97
1DAC:  MOVWF  x9F
1DAE:  MOVLB  0
1DB0:  RCALL  1A3E
1DB2:  MOVFF  01,1B
....................         i++; 
1DB6:  MOVLB  1
1DB8:  INCF   x9C,F
....................         j = 0; 
1DBA:  CLRF   x9D
....................         // While there no END of line "\n" place the value in a table to convert it  
....................         while((SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................         { 
1DBC:  CLRF   03
1DBE:  MOVF   x9C,W
1DC0:  ADDLW  23
1DC2:  MOVWF  FE9
1DC4:  MOVLW  00
1DC6:  ADDWFC 03,W
1DC8:  MOVWF  FEA
1DCA:  MOVF   FEF,W
1DCC:  SUBLW  0A
1DCE:  BZ    1E18
1DD0:  CLRF   03
1DD2:  MOVF   x9C,W
1DD4:  ADDLW  23
1DD6:  MOVWF  FE9
1DD8:  MOVLW  00
1DDA:  ADDWFC 03,W
1DDC:  MOVWF  FEA
1DDE:  MOVF   FEF,W
1DE0:  SUBLW  0D
1DE2:  BZ    1E18
....................            Arg[j] = SerialBuffer[ i ]; 
1DE4:  CLRF   03
1DE6:  MOVF   x9D,W
1DE8:  ADDLW  97
1DEA:  MOVWF  01
1DEC:  MOVLW  01
1DEE:  ADDWFC 03,F
1DF0:  MOVFF  03,1A0
1DF4:  CLRF   03
1DF6:  MOVF   x9C,W
1DF8:  ADDLW  23
1DFA:  MOVWF  FE9
1DFC:  MOVLW  00
1DFE:  ADDWFC 03,W
1E00:  MOVWF  FEA
1E02:  MOVFF  FEF,1A1
1E06:  MOVFF  1A0,FEA
1E0A:  MOVFF  01,FE9
1E0E:  MOVFF  1A1,FEF
....................            i++;      
1E12:  INCF   x9C,F
....................            j++; 
1E14:  INCF   x9D,F
....................         } 
1E16:  BRA    1DBC
....................         Arg[j] ='\0';                                                           // PLace a End of sentence at the end of the values         
1E18:  CLRF   03
1E1A:  MOVF   x9D,W
1E1C:  ADDLW  97
1E1E:  MOVWF  FE9
1E20:  MOVLW  01
1E22:  ADDWFC 03,W
1E24:  MOVWF  FEA
1E26:  CLRF   FEF
....................         if(PwmMotLeft >20)                                                      // Limit the minimum and maximum PWM value to -20 and 20 
1E28:  BTFSC  1A.7
1E2A:  BRA    1E38
1E2C:  MOVF   1A,W
1E2E:  SUBLW  14
1E30:  BC    1E38
....................            PwmMotLeft = 20; 
1E32:  MOVLW  14
1E34:  MOVWF  1A
....................         else if(PwmMotLeft < -20)  
1E36:  BRA    1E44
1E38:  MOVF   1A,W
1E3A:  XORLW  80
1E3C:  SUBLW  6B
1E3E:  BNC   1E44
....................            PwmMotLeft = -20; 
1E40:  MOVLW  EC
1E42:  MOVWF  1A
....................         if(PwmMotRight >20)                                                     // Limit the minimum and maximum PWM value to -20 and 20 
1E44:  BTFSC  1B.7
1E46:  BRA    1E54
1E48:  MOVF   1B,W
1E4A:  SUBLW  14
1E4C:  BC    1E54
....................           PwmMotRight = 20; 
1E4E:  MOVLW  14
1E50:  MOVWF  1B
....................         else if(PwmMotRight < -20)  
1E52:  BRA    1E60
1E54:  MOVF   1B,W
1E56:  XORLW  80
1E58:  SUBLW  6B
1E5A:  BNC   1E60
....................           PwmMotRight = -20;            
1E5C:  MOVLW  EC
1E5E:  MOVWF  1B
....................         MotorTime = atoi(Arg);                                                  // Convert the table of value into a unsigned char                
1E60:  MOVLW  01
1E62:  MOVWF  xA0
1E64:  MOVLW  97
1E66:  MOVWF  x9F
1E68:  MOVLB  0
1E6A:  RCALL  1A3E
1E6C:  MOVFF  01,8F
1E70:  CLRF   19
1E72:  BTFSC  FF2.7
1E74:  BSF    19.7
1E76:  BCF    FF2.7
....................         Motor_Conversion();                                                     // Configure the PWM output 
1E78:  CALL   0B7E
1E7C:  BTFSC  19.7
1E7E:  BSF    FF2.7
....................         if(SerialPort == SERIAL_USB) 
1E80:  MOVF   x74,F
1E82:  BNZ   1E9E
....................           fprintf(USB,"a\r\n");  
1E84:  MOVLW  61
1E86:  BTFSS  F9E.4
1E88:  BRA    1E86
1E8A:  MOVWF  FAD
1E8C:  MOVLW  0D
1E8E:  BTFSS  F9E.4
1E90:  BRA    1E8E
1E92:  MOVWF  FAD
1E94:  MOVLW  0A
1E96:  BTFSS  F9E.4
1E98:  BRA    1E96
1E9A:  MOVWF  FAD
....................         else 
1E9C:  BRA    1EB8
....................           fprintf(BT,"a\r\n");  
1E9E:  MOVLW  61
1EA0:  BTFSS  FA4.4
1EA2:  BRA    1EA0
1EA4:  MOVLB  F
1EA6:  MOVWF  x1C
1EA8:  MOVLW  0D
1EAA:  BTFSS  FA4.4
1EAC:  BRA    1EAA
1EAE:  MOVWF  x1C
1EB0:  MOVLW  0A
1EB2:  BTFSS  FA4.4
1EB4:  BRA    1EB2
1EB6:  MOVWF  x1C
1EB8:  MOVLB  0
....................       } 
....................        
....................    } 
.................... } 
1EBA:  GOTO   4832 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Read the KJunior OS version and revision                                     -// 
.................... //--------------------------------------------------------------------------------//   
.................... void __B(void) 
.................... { 
....................   if(SerialPort == SERIAL_USB) 
1EBE:  MOVF   x74,F
1EC0:  BNZ   1F06
....................    fprintf(USB, "b,%s-%02d\r\n" , KJ_FW_VERSION,KJ_FW_REVISION ); 
1EC2:  MOVLW  62
1EC4:  BTFSS  F9E.4
1EC6:  BRA    1EC4
1EC8:  MOVWF  FAD
1ECA:  MOVLW  2C
1ECC:  BTFSS  F9E.4
1ECE:  BRA    1ECC
1ED0:  MOVWF  FAD
1ED2:  MOVLW  24
1ED4:  MOVWF  FF6
1ED6:  MOVLW  11
1ED8:  MOVWF  FF7
1EDA:  CALL   141C
1EDE:  MOVLW  2D
1EE0:  BTFSS  F9E.4
1EE2:  BRA    1EE0
1EE4:  MOVWF  FAD
1EE6:  MOVLW  01
1EE8:  MOVLB  1
1EEA:  MOVWF  x98
1EEC:  MOVWF  x99
1EEE:  MOVLB  0
1EF0:  CALL   1494
1EF4:  MOVLW  0D
1EF6:  BTFSS  F9E.4
1EF8:  BRA    1EF6
1EFA:  MOVWF  FAD
1EFC:  MOVLW  0A
1EFE:  BTFSS  F9E.4
1F00:  BRA    1EFE
1F02:  MOVWF  FAD
....................   else 
1F04:  BRA    1F50
....................    fprintf(BT, "b,%s-%02d\r\n" , KJ_FW_VERSION,KJ_FW_REVISION ); 
1F06:  MOVLW  62
1F08:  BTFSS  FA4.4
1F0A:  BRA    1F08
1F0C:  MOVLB  F
1F0E:  MOVWF  x1C
1F10:  MOVLW  2C
1F12:  BTFSS  FA4.4
1F14:  BRA    1F12
1F16:  MOVWF  x1C
1F18:  MOVLW  26
1F1A:  MOVWF  FF6
1F1C:  MOVLW  11
1F1E:  MOVWF  FF7
1F20:  MOVLB  0
1F22:  CALL   1552
1F26:  MOVLW  2D
1F28:  BTFSS  FA4.4
1F2A:  BRA    1F28
1F2C:  MOVLB  F
1F2E:  MOVWF  x1C
1F30:  MOVLW  01
1F32:  MOVLB  1
1F34:  MOVWF  x98
1F36:  MOVWF  x99
1F38:  MOVLB  0
1F3A:  CALL   15A4
1F3E:  MOVLW  0D
1F40:  BTFSS  FA4.4
1F42:  BRA    1F40
1F44:  MOVLB  F
1F46:  MOVWF  x1C
1F48:  MOVLW  0A
1F4A:  BTFSS  FA4.4
1F4C:  BRA    1F4A
1F4E:  MOVWF  x1C
1F50:  MOVLB  0
.................... } 
1F52:  GOTO   4832 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Set the speed of the 2 motors. Valure are +/- 20 for each one                -// 
.................... //--------------------------------------------------------------------------------// 
.................... void __D(void) 
.................... { 
....................    unsigned char Arg[5]; 
....................    unsigned char i, j; 
....................    signed int8 MotG_temp; 
....................    i = 2;                                                                       // Begin with the 3 char (after the first ",") 
*
2062:  MOVLW  02
2064:  MOVLB  1
2066:  MOVWF  x9C
....................    j = 0; 
2068:  CLRF   x9D
....................    // While there no END of line "\n" or End of Char ",", place the value in a table to convert it  
....................    while((SerialBuffer[ i ] != ',') &&  (SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................    { 
206A:  CLRF   03
206C:  MOVF   x9C,W
206E:  ADDLW  23
2070:  MOVWF  FE9
2072:  MOVLW  00
2074:  ADDWFC 03,W
2076:  MOVWF  FEA
2078:  MOVF   FEF,W
207A:  SUBLW  2C
207C:  BZ    20DA
207E:  CLRF   03
2080:  MOVF   x9C,W
2082:  ADDLW  23
2084:  MOVWF  FE9
2086:  MOVLW  00
2088:  ADDWFC 03,W
208A:  MOVWF  FEA
208C:  MOVF   FEF,W
208E:  SUBLW  0A
2090:  BZ    20DA
2092:  CLRF   03
2094:  MOVF   x9C,W
2096:  ADDLW  23
2098:  MOVWF  FE9
209A:  MOVLW  00
209C:  ADDWFC 03,W
209E:  MOVWF  FEA
20A0:  MOVF   FEF,W
20A2:  SUBLW  0D
20A4:  BZ    20DA
....................       Arg[j] = SerialBuffer[ i ]; 
20A6:  CLRF   03
20A8:  MOVF   x9D,W
20AA:  ADDLW  97
20AC:  MOVWF  01
20AE:  MOVLW  01
20B0:  ADDWFC 03,F
20B2:  MOVFF  03,1A0
20B6:  CLRF   03
20B8:  MOVF   x9C,W
20BA:  ADDLW  23
20BC:  MOVWF  FE9
20BE:  MOVLW  00
20C0:  ADDWFC 03,W
20C2:  MOVWF  FEA
20C4:  MOVFF  FEF,1A1
20C8:  MOVFF  1A0,FEA
20CC:  MOVFF  01,FE9
20D0:  MOVFF  1A1,FEF
....................       i++;      
20D4:  INCF   x9C,F
....................       j++; 
20D6:  INCF   x9D,F
....................    } 
20D8:  BRA    206A
....................    Arg[j] ='\0';                                                                // PLace a End of sentence at the end of the values 
20DA:  CLRF   03
20DC:  MOVF   x9D,W
20DE:  ADDLW  97
20E0:  MOVWF  FE9
20E2:  MOVLW  01
20E4:  ADDWFC 03,W
20E6:  MOVWF  FEA
20E8:  CLRF   FEF
....................    MotG_Temp = atoi(Arg);                                                       // Convert the table of value into a signed int8 
20EA:  MOVLW  01
20EC:  MOVWF  xA0
20EE:  MOVLW  97
20F0:  MOVWF  x9F
20F2:  MOVLB  0
20F4:  RCALL  1A3E
20F6:  MOVFF  01,19E
....................    if((SerialBuffer[ i ] == 10) || (SerialBuffer[ i ] == 13))                   // If the second argument is not set (i.e. "D,20\r\n") return a error 
20FA:  CLRF   03
20FC:  MOVLB  1
20FE:  MOVF   x9C,W
2100:  ADDLW  23
2102:  MOVWF  FE9
2104:  MOVLW  00
2106:  ADDWFC 03,W
2108:  MOVWF  FEA
210A:  MOVF   FEF,W
210C:  SUBLW  0A
210E:  BZ    2124
2110:  CLRF   03
2112:  MOVF   x9C,W
2114:  ADDLW  23
2116:  MOVWF  FE9
2118:  MOVLW  00
211A:  ADDWFC 03,W
211C:  MOVWF  FEA
211E:  MOVF   FEF,W
2120:  SUBLW  0D
2122:  BNZ   2148
....................    { 
....................     if(SerialPort == SERIAL_USB) 
2124:  MOVLB  0
2126:  MOVF   x74,F
2128:  BNZ   2138
....................       fprintf(USB,"Unknown Command ?!\r\n" ); 
212A:  MOVLW  28
212C:  MOVWF  FF6
212E:  MOVLW  11
2130:  MOVWF  FF7
2132:  CALL   141C
....................     else 
2136:  BRA    2144
....................       fprintf(BT,"Unknown Command ?!\r\n" ); 
2138:  MOVLW  3E
213A:  MOVWF  FF6
213C:  MOVLW  11
213E:  MOVWF  FF7
2140:  CALL   1552
....................    } 
....................    else 
2144:  BRA    224C
2146:  MOVLB  1
....................    { 
....................       i++; 
2148:  INCF   x9C,F
....................       j = 0; 
214A:  CLRF   x9D
....................       // While there no END of line "\n" place the value in a table to convert it  
....................       while((SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................       { 
214C:  CLRF   03
214E:  MOVF   x9C,W
2150:  ADDLW  23
2152:  MOVWF  FE9
2154:  MOVLW  00
2156:  ADDWFC 03,W
2158:  MOVWF  FEA
215A:  MOVF   FEF,W
215C:  SUBLW  0A
215E:  BZ    21A8
2160:  CLRF   03
2162:  MOVF   x9C,W
2164:  ADDLW  23
2166:  MOVWF  FE9
2168:  MOVLW  00
216A:  ADDWFC 03,W
216C:  MOVWF  FEA
216E:  MOVF   FEF,W
2170:  SUBLW  0D
2172:  BZ    21A8
....................          Arg[j] = SerialBuffer[ i ]; 
2174:  CLRF   03
2176:  MOVF   x9D,W
2178:  ADDLW  97
217A:  MOVWF  01
217C:  MOVLW  01
217E:  ADDWFC 03,F
2180:  MOVFF  03,1A0
2184:  CLRF   03
2186:  MOVF   x9C,W
2188:  ADDLW  23
218A:  MOVWF  FE9
218C:  MOVLW  00
218E:  ADDWFC 03,W
2190:  MOVWF  FEA
2192:  MOVFF  FEF,1A1
2196:  MOVFF  1A0,FEA
219A:  MOVFF  01,FE9
219E:  MOVFF  1A1,FEF
....................          i++;      
21A2:  INCF   x9C,F
....................          j++; 
21A4:  INCF   x9D,F
....................       } 
21A6:  BRA    214C
....................       Arg[j] ='\0';                                                             // PLace a End of sentence at the end of the values 
21A8:  CLRF   03
21AA:  MOVF   x9D,W
21AC:  ADDLW  97
21AE:  MOVWF  FE9
21B0:  MOVLW  01
21B2:  ADDWFC 03,W
21B4:  MOVWF  FEA
21B6:  CLRF   FEF
....................       PwmMotLeft = MotG_Temp; 
21B8:  MOVFF  19E,1A
....................       if(PwmMotLeft >20)                                                        // Limit the minimum and maximum PWM value to -20 and 20 
21BC:  BTFSC  1A.7
21BE:  BRA    21CC
21C0:  MOVF   1A,W
21C2:  SUBLW  14
21C4:  BC    21CC
....................          PwmMotLeft = 20; 
21C6:  MOVLW  14
21C8:  MOVWF  1A
....................       else if(PwmMotLeft < -20)  
21CA:  BRA    21D8
21CC:  MOVF   1A,W
21CE:  XORLW  80
21D0:  SUBLW  6B
21D2:  BNC   21D8
....................          PwmMotLeft = -20; 
21D4:  MOVLW  EC
21D6:  MOVWF  1A
....................       PwmMotRight = atoi(Arg);                                                  // Convert the table of value into a signed int8                
21D8:  MOVLW  01
21DA:  MOVWF  xA0
21DC:  MOVLW  97
21DE:  MOVWF  x9F
21E0:  MOVLB  0
21E2:  RCALL  1A3E
21E4:  MOVFF  01,1B
....................       if(PwmMotRight >20)                                                       // Limit the minimum and maximum PWM value to -20 and 20 
21E8:  BTFSC  1B.7
21EA:  BRA    21F8
21EC:  MOVF   1B,W
21EE:  SUBLW  14
21F0:  BC    21F8
....................          PwmMotRight = 20; 
21F2:  MOVLW  14
21F4:  MOVWF  1B
....................       else if(PwmMotRight < -20)  
21F6:  BRA    2204
21F8:  MOVF   1B,W
21FA:  XORLW  80
21FC:  SUBLW  6B
21FE:  BNC   2204
....................          PwmMotRight = -20; 
2200:  MOVLW  EC
2202:  MOVWF  1B
2204:  CLRF   19
2206:  BTFSC  FF2.7
2208:  BSF    19.7
220A:  BCF    FF2.7
....................       Motor_Conversion(); 
220C:  CALL   0B7E
2210:  BTFSC  19.7
2212:  BSF    FF2.7
....................       if(SerialPort == SERIAL_USB) 
2214:  MOVF   x74,F
2216:  BNZ   2232
....................         fprintf(USB,"d\r\n");      
2218:  MOVLW  64
221A:  BTFSS  F9E.4
221C:  BRA    221A
221E:  MOVWF  FAD
2220:  MOVLW  0D
2222:  BTFSS  F9E.4
2224:  BRA    2222
2226:  MOVWF  FAD
2228:  MOVLW  0A
222A:  BTFSS  F9E.4
222C:  BRA    222A
222E:  MOVWF  FAD
....................       else 
2230:  BRA    224C
....................         fprintf(BT,"d\r\n");      
2232:  MOVLW  64
2234:  BTFSS  FA4.4
2236:  BRA    2234
2238:  MOVLB  F
223A:  MOVWF  x1C
223C:  MOVLW  0D
223E:  BTFSS  FA4.4
2240:  BRA    223E
2242:  MOVWF  x1C
2244:  MOVLW  0A
2246:  BTFSS  FA4.4
2248:  BRA    2246
224A:  MOVWF  x1C
224C:  MOVLB  0
....................        
....................    } 
.................... } 
224E:  GOTO   4832 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- Read the Speed of the two motors (-20 to +20)                                -// 
.................... //--------------------------------------------------------------------------------//        
.................... void __E() 
.................... { 
....................   if(SerialPort == SERIAL_USB) 
*
23E4:  MOVF   x74,F
23E6:  BNZ   242E
....................    fprintf(USB,"e,%d,%d\r\n",PwmMotLeft,PwmMotRight); 
23E8:  MOVLW  65
23EA:  BTFSS  F9E.4
23EC:  BRA    23EA
23EE:  MOVWF  FAD
23F0:  MOVLW  2C
23F2:  BTFSS  F9E.4
23F4:  BRA    23F2
23F6:  MOVWF  FAD
23F8:  MOVFF  1A,197
23FC:  MOVLW  18
23FE:  MOVLB  1
2400:  MOVWF  x98
2402:  MOVLB  0
2404:  RCALL  2252
2406:  MOVLW  2C
2408:  BTFSS  F9E.4
240A:  BRA    2408
240C:  MOVWF  FAD
240E:  MOVFF  1B,197
2412:  MOVLW  18
2414:  MOVLB  1
2416:  MOVWF  x98
2418:  MOVLB  0
241A:  RCALL  2252
241C:  MOVLW  0D
241E:  BTFSS  F9E.4
2420:  BRA    241E
2422:  MOVWF  FAD
2424:  MOVLW  0A
2426:  BTFSS  F9E.4
2428:  BRA    2426
242A:  MOVWF  FAD
....................   else 
242C:  BRA    2478
....................    fprintf(BT,"e,%d,%d\r\n",PwmMotLeft,PwmMotRight); 
242E:  MOVLW  65
2430:  BTFSS  FA4.4
2432:  BRA    2430
2434:  MOVLB  F
2436:  MOVWF  x1C
2438:  MOVLW  2C
243A:  BTFSS  FA4.4
243C:  BRA    243A
243E:  MOVWF  x1C
2440:  MOVFF  1A,197
2444:  MOVLW  18
2446:  MOVLB  1
2448:  MOVWF  x98
244A:  MOVLB  0
244C:  RCALL  2314
244E:  MOVLW  2C
2450:  BTFSS  FA4.4
2452:  BRA    2450
2454:  MOVLB  F
2456:  MOVWF  x1C
2458:  MOVFF  1B,197
245C:  MOVLW  18
245E:  MOVLB  1
2460:  MOVWF  x98
2462:  MOVLB  0
2464:  RCALL  2314
2466:  MOVLW  0D
2468:  BTFSS  FA4.4
246A:  BRA    2468
246C:  MOVLB  F
246E:  MOVWF  x1C
2470:  MOVLW  0A
2472:  BTFSS  FA4.4
2474:  BRA    2472
2476:  MOVWF  x1C
2478:  MOVLB  0
.................... } 
247A:  GOTO   4832 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- Set the frequency of the buzzer, 0 = Off , 1 = 500Hz, 100 = 5kHz             -// 
.................... //--------------------------------------------------------------------------------//               
.................... void __H(void) 
.................... { 
....................    unsigned char Arg[5]; 
....................    unsigned char i, j; 
....................    i = 2;                                                                       // Begin with the 3 char (after the first ",") 
*
2816:  MOVLW  02
2818:  MOVLB  1
281A:  MOVWF  x9C
....................    j = 0; 
281C:  CLRF   x9D
....................    // While there no END of line "\n" or End of Char ",", place the value in a table to convert it  
....................    while((SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................    { 
281E:  CLRF   03
2820:  MOVF   x9C,W
2822:  ADDLW  23
2824:  MOVWF  FE9
2826:  MOVLW  00
2828:  ADDWFC 03,W
282A:  MOVWF  FEA
282C:  MOVF   FEF,W
282E:  SUBLW  0A
2830:  BZ    287A
2832:  CLRF   03
2834:  MOVF   x9C,W
2836:  ADDLW  23
2838:  MOVWF  FE9
283A:  MOVLW  00
283C:  ADDWFC 03,W
283E:  MOVWF  FEA
2840:  MOVF   FEF,W
2842:  SUBLW  0D
2844:  BZ    287A
....................       Arg[j] = SerialBuffer[ i ]; 
2846:  CLRF   03
2848:  MOVF   x9D,W
284A:  ADDLW  97
284C:  MOVWF  01
284E:  MOVLW  01
2850:  ADDWFC 03,F
2852:  MOVFF  03,19F
2856:  CLRF   03
2858:  MOVF   x9C,W
285A:  ADDLW  23
285C:  MOVWF  FE9
285E:  MOVLW  00
2860:  ADDWFC 03,W
2862:  MOVWF  FEA
2864:  MOVFF  FEF,1A0
2868:  MOVFF  19F,FEA
286C:  MOVFF  01,FE9
2870:  MOVFF  1A0,FEF
....................       i++;      
2874:  INCF   x9C,F
....................       j++; 
2876:  INCF   x9D,F
....................    } 
2878:  BRA    281E
....................    Arg[j] ='\0';                                                                // PLace a End of sentence at the end of the values 
287A:  CLRF   03
287C:  MOVF   x9D,W
287E:  ADDLW  97
2880:  MOVWF  FE9
2882:  MOVLW  01
2884:  ADDWFC 03,W
2886:  MOVWF  FEA
2888:  CLRF   FEF
....................    buzzValue = atoi(Arg);                                                       // Convert the table of value into a unsigned int8 
288A:  MOVLW  01
288C:  MOVWF  xA0
288E:  MOVLW  97
2890:  MOVWF  x9F
2892:  MOVLB  0
2894:  CALL   1A3E
2898:  MOVFF  01,105
....................    if(buzzvalue > BUZ_NUMBER)                                                   // Limit the value to 100 
289C:  MOVLB  1
289E:  MOVF   x05,W
28A0:  SUBLW  30
28A2:  BC    28A8
....................       buzzValue = BUZ_NUMBER; 
28A4:  MOVLW  30
28A6:  MOVWF  x05
....................    Set_Freq_note();                                                             // Convert the value to the corresponding note 
28A8:  MOVLB  0
28AA:  BRA    273C
....................    if(SerialPort == SERIAL_USB) 
28AC:  MOVF   x74,F
28AE:  BNZ   28CA
....................      fprintf(USB,"h\r\n");                                                      // Send the response 
28B0:  MOVLW  68
28B2:  BTFSS  F9E.4
28B4:  BRA    28B2
28B6:  MOVWF  FAD
28B8:  MOVLW  0D
28BA:  BTFSS  F9E.4
28BC:  BRA    28BA
28BE:  MOVWF  FAD
28C0:  MOVLW  0A
28C2:  BTFSS  F9E.4
28C4:  BRA    28C2
28C6:  MOVWF  FAD
....................    else 
28C8:  BRA    28E4
....................      fprintf(BT,"h\r\n");                                                       // Send the response 
28CA:  MOVLW  68
28CC:  BTFSS  FA4.4
28CE:  BRA    28CC
28D0:  MOVLB  F
28D2:  MOVWF  x1C
28D4:  MOVLW  0D
28D6:  BTFSS  FA4.4
28D8:  BRA    28D6
28DA:  MOVWF  x1C
28DC:  MOVLW  0A
28DE:  BTFSS  FA4.4
28E0:  BRA    28DE
28E2:  MOVWF  x1C
28E4:  MOVLB  0
....................  
.................... } 
28E6:  GOTO   4832 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Calibrate the IR Sensor                                                      -// 
.................... //--------------------------------------------------------------------------------//   
.................... void __K() 
.................... { 
....................    unsigned char i,j,Eeprom_temp; 
....................    signed int16 IR_Temp_Calibrate[12]; 
....................    if(SerialPort == SERIAL_USB)                                                 // If a serial cable is plugged, do not calibrate the IR (as it can disturb the measure) 
*
297C:  MOVF   x74,F
297E:  BNZ   298E
....................      fprintf(USB,"Couldn't calibrate with the USB cable plugged\r\n");          // Send the response 
2980:  MOVLW  54
2982:  MOVWF  FF6
2984:  MOVLW  11
2986:  MOVWF  FF7
2988:  CALL   141C
....................    else 
298C:  BRA    2C46
....................    { 
....................      fprintf(BT,"Place the K-Junior on a surface without obstacle near from it.\n\r"); // Send the response 
298E:  MOVLW  84
2990:  MOVWF  FF6
2992:  MOVLW  11
2994:  MOVWF  FF7
2996:  CALL   1552
....................      fprintf(BT,"Press ENTER to proceed\n\r"); 
299A:  MOVLW  C6
299C:  MOVWF  FF6
299E:  MOVLW  11
29A0:  MOVWF  FF7
29A2:  CALL   1552
....................      SerialCommandOK = 0; 
29A6:  BCF    22.4
....................      for(i=0;i<=GROUNDRIGHT;i++) 
29A8:  MOVLB  1
29AA:  CLRF   x97
29AC:  MOVF   x97,W
29AE:  SUBLW  0A
29B0:  BNC   29E2
....................      { 
....................        IR_Calibrate[i]  = 0;                                                     // Reset the calibrated value     
29B2:  BCF    FD8.0
29B4:  RLCF   x97,W
29B6:  CLRF   03
29B8:  ADDLW  C1
29BA:  MOVWF  FE9
29BC:  MOVLW  00
29BE:  ADDWFC 03,W
29C0:  MOVWF  FEA
29C2:  CLRF   FEC
29C4:  MOVF   FED,F
29C6:  CLRF   FEF
....................        IR_Temp_Calibrate[i] = 0; 
29C8:  BCF    FD8.0
29CA:  RLCF   x97,W
29CC:  CLRF   03
29CE:  ADDLW  9A
29D0:  MOVWF  FE9
29D2:  MOVLW  01
29D4:  ADDWFC 03,W
29D6:  MOVWF  FEA
29D8:  CLRF   FEC
29DA:  MOVF   FED,F
29DC:  CLRF   FEF
....................      } 
29DE:  INCF   x97,F
29E0:  BRA    29AC
....................      while(SerialCommandOK == 0);                                               // Wait the ENTER press 
29E2:  BTFSS  22.4
29E4:  BRA    29E2
....................      Auto_Refresh_Sensors = 0; 
29E6:  BCF    22.0
....................      for(j = 0; j < 8; j++) 
29E8:  CLRF   x98
29EA:  MOVF   x98,W
29EC:  SUBLW  07
29EE:  BNC   2A66
....................      { 
....................        Sensors_Refreshed_Flag = 0;                                                // Start a new measure of the IR sensor 
29F0:  BCF    22.5
....................        Manual_Refresh_sensors = 1; 
29F2:  MOVLB  0
29F4:  BSF    x88.4
....................        while(Sensors_Refreshed_Flag == 0);                                        // Wait until the sensor are refreshed 
29F6:  BTFSS  22.5
29F8:  BRA    29F6
....................        for(i=0;i<=REAR;i++) 
29FA:  MOVLB  1
29FC:  CLRF   x97
29FE:  MOVF   x97,W
2A00:  SUBLW  05
2A02:  BNC   2A62
....................        { 
....................          IR_Temp_Calibrate[i] += IR_Proximity[i];                                 // Save the value of the proximity when no obstacle are present 
2A04:  BCF    FD8.0
2A06:  RLCF   x97,W
2A08:  CLRF   03
2A0A:  ADDLW  9A
2A0C:  MOVWF  01
2A0E:  MOVLW  01
2A10:  ADDWFC 03,F
2A12:  MOVFF  01,1B2
2A16:  MOVFF  03,1B3
2A1A:  MOVFF  03,FEA
2A1E:  MOVFF  01,FE9
2A22:  MOVFF  FEC,1B5
2A26:  MOVF   FED,F
2A28:  MOVFF  FEF,1B4
2A2C:  BCF    FD8.0
2A2E:  RLCF   x97,W
2A30:  CLRF   03
2A32:  ADDLW  A9
2A34:  MOVWF  FE9
2A36:  MOVLW  00
2A38:  ADDWFC 03,W
2A3A:  MOVWF  FEA
2A3C:  MOVFF  FEC,03
2A40:  MOVF   FED,F
2A42:  MOVF   FEF,W
2A44:  ADDWF  xB4,W
2A46:  MOVWF  01
2A48:  MOVF   xB5,W
2A4A:  ADDWFC 03,F
2A4C:  MOVFF  1B3,FEA
2A50:  MOVFF  1B2,FE9
2A54:  MOVFF  03,FEC
2A58:  MOVF   FED,F
2A5A:  MOVFF  01,FEF
....................        } 
2A5E:  INCF   x97,F
2A60:  BRA    29FE
....................      } 
2A62:  INCF   x98,F
2A64:  BRA    29EA
....................      fprintf(BT,"Now return the K-Junior. The ground sensor must be free of obstacle.\n\r"); // Send the response 
2A66:  MOVLW  E0
2A68:  MOVWF  FF6
2A6A:  MOVLW  11
2A6C:  MOVWF  FF7
2A6E:  MOVLB  0
2A70:  CALL   1552
....................      fprintf(BT,"Press ENTER to proceed\n\r"); 
2A74:  MOVLW  28
2A76:  MOVWF  FF6
2A78:  MOVLW  12
2A7A:  MOVWF  FF7
2A7C:  CALL   1552
....................      SerialCommandOK = 0; 
2A80:  BCF    22.4
....................      while(SerialCommandOK == 0);                                               // Wait the ENTER press 
2A82:  BTFSS  22.4
2A84:  BRA    2A82
....................      for(j = 0; j < 8; j++) 
2A86:  MOVLB  1
2A88:  CLRF   x98
2A8A:  MOVF   x98,W
2A8C:  SUBLW  07
2A8E:  BNC   2B08
....................      { 
....................        Sensors_Refreshed_Flag = 0;                                                // Start a new measure of the IR sensor 
2A90:  BCF    22.5
....................        Manual_Refresh_sensors = 1; 
2A92:  MOVLB  0
2A94:  BSF    x88.4
....................        while(Sensors_Refreshed_Flag == 0);                                        // Wait until the sensor are refreshed 
2A96:  BTFSS  22.5
2A98:  BRA    2A96
....................        for(i=GROUNDFRONTLEFT ;i<=GROUNDRIGHT;i++) 
2A9A:  MOVLW  07
2A9C:  MOVLB  1
2A9E:  MOVWF  x97
2AA0:  MOVF   x97,W
2AA2:  SUBLW  0A
2AA4:  BNC   2B04
....................          IR_Temp_Calibrate[i] += IR_Proximity[i];                                        // Save the value of the proximity when no obstacle are present 
2AA6:  BCF    FD8.0
2AA8:  RLCF   x97,W
2AAA:  CLRF   03
2AAC:  ADDLW  9A
2AAE:  MOVWF  01
2AB0:  MOVLW  01
2AB2:  ADDWFC 03,F
2AB4:  MOVFF  01,1B2
2AB8:  MOVFF  03,1B3
2ABC:  MOVFF  03,FEA
2AC0:  MOVFF  01,FE9
2AC4:  MOVFF  FEC,1B5
2AC8:  MOVF   FED,F
2ACA:  MOVFF  FEF,1B4
2ACE:  BCF    FD8.0
2AD0:  RLCF   x97,W
2AD2:  CLRF   03
2AD4:  ADDLW  A9
2AD6:  MOVWF  FE9
2AD8:  MOVLW  00
2ADA:  ADDWFC 03,W
2ADC:  MOVWF  FEA
2ADE:  MOVFF  FEC,03
2AE2:  MOVF   FED,F
2AE4:  MOVF   FEF,W
2AE6:  ADDWF  xB4,W
2AE8:  MOVWF  01
2AEA:  MOVF   xB5,W
2AEC:  ADDWFC 03,F
2AEE:  MOVFF  1B3,FEA
2AF2:  MOVFF  1B2,FE9
2AF6:  MOVFF  03,FEC
2AFA:  MOVF   FED,F
2AFC:  MOVFF  01,FEF
2B00:  INCF   x97,F
2B02:  BRA    2AA0
....................      } 
2B04:  INCF   x98,F
2B06:  BRA    2A8A
....................      for(i = 0; i<=GROUNDRIGHT; i++) 
2B08:  CLRF   x97
2B0A:  MOVF   x97,W
2B0C:  SUBLW  0A
2B0E:  BTFSS  FD8.0
2B10:  BRA    2C36
....................      { 
....................        IR_Calibrate[i] = IR_Temp_Calibrate[i] >> 3;                             // Divide all the Calibrated value and store them in the final table 
2B12:  BCF    FD8.0
2B14:  RLCF   x97,W
2B16:  CLRF   03
2B18:  ADDLW  C1
2B1A:  MOVWF  01
2B1C:  MOVLW  00
2B1E:  ADDWFC 03,F
2B20:  MOVFF  03,1B3
2B24:  BCF    FD8.0
2B26:  RLCF   x97,W
2B28:  CLRF   03
2B2A:  ADDLW  9A
2B2C:  MOVWF  FE9
2B2E:  MOVLW  01
2B30:  ADDWFC 03,W
2B32:  MOVWF  FEA
2B34:  MOVFF  FEC,1B5
2B38:  MOVF   FED,F
2B3A:  MOVFF  FEF,1B4
2B3E:  RRCF   xB5,W
2B40:  MOVWF  03
2B42:  RRCF   xB4,W
2B44:  MOVWF  02
2B46:  RRCF   03,F
2B48:  RRCF   02,F
2B4A:  RRCF   03,F
2B4C:  RRCF   02,F
2B4E:  MOVLW  1F
2B50:  ANDWF  03,F
2B52:  MOVFF  1B3,FEA
2B56:  MOVFF  01,FE9
2B5A:  MOVFF  03,FEC
2B5E:  MOVF   FED,F
2B60:  MOVFF  02,FEF
....................        IR_Calibrate[i] += IR_CALIB_TH; 
2B64:  BCF    FD8.0
2B66:  RLCF   x97,W
2B68:  CLRF   03
2B6A:  ADDLW  C1
2B6C:  MOVWF  FE9
2B6E:  MOVLW  00
2B70:  ADDWFC 03,W
2B72:  MOVWF  FEA
2B74:  MOVLW  14
2B76:  ADDWF  FEF,W
2B78:  MOVWF  01
2B7A:  MOVLW  00
2B7C:  ADDWFC FEC,W
2B7E:  MOVF   FED,F
2B80:  MOVFF  01,FEF
2B84:  MOVWF  FEC
....................        Eeprom_temp = IR_Calibrate[i] & 0x00FF;                                  // Save the calibrate data in the EEPROM 
2B86:  BCF    FD8.0
2B88:  RLCF   x97,W
2B8A:  CLRF   03
2B8C:  ADDLW  C1
2B8E:  MOVWF  FE9
2B90:  MOVLW  00
2B92:  ADDWFC 03,W
2B94:  MOVWF  FEA
2B96:  MOVFF  FEC,1B3
2B9A:  MOVF   FED,F
2B9C:  MOVFF  FEF,1B2
2BA0:  MOVFF  1B2,199
....................        write_eeprom(EEPROM_ADD*2*i,Eeprom_temp); 
2BA4:  MOVF   x97,W
2BA6:  MULLW  14
2BA8:  MOVF   FF3,W
2BAA:  MOVWF  xB2
2BAC:  MOVF   FF2,W
2BAE:  MOVWF  00
2BB0:  BCF    FF2.7
2BB2:  CLRF   F63
2BB4:  MOVFF  1B2,F62
2BB8:  MOVFF  199,F61
2BBC:  BCF    F7F.6
2BBE:  BCF    F7F.7
2BC0:  BSF    F7F.2
2BC2:  MOVLB  F
2BC4:  MOVLW  55
2BC6:  MOVWF  F7E
2BC8:  MOVLW  AA
2BCA:  MOVWF  F7E
2BCC:  BSF    F7F.1
2BCE:  BTFSC  F7F.1
2BD0:  BRA    2BCE
2BD2:  BCF    F7F.2
2BD4:  MOVF   00,W
2BD6:  IORWF  FF2,F
....................        Eeprom_temp = (IR_Calibrate[i] & 0xFF00) >> 8; 
2BD8:  BCF    FD8.0
2BDA:  MOVLB  1
2BDC:  RLCF   x97,W
2BDE:  CLRF   03
2BE0:  ADDLW  C1
2BE2:  MOVWF  FE9
2BE4:  MOVLW  00
2BE6:  ADDWFC 03,W
2BE8:  MOVWF  FEA
2BEA:  MOVFF  FEC,1B3
2BEE:  MOVF   FED,F
2BF0:  MOVFF  FEF,1B2
2BF4:  CLRF   xB2
2BF6:  MOVFF  1B3,199
....................        write_eeprom((EEPROM_ADD*2*i)+1,Eeprom_temp); 
2BFA:  MOVF   x97,W
2BFC:  MULLW  14
2BFE:  MOVF   FF3,W
2C00:  ADDLW  01
2C02:  MOVWF  xB2
2C04:  MOVF   FF2,W
2C06:  MOVWF  00
2C08:  BCF    FF2.7
2C0A:  CLRF   F63
2C0C:  MOVFF  1B2,F62
2C10:  MOVFF  199,F61
2C14:  BCF    F7F.6
2C16:  BCF    F7F.7
2C18:  BSF    F7F.2
2C1A:  MOVLB  F
2C1C:  MOVLW  55
2C1E:  MOVWF  F7E
2C20:  MOVLW  AA
2C22:  MOVWF  F7E
2C24:  BSF    F7F.1
2C26:  BTFSC  F7F.1
2C28:  BRA    2C26
2C2A:  BCF    F7F.2
2C2C:  MOVF   00,W
2C2E:  IORWF  FF2,F
....................         
....................      } 
2C30:  MOVLB  1
2C32:  INCF   x97,F
2C34:  BRA    2B0A
....................      Auto_Refresh_Sensors = 1; 
2C36:  BSF    22.0
....................      fprintf(BT,"Calibration done\n\r");                                        // Send the response 
2C38:  MOVLW  42
2C3A:  MOVWF  FF6
2C3C:  MOVLW  12
2C3E:  MOVWF  FF7
2C40:  MOVLB  0
2C42:  CALL   1552
....................       
....................  
....................    } 
.................... } 
2C46:  GOTO   4832 (RETURN)
....................  
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Scan the I2C Bus                                                             -// 
.................... //--------------------------------------------------------------------------------//   
.................... void __J() 
.................... { 
....................    unsigned char i; 
....................    unsigned char TempVal; 
....................    printf("j"); 
*
2C82:  MOVLW  6A
2C84:  BTFSS  FA4.4
2C86:  BRA    2C84
2C88:  MOVLB  F
2C8A:  MOVWF  x1C
....................    for(i=3;i<254;i=i+2)                                                         // Try all the available I2C address (0x00 to 0xFF) 
2C8C:  MOVLW  03
2C8E:  MOVLB  1
2C90:  MOVWF  x97
2C92:  MOVF   x97,W
2C94:  SUBLW  FD
2C96:  BNC   2D22
....................    { 
....................       i2c_start(); 
2C98:  BSF    FC5.0
2C9A:  BTFSC  FC5.0
2C9C:  BRA    2C9A
....................       if(i2c_write(i-1)==0)                                                     // If a device is detected 
2C9E:  MOVLW  01
2CA0:  SUBWF  x97,W
2CA2:  MOVWF  x99
2CA4:  MOVWF  xCE
2CA6:  MOVLB  0
2CA8:  RCALL  2C4A
2CAA:  MOVF   01,F
2CAC:  BNZ   2D14
....................       { 
....................          i2c_write(0x00);                                                       // Version Register 
2CAE:  MOVLB  1
2CB0:  CLRF   xCE
2CB2:  MOVLB  0
2CB4:  RCALL  2C4A
....................          i2c_start(); 
2CB6:  BSF    FC5.1
2CB8:  BTFSC  FC5.1
2CBA:  BRA    2CB8
....................          i2c_write(i); 
2CBC:  MOVFF  197,1CE
2CC0:  RCALL  2C4A
....................          TempVal=i2c_read(0);                                                   // Read the Version register to validate the communication 
2CC2:  CLRF   00
2CC4:  RCALL  2C66
2CC6:  MOVFF  01,198
....................          i2c_stop(); 
2CCA:  BSF    FC5.2
2CCC:  BTFSC  FC5.2
2CCE:  BRA    2CCC
....................          if(SerialPort == SERIAL_USB) 
2CD0:  MOVF   x74,F
2CD2:  BNZ   2CF2
....................            fprintf(USB,",%2x",i-1); 
2CD4:  MOVLW  01
2CD6:  MOVLB  1
2CD8:  SUBWF  x97,W
2CDA:  MOVWF  x99
2CDC:  MOVLW  2C
2CDE:  BTFSS  F9E.4
2CE0:  BRA    2CDE
2CE2:  MOVWF  FAD
2CE4:  MOVFF  199,19A
2CE8:  MOVLW  57
2CEA:  MOVWF  x9B
2CEC:  MOVLB  0
2CEE:  RCALL  28EA
....................          else 
2CF0:  BRA    2D12
....................            fprintf(BT,",%2x",i-1);  
2CF2:  MOVLW  01
2CF4:  MOVLB  1
2CF6:  SUBWF  x97,W
2CF8:  MOVWF  x99
2CFA:  MOVLW  2C
2CFC:  BTFSS  FA4.4
2CFE:  BRA    2CFC
2D00:  MOVLB  F
2D02:  MOVWF  x1C
2D04:  MOVFF  199,19A
2D08:  MOVLW  57
2D0A:  MOVLB  1
2D0C:  MOVWF  x9B
2D0E:  MOVLB  0
2D10:  RCALL  2930
....................       } 
....................       else 
2D12:  BRA    2D1A
....................       { 
....................          i2c_stop();                                                            // Stop the I2C communication 
2D14:  BSF    FC5.2
2D16:  BTFSC  FC5.2
2D18:  BRA    2D16
....................       } 
....................    } 
2D1A:  MOVLW  02
2D1C:  MOVLB  1
2D1E:  ADDWF  x97,F
2D20:  BRA    2C92
....................    if(SerialPort == SERIAL_USB) 
2D22:  MOVLB  0
2D24:  MOVF   x74,F
2D26:  BNZ   2D3A
....................      fprintf(USB,"\r\n"); 
2D28:  MOVLW  0D
2D2A:  BTFSS  F9E.4
2D2C:  BRA    2D2A
2D2E:  MOVWF  FAD
2D30:  MOVLW  0A
2D32:  BTFSS  F9E.4
2D34:  BRA    2D32
2D36:  MOVWF  FAD
....................    else 
2D38:  BRA    2D4C
....................      fprintf(BT,"\r\n"); 
2D3A:  MOVLW  0D
2D3C:  BTFSS  FA4.4
2D3E:  BRA    2D3C
2D40:  MOVLB  F
2D42:  MOVWF  x1C
2D44:  MOVLW  0A
2D46:  BTFSS  FA4.4
2D48:  BRA    2D46
2D4A:  MOVWF  x1C
2D4C:  MOVLB  0
.................... } 
2D4E:  GOTO   4832 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- Set the LED value                                                            -// 
.................... //--------------------------------------------------------------------------------//   
.................... //#separate 
.................... void __L(void) 
.................... { 
....................    unsigned char LED_temp; 
....................  
....................   switch(SerialBuffer[2]) 
....................    { 
*
2DC8:  MOVF   25,W
2DCA:  XORLW  30
2DCC:  BZ    2DE0
2DCE:  XORLW  01
2DD0:  BZ    2DE8
2DD2:  XORLW  03
2DD4:  BZ    2DF0
2DD6:  XORLW  01
2DD8:  BZ    2DF8
2DDA:  XORLW  07
2DDC:  BZ    2E00
2DDE:  BRA    2E0A
....................       case '0': 
....................          LED_temp = LED0; 
2DE0:  MOVLW  09
2DE2:  MOVLB  1
2DE4:  MOVWF  x97
....................          break; 
2DE6:  BRA    2E2A
....................       case '1': 
....................          LED_temp = LED1; 
2DE8:  MOVLW  0A
2DEA:  MOVLB  1
2DEC:  MOVWF  x97
....................          break; 
2DEE:  BRA    2E2A
....................       case '2': 
....................          LED_temp = LED2; 
2DF0:  MOVLW  0B
2DF2:  MOVLB  1
2DF4:  MOVWF  x97
....................          break; 
2DF6:  BRA    2E2A
....................       case '3': 
....................          LED_temp = LED3; 
2DF8:  MOVLW  0C
2DFA:  MOVLB  1
2DFC:  MOVWF  x97
....................          break; 
2DFE:  BRA    2E2A
....................       case '4': 
....................          LED_temp = LED4; 
2E00:  MOVLW  0D
2E02:  MOVLB  1
2E04:  MOVWF  x97
....................          break; 
2E06:  BRA    2E2A
2E08:  MOVLB  0
....................       default: 
....................          if(SerialPort == SERIAL_USB) 
2E0A:  MOVF   x74,F
2E0C:  BNZ   2E1C
....................            fprintf(USB,"Unknown Command ?!\r\n" ); 
2E0E:  MOVLW  56
2E10:  MOVWF  FF6
2E12:  MOVLW  12
2E14:  MOVWF  FF7
2E16:  CALL   141C
....................          else 
2E1A:  BRA    2E28
....................            fprintf(BT,"Unknown Command ?!\r\n" ); 
2E1C:  MOVLW  6C
2E1E:  MOVWF  FF6
2E20:  MOVLW  12
2E22:  MOVWF  FF7
2E24:  CALL   1552
....................          break; 
2E28:  MOVLB  1
....................    } 
....................    if(SerialBuffer[4] == '3')                                                   // Activate the auto mode of the LED 
2E2A:  MOVF   27,W
2E2C:  SUBLW  33
2E2E:  BNZ   2E4C
....................       LED_Mode |= (0x01 << (SerialBuffer[2] - '0')); 
2E30:  MOVLW  30
2E32:  SUBWF  25,W
2E34:  MOVWF  01
2E36:  MOVLW  01
2E38:  MOVWF  00
2E3A:  MOVF   01,F
2E3C:  BZ    2E46
2E3E:  BCF    FD8.0
2E40:  RLCF   00,F
2E42:  DECFSZ 01,F
2E44:  BRA    2E3E
2E46:  MOVF   00,W
2E48:  IORWF  x02,F
....................    else 
2E4A:  BRA    2EE4
....................    { 
....................       if(SerialBuffer[4] == '2')                                                // Toggle the Selected LED 
2E4C:  MOVF   27,W
2E4E:  SUBLW  32
2E50:  BNZ   2E96
....................       { 
....................          if(input(LED_temp)) 
2E52:  MOVFF  197,198
2E56:  MOVLW  0F
2E58:  MOVWF  x9A
2E5A:  MOVLW  80
2E5C:  MOVWF  x99
2E5E:  MOVLB  0
2E60:  BRA    2D52
2E62:  BTFSS  01.0
2E64:  BRA    2E7C
....................             output_low(LED_TEMP); 
2E66:  MOVFF  197,198
2E6A:  MOVLB  1
2E6C:  CLRF   x99
2E6E:  MOVLW  0F
2E70:  MOVWF  x9B
2E72:  MOVLW  89
2E74:  MOVWF  x9A
2E76:  MOVLB  0
2E78:  RCALL  2D86
....................          else 
2E7A:  BRA    2E92
....................             output_high(LED_TEMP); 
2E7C:  MOVFF  197,198
2E80:  MOVLW  01
2E82:  MOVLB  1
2E84:  MOVWF  x99
2E86:  MOVLW  0F
2E88:  MOVWF  x9B
2E8A:  MOVLW  89
2E8C:  MOVWF  x9A
2E8E:  MOVLB  0
2E90:  RCALL  2D86
....................       } 
....................       else if(SerialBuffer[4] == '0') 
2E92:  BRA    2EC6
2E94:  MOVLB  1
2E96:  MOVF   27,W
2E98:  SUBLW  30
2E9A:  BNZ   2EB2
....................           output_low(LED_temp);                                                 // Turn OFF the selected LED 
2E9C:  MOVFF  197,198
2EA0:  CLRF   x99
2EA2:  MOVLW  0F
2EA4:  MOVWF  x9B
2EA6:  MOVLW  89
2EA8:  MOVWF  x9A
2EAA:  MOVLB  0
2EAC:  RCALL  2D86
....................       else                                                   
2EAE:  BRA    2EC6
2EB0:  MOVLB  1
....................          output_high(LED_temp);                                                 // Turn ON the selected LED 
2EB2:  MOVFF  197,198
2EB6:  MOVLW  01
2EB8:  MOVWF  x99
2EBA:  MOVLW  0F
2EBC:  MOVWF  x9B
2EBE:  MOVLW  89
2EC0:  MOVWF  x9A
2EC2:  MOVLB  0
2EC4:  RCALL  2D86
....................       LED_Mode &= 0xff - (0x01 << (SerialBuffer[2] - '0'));                     // Reset the flag of the auto mode 
2EC6:  MOVLW  30
2EC8:  SUBWF  25,W
2ECA:  MOVWF  01
2ECC:  MOVLW  01
2ECE:  MOVWF  00
2ED0:  MOVF   01,F
2ED2:  BZ    2EDC
2ED4:  BCF    FD8.0
2ED6:  RLCF   00,F
2ED8:  DECFSZ 01,F
2EDA:  BRA    2ED4
2EDC:  MOVF   00,W
2EDE:  SUBLW  FF
2EE0:  MOVLB  1
2EE2:  ANDWF  x02,F
....................    }                
....................    if(SerialPort == SERIAL_USB) 
2EE4:  MOVLB  0
2EE6:  MOVF   x74,F
2EE8:  BNZ   2F04
....................      fprintf(USB,"l\r\n"); 
2EEA:  MOVLW  6C
2EEC:  BTFSS  F9E.4
2EEE:  BRA    2EEC
2EF0:  MOVWF  FAD
2EF2:  MOVLW  0D
2EF4:  BTFSS  F9E.4
2EF6:  BRA    2EF4
2EF8:  MOVWF  FAD
2EFA:  MOVLW  0A
2EFC:  BTFSS  F9E.4
2EFE:  BRA    2EFC
2F00:  MOVWF  FAD
....................    else 
2F02:  BRA    2F1E
....................      fprintf(BT,"l\r\n"); 
2F04:  MOVLW  6C
2F06:  BTFSS  FA4.4
2F08:  BRA    2F06
2F0A:  MOVLB  F
2F0C:  MOVWF  x1C
2F0E:  MOVLW  0D
2F10:  BTFSS  FA4.4
2F12:  BRA    2F10
2F14:  MOVWF  x1C
2F16:  MOVLW  0A
2F18:  BTFSS  FA4.4
2F1A:  BRA    2F18
2F1C:  MOVWF  x1C
2F1E:  MOVLB  0
.................... } 
2F20:  GOTO   4832 (RETURN)
....................  
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Return the values of the IR Proximity sensor                                 -// 
.................... //--------------------------------------------------------------------------------//    
.................... //#separate 
.................... void __N(void) 
.................... { 
....................   if(SerialPort == SERIAL_USB) 
*
30EC:  MOVF   x74,F
30EE:  BTFSS  FD8.2
30F0:  BRA    31E8
....................    fprintf(USB, "n,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld\r\n" , IR_Proximity[ LEFT ] , IR_Proximity[ FrontLEFT ] , 
....................          IR_Proximity[ FRONT ] , IR_Proximity[ FRONTRIGHT] , IR_Proximity[ RIGHT] , IR_Proximity[ REAR ] , 
....................          IR_Proximity[ GROUNDLEFT ] , IR_Proximity[ GROUNDFRONTLEFT ], IR_Proximity[ GROUNDFRONTRIGHT ] , IR_Proximity[ GROUNDRIGHT ]  ); 
30F2:  MOVLW  6E
30F4:  BTFSS  F9E.4
30F6:  BRA    30F4
30F8:  MOVWF  FAD
30FA:  MOVLW  2C
30FC:  BTFSS  F9E.4
30FE:  BRA    30FC
3100:  MOVWF  FAD
3102:  MOVLW  0A
3104:  MOVWF  FE9
3106:  MOVFF  AA,198
310A:  MOVFF  A9,197
310E:  RCALL  2F24
3110:  MOVLW  2C
3112:  BTFSS  F9E.4
3114:  BRA    3112
3116:  MOVWF  FAD
3118:  MOVLW  0A
311A:  MOVWF  FE9
311C:  MOVFF  AC,198
3120:  MOVFF  AB,197
3124:  RCALL  2F24
3126:  MOVLW  2C
3128:  BTFSS  F9E.4
312A:  BRA    3128
312C:  MOVWF  FAD
312E:  MOVLW  0A
3130:  MOVWF  FE9
3132:  MOVFF  AE,198
3136:  MOVFF  AD,197
313A:  RCALL  2F24
313C:  MOVLW  2C
313E:  BTFSS  F9E.4
3140:  BRA    313E
3142:  MOVWF  FAD
3144:  MOVLW  0A
3146:  MOVWF  FE9
3148:  MOVFF  B0,198
314C:  MOVFF  AF,197
3150:  RCALL  2F24
3152:  MOVLW  2C
3154:  BTFSS  F9E.4
3156:  BRA    3154
3158:  MOVWF  FAD
315A:  MOVLW  0A
315C:  MOVWF  FE9
315E:  MOVFF  B2,198
3162:  MOVFF  B1,197
3166:  RCALL  2F24
3168:  MOVLW  2C
316A:  BTFSS  F9E.4
316C:  BRA    316A
316E:  MOVWF  FAD
3170:  MOVLW  0A
3172:  MOVWF  FE9
3174:  MOVFF  B4,198
3178:  MOVFF  B3,197
317C:  RCALL  2F24
317E:  MOVLW  2C
3180:  BTFSS  F9E.4
3182:  BRA    3180
3184:  MOVWF  FAD
3186:  MOVLW  0A
3188:  MOVWF  FE9
318A:  MOVFF  BC,198
318E:  MOVFF  BB,197
3192:  RCALL  2F24
3194:  MOVLW  2C
3196:  BTFSS  F9E.4
3198:  BRA    3196
319A:  MOVWF  FAD
319C:  MOVLW  0A
319E:  MOVWF  FE9
31A0:  MOVFF  B8,198
31A4:  MOVFF  B7,197
31A8:  RCALL  2F24
31AA:  MOVLW  2C
31AC:  BTFSS  F9E.4
31AE:  BRA    31AC
31B0:  MOVWF  FAD
31B2:  MOVLW  0A
31B4:  MOVWF  FE9
31B6:  MOVFF  BA,198
31BA:  MOVFF  B9,197
31BE:  RCALL  2F24
31C0:  MOVLW  2C
31C2:  BTFSS  F9E.4
31C4:  BRA    31C2
31C6:  MOVWF  FAD
31C8:  MOVLW  0A
31CA:  MOVWF  FE9
31CC:  MOVFF  BE,198
31D0:  MOVFF  BD,197
31D4:  RCALL  2F24
31D6:  MOVLW  0D
31D8:  BTFSS  F9E.4
31DA:  BRA    31D8
31DC:  MOVWF  FAD
31DE:  MOVLW  0A
31E0:  BTFSS  F9E.4
31E2:  BRA    31E0
31E4:  MOVWF  FAD
....................   else 
31E6:  BRA    3306
....................    fprintf(BT, "n,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld\r\n" , IR_Proximity[ LEFT ] , IR_Proximity[ FrontLEFT ] , 
....................          IR_Proximity[ FRONT ] , IR_Proximity[ FRONTRIGHT] , IR_Proximity[ RIGHT] , IR_Proximity[ REAR ] , 
....................          IR_Proximity[ GROUNDLEFT ] , IR_Proximity[ GROUNDFRONTLEFT ], IR_Proximity[ GROUNDFRONTRIGHT ] , IR_Proximity[ GROUNDRIGHT ]  ); 
31E8:  MOVLW  6E
31EA:  BTFSS  FA4.4
31EC:  BRA    31EA
31EE:  MOVLB  F
31F0:  MOVWF  x1C
31F2:  MOVLW  2C
31F4:  BTFSS  FA4.4
31F6:  BRA    31F4
31F8:  MOVWF  x1C
31FA:  MOVLW  0A
31FC:  MOVWF  FE9
31FE:  MOVFF  AA,198
3202:  MOVFF  A9,197
3206:  MOVLB  0
3208:  RCALL  3006
320A:  MOVLW  2C
320C:  BTFSS  FA4.4
320E:  BRA    320C
3210:  MOVLB  F
3212:  MOVWF  x1C
3214:  MOVLW  0A
3216:  MOVWF  FE9
3218:  MOVFF  AC,198
321C:  MOVFF  AB,197
3220:  MOVLB  0
3222:  RCALL  3006
3224:  MOVLW  2C
3226:  BTFSS  FA4.4
3228:  BRA    3226
322A:  MOVLB  F
322C:  MOVWF  x1C
322E:  MOVLW  0A
3230:  MOVWF  FE9
3232:  MOVFF  AE,198
3236:  MOVFF  AD,197
323A:  MOVLB  0
323C:  RCALL  3006
323E:  MOVLW  2C
3240:  BTFSS  FA4.4
3242:  BRA    3240
3244:  MOVLB  F
3246:  MOVWF  x1C
3248:  MOVLW  0A
324A:  MOVWF  FE9
324C:  MOVFF  B0,198
3250:  MOVFF  AF,197
3254:  MOVLB  0
3256:  RCALL  3006
3258:  MOVLW  2C
325A:  BTFSS  FA4.4
325C:  BRA    325A
325E:  MOVLB  F
3260:  MOVWF  x1C
3262:  MOVLW  0A
3264:  MOVWF  FE9
3266:  MOVFF  B2,198
326A:  MOVFF  B1,197
326E:  MOVLB  0
3270:  RCALL  3006
3272:  MOVLW  2C
3274:  BTFSS  FA4.4
3276:  BRA    3274
3278:  MOVLB  F
327A:  MOVWF  x1C
327C:  MOVLW  0A
327E:  MOVWF  FE9
3280:  MOVFF  B4,198
3284:  MOVFF  B3,197
3288:  MOVLB  0
328A:  RCALL  3006
328C:  MOVLW  2C
328E:  BTFSS  FA4.4
3290:  BRA    328E
3292:  MOVLB  F
3294:  MOVWF  x1C
3296:  MOVLW  0A
3298:  MOVWF  FE9
329A:  MOVFF  BC,198
329E:  MOVFF  BB,197
32A2:  MOVLB  0
32A4:  RCALL  3006
32A6:  MOVLW  2C
32A8:  BTFSS  FA4.4
32AA:  BRA    32A8
32AC:  MOVLB  F
32AE:  MOVWF  x1C
32B0:  MOVLW  0A
32B2:  MOVWF  FE9
32B4:  MOVFF  B8,198
32B8:  MOVFF  B7,197
32BC:  MOVLB  0
32BE:  RCALL  3006
32C0:  MOVLW  2C
32C2:  BTFSS  FA4.4
32C4:  BRA    32C2
32C6:  MOVLB  F
32C8:  MOVWF  x1C
32CA:  MOVLW  0A
32CC:  MOVWF  FE9
32CE:  MOVFF  BA,198
32D2:  MOVFF  B9,197
32D6:  MOVLB  0
32D8:  RCALL  3006
32DA:  MOVLW  2C
32DC:  BTFSS  FA4.4
32DE:  BRA    32DC
32E0:  MOVLB  F
32E2:  MOVWF  x1C
32E4:  MOVLW  0A
32E6:  MOVWF  FE9
32E8:  MOVFF  BE,198
32EC:  MOVFF  BD,197
32F0:  MOVLB  0
32F2:  RCALL  3006
32F4:  MOVLW  0D
32F6:  BTFSS  FA4.4
32F8:  BRA    32F6
32FA:  MOVLB  F
32FC:  MOVWF  x1C
32FE:  MOVLW  0A
3300:  BTFSS  FA4.4
3302:  BRA    3300
3304:  MOVWF  x1C
3306:  MOVLB  0
....................    
.................... } 
3308:  GOTO   4832 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- Return the values of the IR Ambient light sensor                             -// 
.................... //--------------------------------------------------------------------------------//                   
.................... //#separate 
.................... void __O(void) 
.................... { 
....................   if(SerialPort == SERIAL_USB) 
330C:  MOVF   x74,F
330E:  BTFSS  FD8.2
3310:  BRA    3408
....................    fprintf(USB, "o,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld\r\n" , IR_Light[ LEFT ] , IR_Light[ FrontLEFT ] , 
....................          IR_Light[ FRONT ] , IR_Light[ FRONTRIGHT] , IR_Light[ RIGHT] , IR_Light[ REAR ] , 
....................          IR_Light[ GROUNDLEFT ] , IR_Light[ GROUNDFRONTLEFT ], IR_Light[ GROUNDFRONTRIGHT ] , IR_Light[ GROUNDRIGHT ]  ); 
3312:  MOVLW  6F
3314:  BTFSS  F9E.4
3316:  BRA    3314
3318:  MOVWF  FAD
331A:  MOVLW  2C
331C:  BTFSS  F9E.4
331E:  BRA    331C
3320:  MOVWF  FAD
3322:  MOVLW  0A
3324:  MOVWF  FE9
3326:  MOVFF  92,198
332A:  MOVFF  91,197
332E:  RCALL  2F24
3330:  MOVLW  2C
3332:  BTFSS  F9E.4
3334:  BRA    3332
3336:  MOVWF  FAD
3338:  MOVLW  0A
333A:  MOVWF  FE9
333C:  MOVFF  94,198
3340:  MOVFF  93,197
3344:  RCALL  2F24
3346:  MOVLW  2C
3348:  BTFSS  F9E.4
334A:  BRA    3348
334C:  MOVWF  FAD
334E:  MOVLW  0A
3350:  MOVWF  FE9
3352:  MOVFF  96,198
3356:  MOVFF  95,197
335A:  RCALL  2F24
335C:  MOVLW  2C
335E:  BTFSS  F9E.4
3360:  BRA    335E
3362:  MOVWF  FAD
3364:  MOVLW  0A
3366:  MOVWF  FE9
3368:  MOVFF  98,198
336C:  MOVFF  97,197
3370:  RCALL  2F24
3372:  MOVLW  2C
3374:  BTFSS  F9E.4
3376:  BRA    3374
3378:  MOVWF  FAD
337A:  MOVLW  0A
337C:  MOVWF  FE9
337E:  MOVFF  9A,198
3382:  MOVFF  99,197
3386:  RCALL  2F24
3388:  MOVLW  2C
338A:  BTFSS  F9E.4
338C:  BRA    338A
338E:  MOVWF  FAD
3390:  MOVLW  0A
3392:  MOVWF  FE9
3394:  MOVFF  9C,198
3398:  MOVFF  9B,197
339C:  RCALL  2F24
339E:  MOVLW  2C
33A0:  BTFSS  F9E.4
33A2:  BRA    33A0
33A4:  MOVWF  FAD
33A6:  MOVLW  0A
33A8:  MOVWF  FE9
33AA:  MOVFF  A4,198
33AE:  MOVFF  A3,197
33B2:  RCALL  2F24
33B4:  MOVLW  2C
33B6:  BTFSS  F9E.4
33B8:  BRA    33B6
33BA:  MOVWF  FAD
33BC:  MOVLW  0A
33BE:  MOVWF  FE9
33C0:  MOVFF  A0,198
33C4:  MOVFF  9F,197
33C8:  RCALL  2F24
33CA:  MOVLW  2C
33CC:  BTFSS  F9E.4
33CE:  BRA    33CC
33D0:  MOVWF  FAD
33D2:  MOVLW  0A
33D4:  MOVWF  FE9
33D6:  MOVFF  A2,198
33DA:  MOVFF  A1,197
33DE:  RCALL  2F24
33E0:  MOVLW  2C
33E2:  BTFSS  F9E.4
33E4:  BRA    33E2
33E6:  MOVWF  FAD
33E8:  MOVLW  0A
33EA:  MOVWF  FE9
33EC:  MOVFF  A6,198
33F0:  MOVFF  A5,197
33F4:  RCALL  2F24
33F6:  MOVLW  0D
33F8:  BTFSS  F9E.4
33FA:  BRA    33F8
33FC:  MOVWF  FAD
33FE:  MOVLW  0A
3400:  BTFSS  F9E.4
3402:  BRA    3400
3404:  MOVWF  FAD
....................   else 
3406:  BRA    3526
....................    fprintf(BT, "o,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld\r\n" , IR_Light[ LEFT ] , IR_Light[ FrontLEFT ] , 
....................          IR_Light[ FRONT ] , IR_Light[ FRONTRIGHT] , IR_Light[ RIGHT] , IR_Light[ REAR ] , 
....................          IR_Light[ GROUNDLEFT ] , IR_Light[ GROUNDFRONTLEFT ], IR_Light[ GROUNDFRONTRIGHT ] , IR_Light[ GROUNDRIGHT ]  ); 
3408:  MOVLW  6F
340A:  BTFSS  FA4.4
340C:  BRA    340A
340E:  MOVLB  F
3410:  MOVWF  x1C
3412:  MOVLW  2C
3414:  BTFSS  FA4.4
3416:  BRA    3414
3418:  MOVWF  x1C
341A:  MOVLW  0A
341C:  MOVWF  FE9
341E:  MOVFF  92,198
3422:  MOVFF  91,197
3426:  MOVLB  0
3428:  RCALL  3006
342A:  MOVLW  2C
342C:  BTFSS  FA4.4
342E:  BRA    342C
3430:  MOVLB  F
3432:  MOVWF  x1C
3434:  MOVLW  0A
3436:  MOVWF  FE9
3438:  MOVFF  94,198
343C:  MOVFF  93,197
3440:  MOVLB  0
3442:  RCALL  3006
3444:  MOVLW  2C
3446:  BTFSS  FA4.4
3448:  BRA    3446
344A:  MOVLB  F
344C:  MOVWF  x1C
344E:  MOVLW  0A
3450:  MOVWF  FE9
3452:  MOVFF  96,198
3456:  MOVFF  95,197
345A:  MOVLB  0
345C:  RCALL  3006
345E:  MOVLW  2C
3460:  BTFSS  FA4.4
3462:  BRA    3460
3464:  MOVLB  F
3466:  MOVWF  x1C
3468:  MOVLW  0A
346A:  MOVWF  FE9
346C:  MOVFF  98,198
3470:  MOVFF  97,197
3474:  MOVLB  0
3476:  RCALL  3006
3478:  MOVLW  2C
347A:  BTFSS  FA4.4
347C:  BRA    347A
347E:  MOVLB  F
3480:  MOVWF  x1C
3482:  MOVLW  0A
3484:  MOVWF  FE9
3486:  MOVFF  9A,198
348A:  MOVFF  99,197
348E:  MOVLB  0
3490:  RCALL  3006
3492:  MOVLW  2C
3494:  BTFSS  FA4.4
3496:  BRA    3494
3498:  MOVLB  F
349A:  MOVWF  x1C
349C:  MOVLW  0A
349E:  MOVWF  FE9
34A0:  MOVFF  9C,198
34A4:  MOVFF  9B,197
34A8:  MOVLB  0
34AA:  RCALL  3006
34AC:  MOVLW  2C
34AE:  BTFSS  FA4.4
34B0:  BRA    34AE
34B2:  MOVLB  F
34B4:  MOVWF  x1C
34B6:  MOVLW  0A
34B8:  MOVWF  FE9
34BA:  MOVFF  A4,198
34BE:  MOVFF  A3,197
34C2:  MOVLB  0
34C4:  RCALL  3006
34C6:  MOVLW  2C
34C8:  BTFSS  FA4.4
34CA:  BRA    34C8
34CC:  MOVLB  F
34CE:  MOVWF  x1C
34D0:  MOVLW  0A
34D2:  MOVWF  FE9
34D4:  MOVFF  A0,198
34D8:  MOVFF  9F,197
34DC:  MOVLB  0
34DE:  RCALL  3006
34E0:  MOVLW  2C
34E2:  BTFSS  FA4.4
34E4:  BRA    34E2
34E6:  MOVLB  F
34E8:  MOVWF  x1C
34EA:  MOVLW  0A
34EC:  MOVWF  FE9
34EE:  MOVFF  A2,198
34F2:  MOVFF  A1,197
34F6:  MOVLB  0
34F8:  RCALL  3006
34FA:  MOVLW  2C
34FC:  BTFSS  FA4.4
34FE:  BRA    34FC
3500:  MOVLB  F
3502:  MOVWF  x1C
3504:  MOVLW  0A
3506:  MOVWF  FE9
3508:  MOVFF  A6,198
350C:  MOVFF  A5,197
3510:  MOVLB  0
3512:  RCALL  3006
3514:  MOVLW  0D
3516:  BTFSS  FA4.4
3518:  BRA    3516
351A:  MOVLB  F
351C:  MOVWF  x1C
351E:  MOVLW  0A
3520:  BTFSS  FA4.4
3522:  BRA    3520
3524:  MOVWF  x1C
3526:  MOVLB  0
....................  
.................... } 
3528:  GOTO   4832 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Read on the I2C Bus                                                          -// 
.................... //--------------------------------------------------------------------------------//  
.................... //#separate 
.................... void __R(void) 
.................... { 
*
3658:  MOVLB  1
365A:  CLRF   x97
365C:  CLRF   x98
365E:  CLRF   x99
....................    unsigned char memaddress = 0; 
....................    unsigned char rcvalue = 0; 
....................    unsigned char nb_bytes = 0; 
....................    unsigned char TempVal; 
....................    memaddress = chartohex(SerialBuffer[2]); 
3660:  MOVFF  25,1D1
3664:  MOVLB  0
3666:  RCALL  352C
3668:  MOVFF  01,197
....................    memaddress = (memaddress<<4) + chartohex(SerialBuffer[3]); 
366C:  MOVLB  1
366E:  SWAPF  x97,W
3670:  MOVWF  x9B
3672:  MOVLW  F0
3674:  ANDWF  x9B,F
3676:  MOVFF  26,1D1
367A:  MOVLB  0
367C:  RCALL  352C
367E:  MOVF   01,W
3680:  MOVLB  1
3682:  ADDWF  x9B,W
3684:  MOVWF  x97
....................    rcvalue = chartohex(SerialBuffer[5]); 
3686:  MOVFF  28,1D1
368A:  MOVLB  0
368C:  RCALL  352C
368E:  MOVFF  01,198
....................    rcvalue = (rcvalue<<4) + chartohex(SerialBuffer[6]); 
3692:  MOVLB  1
3694:  SWAPF  x98,W
3696:  MOVWF  x9B
3698:  MOVLW  F0
369A:  ANDWF  x9B,F
369C:  MOVFF  29,1D1
36A0:  MOVLB  0
36A2:  RCALL  352C
36A4:  MOVF   01,W
36A6:  MOVLB  1
36A8:  ADDWF  x9B,W
36AA:  MOVWF  x98
....................    nb_bytes = chartohex(SerialBuffer[8]); 
36AC:  MOVFF  2B,1D1
36B0:  MOVLB  0
36B2:  RCALL  352C
36B4:  MOVFF  01,199
....................    nb_bytes = (nb_bytes<<4) + chartohex(SerialBuffer[9]); 
36B8:  MOVLB  1
36BA:  SWAPF  x99,W
36BC:  MOVWF  x9B
36BE:  MOVLW  F0
36C0:  ANDWF  x9B,F
36C2:  MOVFF  2C,1D1
36C6:  MOVLB  0
36C8:  RCALL  352C
36CA:  MOVF   01,W
36CC:  MOVLB  1
36CE:  ADDWF  x9B,W
36D0:  MOVWF  x99
....................    i2c_start(); 
36D2:  BSF    FC5.0
36D4:  BTFSC  FC5.0
36D6:  BRA    36D4
....................    i2c_write( memaddress );                                      // Writing Address of the module 
36D8:  MOVFF  197,1CE
36DC:  MOVLB  0
36DE:  CALL   2C4A
....................    i2c_write( rcvalue );                                         // Writing Address of the register 
36E2:  MOVFF  198,1CE
36E6:  CALL   2C4A
....................    i2c_start(); 
36EA:  BSF    FC5.1
36EC:  BTFSC  FC5.1
36EE:  BRA    36EC
....................    i2c_write( memaddress + 1 );                                  // Writing Address of the module in Read Mode 
36F0:  MOVLW  01
36F2:  MOVLB  1
36F4:  ADDWF  x97,W
36F6:  MOVWF  x9B
36F8:  MOVWF  xCE
36FA:  MOVLB  0
36FC:  CALL   2C4A
....................    if(SerialPort == SERIAL_USB) 
3700:  MOVF   x74,F
3702:  BNZ   370E
....................      fprintf(USB,"r"); 
3704:  MOVLW  72
3706:  BTFSS  F9E.4
3708:  BRA    3706
370A:  MOVWF  FAD
....................    else 
370C:  BRA    371A
....................      fprintf(BT,"r"); 
370E:  MOVLW  72
3710:  BTFSS  FA4.4
3712:  BRA    3710
3714:  MOVLB  F
3716:  MOVWF  x1C
3718:  MOVLB  0
....................    while(nb_bytes> 1) 
....................    { 
371A:  MOVLB  1
371C:  MOVF   x99,W
371E:  SUBLW  01
3720:  BC    376A
....................      TempVal = i2c_read(); 
3722:  MOVLW  01
3724:  MOVWF  00
3726:  MOVLB  0
3728:  CALL   2C66
372C:  MOVFF  01,19A
....................      if(SerialPort == SERIAL_USB) 
3730:  MOVF   x74,F
3732:  BNZ   374C
....................        fprintf(USB,",%03u",TempVal); 
3734:  MOVLW  2C
3736:  BTFSS  F9E.4
3738:  BRA    3736
373A:  MOVWF  FAD
373C:  MOVFF  19A,1A1
3740:  MOVLW  03
3742:  MOVLB  1
3744:  MOVWF  xA2
3746:  MOVLB  0
3748:  RCALL  354C
....................      else 
374A:  BRA    3764
....................        fprintf(BT,",%03u",TempVal); 
374C:  MOVLW  2C
374E:  BTFSS  FA4.4
3750:  BRA    374E
3752:  MOVLB  F
3754:  MOVWF  x1C
3756:  MOVFF  19A,19B
375A:  MOVLW  03
375C:  MOVLB  1
375E:  MOVWF  x9C
3760:  MOVLB  0
3762:  RCALL  35CE
....................      nb_bytes--; 
3764:  MOVLB  1
3766:  DECF   x99,F
....................    } 
3768:  BRA    371C
....................    TempVal = i2c_read(0); 
376A:  CLRF   00
376C:  MOVLB  0
376E:  CALL   2C66
3772:  MOVFF  01,19A
....................    if(SerialPort == SERIAL_USB) 
3776:  MOVF   x74,F
3778:  BNZ   37A2
....................      fprintf(USB,",%03u\r\n",TempVal); 
377A:  MOVLW  2C
377C:  BTFSS  F9E.4
377E:  BRA    377C
3780:  MOVWF  FAD
3782:  MOVFF  19A,1A1
3786:  MOVLW  03
3788:  MOVLB  1
378A:  MOVWF  xA2
378C:  MOVLB  0
378E:  RCALL  354C
3790:  MOVLW  0D
3792:  BTFSS  F9E.4
3794:  BRA    3792
3796:  MOVWF  FAD
3798:  MOVLW  0A
379A:  BTFSS  F9E.4
379C:  BRA    379A
379E:  MOVWF  FAD
....................    else 
37A0:  BRA    37CE
....................      fprintf(BT,",%03u\r\n",TempVal); 
37A2:  MOVLW  2C
37A4:  BTFSS  FA4.4
37A6:  BRA    37A4
37A8:  MOVLB  F
37AA:  MOVWF  x1C
37AC:  MOVFF  19A,19B
37B0:  MOVLW  03
37B2:  MOVLB  1
37B4:  MOVWF  x9C
37B6:  MOVLB  0
37B8:  RCALL  35CE
37BA:  MOVLW  0D
37BC:  BTFSS  FA4.4
37BE:  BRA    37BC
37C0:  MOVLB  F
37C2:  MOVWF  x1C
37C4:  MOVLW  0A
37C6:  BTFSS  FA4.4
37C8:  BRA    37C6
37CA:  MOVWF  x1C
37CC:  MOVLB  0
....................    i2c_stop(); 
37CE:  BSF    FC5.2
37D0:  BTFSC  FC5.2
37D2:  BRA    37D0
.................... } 
37D4:  GOTO   4832 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- Return the receiving TV data                                                 -// 
.................... //--------------------------------------------------------------------------------//  
.................... //#separate 
.................... void __T() 
.................... { 
....................  if(SerialPort == SERIAL_USB) 
*
3934:  MOVF   x74,F
3936:  BNZ   397E
....................    fprintf(USB, "t,%03u,%03u\r\n" , TV_ADDR,TV_DATA ); 
3938:  MOVLW  74
393A:  BTFSS  F9E.4
393C:  BRA    393A
393E:  MOVWF  FAD
3940:  MOVLW  2C
3942:  BTFSS  F9E.4
3944:  BRA    3942
3946:  MOVWF  FAD
3948:  MOVFF  83,1A1
394C:  MOVLW  03
394E:  MOVLB  1
3950:  MOVWF  xA2
3952:  MOVLB  0
3954:  RCALL  354C
3956:  MOVLW  2C
3958:  BTFSS  F9E.4
395A:  BRA    3958
395C:  MOVWF  FAD
395E:  MOVFF  84,1A1
3962:  MOVLW  03
3964:  MOVLB  1
3966:  MOVWF  xA2
3968:  MOVLB  0
396A:  RCALL  354C
396C:  MOVLW  0D
396E:  BTFSS  F9E.4
3970:  BRA    396E
3972:  MOVWF  FAD
3974:  MOVLW  0A
3976:  BTFSS  F9E.4
3978:  BRA    3976
397A:  MOVWF  FAD
....................  else 
397C:  BRA    39C8
....................    fprintf(BT, "t,%03u,%03u\r\n" , TV_ADDR,TV_DATA ); 
397E:  MOVLW  74
3980:  BTFSS  FA4.4
3982:  BRA    3980
3984:  MOVLB  F
3986:  MOVWF  x1C
3988:  MOVLW  2C
398A:  BTFSS  FA4.4
398C:  BRA    398A
398E:  MOVWF  x1C
3990:  MOVFF  83,19B
3994:  MOVLW  03
3996:  MOVLB  1
3998:  MOVWF  x9C
399A:  MOVLB  0
399C:  RCALL  35CE
399E:  MOVLW  2C
39A0:  BTFSS  FA4.4
39A2:  BRA    39A0
39A4:  MOVLB  F
39A6:  MOVWF  x1C
39A8:  MOVFF  84,19B
39AC:  MOVLW  03
39AE:  MOVLB  1
39B0:  MOVWF  x9C
39B2:  MOVLB  0
39B4:  RCALL  35CE
39B6:  MOVLW  0D
39B8:  BTFSS  FA4.4
39BA:  BRA    39B8
39BC:  MOVLB  F
39BE:  MOVWF  x1C
39C0:  MOVLW  0A
39C2:  BTFSS  FA4.4
39C4:  BRA    39C2
39C6:  MOVWF  x1C
39C8:  MOVLB  0
.................... } 
39CA:  GOTO   4832 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- Send a RC5 data on the IR emitter                                            -// 
.................... //--------------------------------------------------------------------------------//  
.................... //#separate 
.................... void __V() 
.................... { 
....................    unsigned char Arg[5]; 
....................    unsigned char i, j; 
....................    i = 2;                                                                       // Begin with the 3 char (after the first ",") 
39CE:  MOVLW  02
39D0:  MOVLB  1
39D2:  MOVWF  x9C
....................    j = 0; 
39D4:  CLRF   x9D
....................    // While there no END of line "\n" or End of Char ",", place the value in a table to convert it  
....................    while((SerialBuffer[ i ] != ',') &&  (SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................    { 
39D6:  CLRF   03
39D8:  MOVF   x9C,W
39DA:  ADDLW  23
39DC:  MOVWF  FE9
39DE:  MOVLW  00
39E0:  ADDWFC 03,W
39E2:  MOVWF  FEA
39E4:  MOVF   FEF,W
39E6:  SUBLW  2C
39E8:  BZ    3A46
39EA:  CLRF   03
39EC:  MOVF   x9C,W
39EE:  ADDLW  23
39F0:  MOVWF  FE9
39F2:  MOVLW  00
39F4:  ADDWFC 03,W
39F6:  MOVWF  FEA
39F8:  MOVF   FEF,W
39FA:  SUBLW  0A
39FC:  BZ    3A46
39FE:  CLRF   03
3A00:  MOVF   x9C,W
3A02:  ADDLW  23
3A04:  MOVWF  FE9
3A06:  MOVLW  00
3A08:  ADDWFC 03,W
3A0A:  MOVWF  FEA
3A0C:  MOVF   FEF,W
3A0E:  SUBLW  0D
3A10:  BZ    3A46
....................       Arg[j] = SerialBuffer[ i ]; 
3A12:  CLRF   03
3A14:  MOVF   x9D,W
3A16:  ADDLW  97
3A18:  MOVWF  01
3A1A:  MOVLW  01
3A1C:  ADDWFC 03,F
3A1E:  MOVFF  03,19F
3A22:  CLRF   03
3A24:  MOVF   x9C,W
3A26:  ADDLW  23
3A28:  MOVWF  FE9
3A2A:  MOVLW  00
3A2C:  ADDWFC 03,W
3A2E:  MOVWF  FEA
3A30:  MOVFF  FEF,1A0
3A34:  MOVFF  19F,FEA
3A38:  MOVFF  01,FE9
3A3C:  MOVFF  1A0,FEF
....................       i++;      
3A40:  INCF   x9C,F
....................       j++; 
3A42:  INCF   x9D,F
....................    } 
3A44:  BRA    39D6
....................    Arg[j] ='\0';                                                                // PLace a End of sentence at the end of the values 
3A46:  CLRF   03
3A48:  MOVF   x9D,W
3A4A:  ADDLW  97
3A4C:  MOVWF  FE9
3A4E:  MOVLW  01
3A50:  ADDWFC 03,W
3A52:  MOVWF  FEA
3A54:  CLRF   FEF
....................    TV_Addr_send = atoi(Arg);                                                    // Convert the table of value into a unsigned int8 
3A56:  MOVLW  01
3A58:  MOVWF  xA0
3A5A:  MOVLW  97
3A5C:  MOVWF  x9F
3A5E:  MOVLB  0
3A60:  CALL   1A3E
3A64:  MOVFF  01,87
....................    if((SerialBuffer[ i ] == 10) || (SerialBuffer[ i ] == 13))                   // If the second argument is not set (i.e. "D,20\r\n") return a error 
3A68:  CLRF   03
3A6A:  MOVLB  1
3A6C:  MOVF   x9C,W
3A6E:  ADDLW  23
3A70:  MOVWF  FE9
3A72:  MOVLW  00
3A74:  ADDWFC 03,W
3A76:  MOVWF  FEA
3A78:  MOVF   FEF,W
3A7A:  SUBLW  0A
3A7C:  BZ    3A92
3A7E:  CLRF   03
3A80:  MOVF   x9C,W
3A82:  ADDLW  23
3A84:  MOVWF  FE9
3A86:  MOVLW  00
3A88:  ADDWFC 03,W
3A8A:  MOVWF  FEA
3A8C:  MOVF   FEF,W
3A8E:  SUBLW  0D
3A90:  BNZ   3AB6
....................    { 
....................      if(SerialPort == SERIAL_USB) 
3A92:  MOVLB  0
3A94:  MOVF   x74,F
3A96:  BNZ   3AA6
....................       fprintf(USB,"Unknown Command ?!\r\n" ); 
3A98:  MOVLW  82
3A9A:  MOVWF  FF6
3A9C:  MOVLW  12
3A9E:  MOVWF  FF7
3AA0:  CALL   141C
....................      else 
3AA4:  BRA    3AB2
....................       fprintf(BT,"Unknown Command ?!\r\n" ); 
3AA6:  MOVLW  98
3AA8:  MOVWF  FF6
3AAA:  MOVLW  12
3AAC:  MOVWF  FF7
3AAE:  CALL   1552
....................    } 
....................    else 
3AB2:  BRA    3B8E
3AB4:  MOVLB  1
....................    { 
....................       i++; 
3AB6:  INCF   x9C,F
....................       j = 0; 
3AB8:  CLRF   x9D
....................       // While there no END of line "\n" place the value in a table to convert it  
....................       while((SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................       { 
3ABA:  CLRF   03
3ABC:  MOVF   x9C,W
3ABE:  ADDLW  23
3AC0:  MOVWF  FE9
3AC2:  MOVLW  00
3AC4:  ADDWFC 03,W
3AC6:  MOVWF  FEA
3AC8:  MOVF   FEF,W
3ACA:  SUBLW  0A
3ACC:  BZ    3B16
3ACE:  CLRF   03
3AD0:  MOVF   x9C,W
3AD2:  ADDLW  23
3AD4:  MOVWF  FE9
3AD6:  MOVLW  00
3AD8:  ADDWFC 03,W
3ADA:  MOVWF  FEA
3ADC:  MOVF   FEF,W
3ADE:  SUBLW  0D
3AE0:  BZ    3B16
....................          Arg[j] = SerialBuffer[ i ]; 
3AE2:  CLRF   03
3AE4:  MOVF   x9D,W
3AE6:  ADDLW  97
3AE8:  MOVWF  01
3AEA:  MOVLW  01
3AEC:  ADDWFC 03,F
3AEE:  MOVFF  03,19F
3AF2:  CLRF   03
3AF4:  MOVF   x9C,W
3AF6:  ADDLW  23
3AF8:  MOVWF  FE9
3AFA:  MOVLW  00
3AFC:  ADDWFC 03,W
3AFE:  MOVWF  FEA
3B00:  MOVFF  FEF,1A0
3B04:  MOVFF  19F,FEA
3B08:  MOVFF  01,FE9
3B0C:  MOVFF  1A0,FEF
....................          i++;      
3B10:  INCF   x9C,F
....................          j++; 
3B12:  INCF   x9D,F
....................       } 
3B14:  BRA    3ABA
....................       Arg[j] ='\0';                                                             // PLace a End of sentence at the end of the values 
3B16:  CLRF   03
3B18:  MOVF   x9D,W
3B1A:  ADDLW  97
3B1C:  MOVWF  FE9
3B1E:  MOVLW  01
3B20:  ADDWFC 03,W
3B22:  MOVWF  FEA
3B24:  CLRF   FEF
....................       TV_Data_send = atoi(Arg);                                                 // Convert the table of value into a unsigned int8 
3B26:  MOVLW  01
3B28:  MOVWF  xA0
3B2A:  MOVLW  97
3B2C:  MOVWF  x9F
3B2E:  MOVLB  0
3B30:  CALL   1A3E
3B34:  MOVFF  01,86
....................       TV_Data_emitting = 1;                                                     // Set the flag to indicate that a mesasge must be send 
3B38:  BSF    x88.1
....................       if(SerialPort == SERIAL_USB) 
3B3A:  MOVF   x74,F
3B3C:  BNZ   3B58
....................         fprintf(USB,"v\r\n"); 
3B3E:  MOVLW  76
3B40:  BTFSS  F9E.4
3B42:  BRA    3B40
3B44:  MOVWF  FAD
3B46:  MOVLW  0D
3B48:  BTFSS  F9E.4
3B4A:  BRA    3B48
3B4C:  MOVWF  FAD
3B4E:  MOVLW  0A
3B50:  BTFSS  F9E.4
3B52:  BRA    3B50
3B54:  MOVWF  FAD
....................       else 
3B56:  BRA    3B74
....................         fprintf(BT,"v\r\n"); 
3B58:  MOVLW  76
3B5A:  BTFSS  FA4.4
3B5C:  BRA    3B5A
3B5E:  MOVLB  F
3B60:  MOVWF  x1C
3B62:  MOVLW  0D
3B64:  BTFSS  FA4.4
3B66:  BRA    3B64
3B68:  MOVWF  x1C
3B6A:  MOVLW  0A
3B6C:  BTFSS  FA4.4
3B6E:  BRA    3B6C
3B70:  MOVWF  x1C
3B72:  MOVLB  0
....................       while(TV_Data_pending == 1);                                              // If a IR data is receiving, wait until it's done 
3B74:  BTFSC  x88.0
3B76:  BRA    3B74
....................       set_timer0(TIMER0_886); 
3B78:  MOVLW  F2
3B7A:  MOVWF  FD7
3B7C:  MOVLW  27
3B7E:  MOVWF  FD6
....................       setup_timer_0(T0_INTERNAL | T0_DIV_1);                                    // Interrupt every 886 us 
3B80:  MOVLW  88
3B82:  MOVWF  FD5
....................       TV_Counter = 0;                                                           // reset TV_Counter  
3B84:  CLRF   x85
....................       TV_Counter_flag = 0;                                                      // reset the sending phase flag 
3B86:  BCF    22.6
....................       disable_interrupts(INT_EXT);                                              // Disable interrupt of the receiving IR, to avoid receiving its own data 
3B88:  BCF    FF2.4
....................       disable_interrupts(INT_TIMER1);                                           // disable the timer1 interrupt to avoid perturbation 
3B8A:  BCF    F9D.0
....................       enable_interrupts(INT_TIMER0);                                            // enable the timer0 interrupt to start the emitting 
3B8C:  BSF    FF2.5
....................    }       
....................        
.................... } 
3B8E:  GOTO   4832 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Write a data on the I2C Bus                                                  -// 
.................... //--------------------------------------------------------------------------------//  
.................... //#separate 
.................... void __W(void) 
.................... { 
3B92:  MOVLB  1
3B94:  CLRF   x97
....................    unsigned char rcvalue = 0; 
....................    rcvalue = chartohex(SerialBuffer[2]); 
3B96:  MOVFF  25,1D1
3B9A:  MOVLB  0
3B9C:  RCALL  352C
3B9E:  MOVFF  01,197
....................    rcvalue = (rcvalue<<4) + chartohex(SerialBuffer[3]); 
3BA2:  MOVLB  1
3BA4:  SWAPF  x97,W
3BA6:  MOVWF  x98
3BA8:  MOVLW  F0
3BAA:  ANDWF  x98,F
3BAC:  MOVFF  26,1D1
3BB0:  MOVLB  0
3BB2:  RCALL  352C
3BB4:  MOVF   01,W
3BB6:  MOVLB  1
3BB8:  ADDWF  x98,W
3BBA:  MOVWF  x97
....................    i2c_start(); 
3BBC:  BSF    FC5.0
3BBE:  BTFSC  FC5.0
3BC0:  BRA    3BBE
....................    i2c_write( rcvalue );                                         // Writing Address of the module 
3BC2:  MOVFF  197,1CE
3BC6:  MOVLB  0
3BC8:  CALL   2C4A
....................    rcvalue = chartohex(SerialBuffer[5]); 
3BCC:  MOVFF  28,1D1
3BD0:  RCALL  352C
3BD2:  MOVFF  01,197
....................    rcvalue = (rcvalue<<4) + chartohex(SerialBuffer[6]); 
3BD6:  MOVLB  1
3BD8:  SWAPF  x97,W
3BDA:  MOVWF  x98
3BDC:  MOVLW  F0
3BDE:  ANDWF  x98,F
3BE0:  MOVFF  29,1D1
3BE4:  MOVLB  0
3BE6:  RCALL  352C
3BE8:  MOVF   01,W
3BEA:  MOVLB  1
3BEC:  ADDWF  x98,W
3BEE:  MOVWF  x97
....................    i2c_write( rcvalue );                                         // Writing Address of the register 
3BF0:  MOVFF  197,1CE
3BF4:  MOVLB  0
3BF6:  CALL   2C4A
....................    rcvalue = chartohex(SerialBuffer[8]); 
3BFA:  MOVFF  2B,1D1
3BFE:  RCALL  352C
3C00:  MOVFF  01,197
....................    rcvalue = (rcvalue<<4) + chartohex(SerialBuffer[9]); 
3C04:  MOVLB  1
3C06:  SWAPF  x97,W
3C08:  MOVWF  x98
3C0A:  MOVLW  F0
3C0C:  ANDWF  x98,F
3C0E:  MOVFF  2C,1D1
3C12:  MOVLB  0
3C14:  RCALL  352C
3C16:  MOVF   01,W
3C18:  MOVLB  1
3C1A:  ADDWF  x98,W
3C1C:  MOVWF  x97
....................    i2c_write( rcvalue );                                         // Writing Data in the register 
3C1E:  MOVFF  197,1CE
3C22:  MOVLB  0
3C24:  CALL   2C4A
....................    i2c_stop(); 
3C28:  BSF    FC5.2
3C2A:  BTFSC  FC5.2
3C2C:  BRA    3C2A
....................    if(SerialPort == SERIAL_USB) 
3C2E:  MOVF   x74,F
3C30:  BNZ   3C4C
....................      fprintf(USB,"w\r\n"); 
3C32:  MOVLW  77
3C34:  BTFSS  F9E.4
3C36:  BRA    3C34
3C38:  MOVWF  FAD
3C3A:  MOVLW  0D
3C3C:  BTFSS  F9E.4
3C3E:  BRA    3C3C
3C40:  MOVWF  FAD
3C42:  MOVLW  0A
3C44:  BTFSS  F9E.4
3C46:  BRA    3C44
3C48:  MOVWF  FAD
....................    else 
3C4A:  BRA    3C66
....................      fprintf(BT,"w\r\n"); 
3C4C:  MOVLW  77
3C4E:  BTFSS  FA4.4
3C50:  BRA    3C4E
3C52:  MOVLB  F
3C54:  MOVWF  x1C
3C56:  MOVLW  0D
3C58:  BTFSS  FA4.4
3C5A:  BRA    3C58
3C5C:  MOVWF  x1C
3C5E:  MOVLW  0A
3C60:  BTFSS  FA4.4
3C62:  BRA    3C60
3C64:  MOVWF  x1C
3C66:  MOVLB  0
....................  
.................... } 
3C68:  GOTO   4832 (RETURN)
....................  
.................... void __X(void) 
.................... { 
....................  if(SerialPort == SERIAL_USB) 
3C6C:  MOVF   x74,F
3C6E:  BTFSS  FD8.2
3C70:  BRA    3F9C
....................  { 
....................     fprintf(USB,"x%c%c%c%c",IR_Proximity[ LEFT ] & 0x00FF, (IR_Proximity[ LEFT ]>>8) & 0x00FF  , IR_Proximity[ FrontLEFT ]  & 0xFF , (IR_Proximity[ FrontLEFT ] >> 8)  & 0xFF); 
3C72:  MOVFF  A9,197
3C76:  MOVLB  1
3C78:  CLRF   x98
3C7A:  MOVFF  AA,199
3C7E:  CLRF   x9A
3C80:  CLRF   x9A
3C82:  MOVFF  AB,19B
3C86:  MOVLB  1
3C88:  CLRF   x9C
3C8A:  MOVFF  AC,19D
3C8E:  CLRF   x9E
3C90:  CLRF   x9E
3C92:  MOVLW  78
3C94:  BTFSS  F9E.4
3C96:  BRA    3C94
3C98:  MOVWF  FAD
3C9A:  MOVF   x97,W
3C9C:  BTFSS  F9E.4
3C9E:  BRA    3C9C
3CA0:  MOVWF  FAD
3CA2:  MOVF   x99,W
3CA4:  BTFSS  F9E.4
3CA6:  BRA    3CA4
3CA8:  MOVWF  FAD
3CAA:  MOVF   x9B,W
3CAC:  BTFSS  F9E.4
3CAE:  BRA    3CAC
3CB0:  MOVWF  FAD
3CB2:  MOVF   x9D,W
3CB4:  BTFSS  F9E.4
3CB6:  BRA    3CB4
3CB8:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Proximity[ FRONT ]  & 0xFF, (IR_Proximity[ FRONT ] >> 8) & 0xFF , IR_Proximity[ FRONTRIGHT] & 0xFF, (IR_Proximity[ FRONTRIGHT] >> 8) & 0xFF ); 
3CBA:  MOVFF  AD,197
3CBE:  MOVLB  1
3CC0:  CLRF   x98
3CC2:  MOVFF  AE,199
3CC6:  CLRF   x9A
3CC8:  CLRF   x9A
3CCA:  MOVFF  AF,19B
3CCE:  MOVLB  1
3CD0:  CLRF   x9C
3CD2:  MOVFF  B0,19D
3CD6:  CLRF   x9E
3CD8:  CLRF   x9E
3CDA:  MOVF   x97,W
3CDC:  BTFSS  F9E.4
3CDE:  BRA    3CDC
3CE0:  MOVWF  FAD
3CE2:  MOVF   x99,W
3CE4:  BTFSS  F9E.4
3CE6:  BRA    3CE4
3CE8:  MOVWF  FAD
3CEA:  MOVF   x9B,W
3CEC:  BTFSS  F9E.4
3CEE:  BRA    3CEC
3CF0:  MOVWF  FAD
3CF2:  MOVF   x9D,W
3CF4:  BTFSS  F9E.4
3CF6:  BRA    3CF4
3CF8:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Proximity[ RIGHT] & 0xFF, (IR_Proximity[ RIGHT] >> 8) & 0xFF , IR_Proximity[ REAR ] & 0xFF ,(IR_Proximity[ REAR ] >> 8) & 0xFF);  
3CFA:  MOVFF  B1,197
3CFE:  MOVLB  1
3D00:  CLRF   x98
3D02:  MOVFF  B2,199
3D06:  CLRF   x9A
3D08:  CLRF   x9A
3D0A:  MOVFF  B3,19B
3D0E:  MOVLB  1
3D10:  CLRF   x9C
3D12:  MOVFF  B4,19D
3D16:  CLRF   x9E
3D18:  CLRF   x9E
3D1A:  MOVF   x97,W
3D1C:  BTFSS  F9E.4
3D1E:  BRA    3D1C
3D20:  MOVWF  FAD
3D22:  MOVF   x99,W
3D24:  BTFSS  F9E.4
3D26:  BRA    3D24
3D28:  MOVWF  FAD
3D2A:  MOVF   x9B,W
3D2C:  BTFSS  F9E.4
3D2E:  BRA    3D2C
3D30:  MOVWF  FAD
3D32:  MOVF   x9D,W
3D34:  BTFSS  F9E.4
3D36:  BRA    3D34
3D38:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Proximity[ GROUNDLEFT ] & 0xFF, (IR_Proximity[ GROUNDLEFT ] >> 8) & 0xFF , IR_Proximity[ GROUNDFRONTLEFT ] & 0xFF, (IR_Proximity[ GROUNDFRONTLEFT ] >> 8) & 0xFF); 
3D3A:  MOVFF  BB,197
3D3E:  MOVLB  1
3D40:  CLRF   x98
3D42:  MOVFF  BC,199
3D46:  CLRF   x9A
3D48:  CLRF   x9A
3D4A:  MOVFF  B7,19B
3D4E:  MOVLB  1
3D50:  CLRF   x9C
3D52:  MOVFF  B8,19D
3D56:  CLRF   x9E
3D58:  CLRF   x9E
3D5A:  MOVF   x97,W
3D5C:  BTFSS  F9E.4
3D5E:  BRA    3D5C
3D60:  MOVWF  FAD
3D62:  MOVF   x99,W
3D64:  BTFSS  F9E.4
3D66:  BRA    3D64
3D68:  MOVWF  FAD
3D6A:  MOVF   x9B,W
3D6C:  BTFSS  F9E.4
3D6E:  BRA    3D6C
3D70:  MOVWF  FAD
3D72:  MOVF   x9D,W
3D74:  BTFSS  F9E.4
3D76:  BRA    3D74
3D78:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Proximity[ GROUNDFRONTRIGHT ] & 0xFF, (IR_Proximity[ GROUNDFRONTRIGHT]>>8) & 0xFF  , IR_Proximity[ GROUNDRIGHT ] & 0xFF, (IR_Proximity[ GROUNDRIGHT ] >> 8) & 0xFF ); 
3D7A:  MOVFF  B9,197
3D7E:  MOVLB  1
3D80:  CLRF   x98
3D82:  MOVFF  BA,199
3D86:  CLRF   x9A
3D88:  CLRF   x9A
3D8A:  MOVFF  BD,19B
3D8E:  MOVLB  1
3D90:  CLRF   x9C
3D92:  MOVFF  BE,19D
3D96:  CLRF   x9E
3D98:  CLRF   x9E
3D9A:  MOVF   x97,W
3D9C:  BTFSS  F9E.4
3D9E:  BRA    3D9C
3DA0:  MOVWF  FAD
3DA2:  MOVF   x99,W
3DA4:  BTFSS  F9E.4
3DA6:  BRA    3DA4
3DA8:  MOVWF  FAD
3DAA:  MOVF   x9B,W
3DAC:  BTFSS  F9E.4
3DAE:  BRA    3DAC
3DB0:  MOVWF  FAD
3DB2:  MOVF   x9D,W
3DB4:  BTFSS  F9E.4
3DB6:  BRA    3DB4
3DB8:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Light[ LEFT ] & 0x00FF, (IR_Light[ LEFT ]>>8) & 0x00FF  , IR_Light[ FrontLEFT ]  & 0xFF , (IR_Light[ FrontLEFT ] >> 8)  & 0xFF); 
3DBA:  MOVFF  91,197
3DBE:  MOVLB  1
3DC0:  CLRF   x98
3DC2:  MOVFF  92,199
3DC6:  CLRF   x9A
3DC8:  CLRF   x9A
3DCA:  MOVFF  93,19B
3DCE:  MOVLB  1
3DD0:  CLRF   x9C
3DD2:  MOVFF  94,19D
3DD6:  CLRF   x9E
3DD8:  CLRF   x9E
3DDA:  MOVF   x97,W
3DDC:  BTFSS  F9E.4
3DDE:  BRA    3DDC
3DE0:  MOVWF  FAD
3DE2:  MOVF   x99,W
3DE4:  BTFSS  F9E.4
3DE6:  BRA    3DE4
3DE8:  MOVWF  FAD
3DEA:  MOVF   x9B,W
3DEC:  BTFSS  F9E.4
3DEE:  BRA    3DEC
3DF0:  MOVWF  FAD
3DF2:  MOVF   x9D,W
3DF4:  BTFSS  F9E.4
3DF6:  BRA    3DF4
3DF8:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Light[ FRONT ]  & 0xFF, (IR_Light[ FRONT ] >> 8) & 0xFF , IR_Light[ FRONTRIGHT] & 0xFF, (IR_Light[ FRONTRIGHT] >> 8) & 0xFF ); 
3DFA:  MOVFF  95,197
3DFE:  MOVLB  1
3E00:  CLRF   x98
3E02:  MOVFF  96,199
3E06:  CLRF   x9A
3E08:  CLRF   x9A
3E0A:  MOVFF  97,19B
3E0E:  MOVLB  1
3E10:  CLRF   x9C
3E12:  MOVFF  98,19D
3E16:  CLRF   x9E
3E18:  CLRF   x9E
3E1A:  MOVF   x97,W
3E1C:  BTFSS  F9E.4
3E1E:  BRA    3E1C
3E20:  MOVWF  FAD
3E22:  MOVF   x99,W
3E24:  BTFSS  F9E.4
3E26:  BRA    3E24
3E28:  MOVWF  FAD
3E2A:  MOVF   x9B,W
3E2C:  BTFSS  F9E.4
3E2E:  BRA    3E2C
3E30:  MOVWF  FAD
3E32:  MOVF   x9D,W
3E34:  BTFSS  F9E.4
3E36:  BRA    3E34
3E38:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Light[ RIGHT] & 0xFF, (IR_Light[ RIGHT] >> 8) & 0xFF , IR_Light[ REAR ] & 0xFF ,(IR_Light[ REAR ] >> 8) & 0xFF);  
3E3A:  MOVFF  99,197
3E3E:  MOVLB  1
3E40:  CLRF   x98
3E42:  MOVFF  9A,199
3E46:  CLRF   x9A
3E48:  CLRF   x9A
3E4A:  MOVFF  9B,19B
3E4E:  MOVLB  1
3E50:  CLRF   x9C
3E52:  MOVFF  9C,19D
3E56:  CLRF   x9E
3E58:  CLRF   x9E
3E5A:  MOVF   x97,W
3E5C:  BTFSS  F9E.4
3E5E:  BRA    3E5C
3E60:  MOVWF  FAD
3E62:  MOVF   x99,W
3E64:  BTFSS  F9E.4
3E66:  BRA    3E64
3E68:  MOVWF  FAD
3E6A:  MOVF   x9B,W
3E6C:  BTFSS  F9E.4
3E6E:  BRA    3E6C
3E70:  MOVWF  FAD
3E72:  MOVF   x9D,W
3E74:  BTFSS  F9E.4
3E76:  BRA    3E74
3E78:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Light[ GROUNDLEFT ] & 0xFF, (IR_Light[ GROUNDLEFT ] >> 8) & 0xFF , IR_Light[ GROUNDFRONTLEFT ] & 0xFF, (IR_Light[ GROUNDFRONTLEFT ] >> 8) & 0xFF); 
3E7A:  MOVFF  A3,197
3E7E:  MOVLB  1
3E80:  CLRF   x98
3E82:  MOVFF  A4,199
3E86:  CLRF   x9A
3E88:  CLRF   x9A
3E8A:  MOVFF  9F,19B
3E8E:  MOVLB  1
3E90:  CLRF   x9C
3E92:  MOVFF  A0,19D
3E96:  CLRF   x9E
3E98:  CLRF   x9E
3E9A:  MOVF   x97,W
3E9C:  BTFSS  F9E.4
3E9E:  BRA    3E9C
3EA0:  MOVWF  FAD
3EA2:  MOVF   x99,W
3EA4:  BTFSS  F9E.4
3EA6:  BRA    3EA4
3EA8:  MOVWF  FAD
3EAA:  MOVF   x9B,W
3EAC:  BTFSS  F9E.4
3EAE:  BRA    3EAC
3EB0:  MOVWF  FAD
3EB2:  MOVF   x9D,W
3EB4:  BTFSS  F9E.4
3EB6:  BRA    3EB4
3EB8:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Light[ GROUNDFRONTRIGHT ] & 0xFF, (IR_Light[ GROUNDFRONTRIGHT]>>8) & 0xFF  , IR_Light[ GROUNDRIGHT ] & 0xFF, (IR_Light[ GROUNDRIGHT ] >> 8) & 0xFF ); 
3EBA:  MOVFF  A1,197
3EBE:  MOVLB  1
3EC0:  CLRF   x98
3EC2:  MOVFF  A2,199
3EC6:  CLRF   x9A
3EC8:  CLRF   x9A
3ECA:  MOVFF  A5,19B
3ECE:  MOVLB  1
3ED0:  CLRF   x9C
3ED2:  MOVFF  A6,19D
3ED6:  CLRF   x9E
3ED8:  CLRF   x9E
3EDA:  MOVF   x97,W
3EDC:  BTFSS  F9E.4
3EDE:  BRA    3EDC
3EE0:  MOVWF  FAD
3EE2:  MOVF   x99,W
3EE4:  BTFSS  F9E.4
3EE6:  BRA    3EE4
3EE8:  MOVWF  FAD
3EEA:  MOVF   x9B,W
3EEC:  BTFSS  F9E.4
3EEE:  BRA    3EEC
3EF0:  MOVWF  FAD
3EF2:  MOVF   x9D,W
3EF4:  BTFSS  F9E.4
3EF6:  BRA    3EF4
3EF8:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c%c%c%c%c%c\r\n",PwmMotLeft, PwmMotRight, Switchs, TV_ADDR, TV_DATA, TimeTip & 0xFF, (TimeTip >> 8) &0xFF, (TimeTip >> 16) & 0xFF, (TimeTip >> 24) &0xFF ); 
3EFA:  MOVFF  8A,197
3EFE:  MOVLB  1
3F00:  CLRF   x98
3F02:  CLRF   x99
3F04:  CLRF   x9A
3F06:  MOVFF  8B,19C
3F0A:  MOVFF  8C,19D
3F0E:  MOVFF  8D,19E
3F12:  CLRF   x9F
3F14:  CLRF   x9D
3F16:  CLRF   x9E
3F18:  CLRF   x9F
3F1A:  MOVFF  8C,1A1
3F1E:  MOVFF  8D,1A2
3F22:  CLRF   xA3
3F24:  CLRF   xA4
3F26:  CLRF   xA2
3F28:  CLRF   xA3
3F2A:  CLRF   xA4
3F2C:  MOVFF  8D,1A6
3F30:  CLRF   xA7
3F32:  CLRF   xA8
3F34:  CLRF   xA9
3F36:  CLRF   xA7
3F38:  CLRF   xA8
3F3A:  CLRF   xA9
3F3C:  MOVF   1A,W
3F3E:  BTFSS  F9E.4
3F40:  BRA    3F3E
3F42:  MOVWF  FAD
3F44:  MOVF   1B,W
3F46:  BTFSS  F9E.4
3F48:  BRA    3F46
3F4A:  MOVWF  FAD
3F4C:  MOVF   x01,W
3F4E:  BTFSS  F9E.4
3F50:  BRA    3F4E
3F52:  MOVWF  FAD
3F54:  MOVLB  0
3F56:  MOVF   x83,W
3F58:  BTFSS  F9E.4
3F5A:  BRA    3F58
3F5C:  MOVWF  FAD
3F5E:  MOVF   x84,W
3F60:  BTFSS  F9E.4
3F62:  BRA    3F60
3F64:  MOVWF  FAD
3F66:  MOVLB  1
3F68:  MOVF   x97,W
3F6A:  BTFSS  F9E.4
3F6C:  BRA    3F6A
3F6E:  MOVWF  FAD
3F70:  MOVF   x9C,W
3F72:  BTFSS  F9E.4
3F74:  BRA    3F72
3F76:  MOVWF  FAD
3F78:  MOVF   xA1,W
3F7A:  BTFSS  F9E.4
3F7C:  BRA    3F7A
3F7E:  MOVWF  FAD
3F80:  MOVF   xA6,W
3F82:  BTFSS  F9E.4
3F84:  BRA    3F82
3F86:  MOVWF  FAD
3F88:  MOVLW  0D
3F8A:  BTFSS  F9E.4
3F8C:  BRA    3F8A
3F8E:  MOVWF  FAD
3F90:  MOVLW  0A
3F92:  BTFSS  F9E.4
3F94:  BRA    3F92
3F96:  MOVWF  FAD
.................... } 
....................  else 
3F98:  BRA    436E
3F9A:  MOVLB  0
....................  { 
....................     fprintf(BT,"x%c%c%c%c",IR_Proximity[ LEFT ] & 0x00FF, (IR_Proximity[ LEFT ]>>8) & 0x00FF  , IR_Proximity[ FrontLEFT ]  & 0xFF , (IR_Proximity[ FrontLEFT ] >> 8)  & 0xFF); 
3F9C:  MOVFF  A9,197
3FA0:  MOVLB  1
3FA2:  CLRF   x98
3FA4:  MOVFF  AA,199
3FA8:  CLRF   x9A
3FAA:  CLRF   x9A
3FAC:  MOVFF  AB,19B
3FB0:  MOVLB  1
3FB2:  CLRF   x9C
3FB4:  MOVFF  AC,19D
3FB8:  CLRF   x9E
3FBA:  CLRF   x9E
3FBC:  MOVLW  78
3FBE:  BTFSS  FA4.4
3FC0:  BRA    3FBE
3FC2:  MOVLB  F
3FC4:  MOVWF  x1C
3FC6:  MOVLB  1
3FC8:  MOVF   x97,W
3FCA:  BTFSS  FA4.4
3FCC:  BRA    3FCA
3FCE:  MOVLB  F
3FD0:  MOVWF  x1C
3FD2:  MOVLB  1
3FD4:  MOVF   x99,W
3FD6:  BTFSS  FA4.4
3FD8:  BRA    3FD6
3FDA:  MOVLB  F
3FDC:  MOVWF  x1C
3FDE:  MOVLB  1
3FE0:  MOVF   x9B,W
3FE2:  BTFSS  FA4.4
3FE4:  BRA    3FE2
3FE6:  MOVLB  F
3FE8:  MOVWF  x1C
3FEA:  MOVLB  1
3FEC:  MOVF   x9D,W
3FEE:  BTFSS  FA4.4
3FF0:  BRA    3FEE
3FF2:  MOVLB  F
3FF4:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Proximity[ FRONT ]  & 0xFF, (IR_Proximity[ FRONT ] >> 8) & 0xFF , IR_Proximity[ FRONTRIGHT] & 0xFF, (IR_Proximity[ FRONTRIGHT] >> 8) & 0xFF ); 
3FF6:  MOVFF  AD,197
3FFA:  MOVLB  1
3FFC:  CLRF   x98
3FFE:  MOVFF  AE,199
4002:  CLRF   x9A
4004:  CLRF   x9A
4006:  MOVFF  AF,19B
400A:  MOVLB  1
400C:  CLRF   x9C
400E:  MOVFF  B0,19D
4012:  CLRF   x9E
4014:  CLRF   x9E
4016:  MOVF   x97,W
4018:  BTFSS  FA4.4
401A:  BRA    4018
401C:  MOVLB  F
401E:  MOVWF  x1C
4020:  MOVLB  1
4022:  MOVF   x99,W
4024:  BTFSS  FA4.4
4026:  BRA    4024
4028:  MOVLB  F
402A:  MOVWF  x1C
402C:  MOVLB  1
402E:  MOVF   x9B,W
4030:  BTFSS  FA4.4
4032:  BRA    4030
4034:  MOVLB  F
4036:  MOVWF  x1C
4038:  MOVLB  1
403A:  MOVF   x9D,W
403C:  BTFSS  FA4.4
403E:  BRA    403C
4040:  MOVLB  F
4042:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Proximity[ RIGHT] & 0xFF, (IR_Proximity[ RIGHT] >> 8) & 0xFF , IR_Proximity[ REAR ] & 0xFF ,(IR_Proximity[ REAR ] >> 8) & 0xFF);  
4044:  MOVFF  B1,197
4048:  MOVLB  1
404A:  CLRF   x98
404C:  MOVFF  B2,199
4050:  CLRF   x9A
4052:  CLRF   x9A
4054:  MOVFF  B3,19B
4058:  MOVLB  1
405A:  CLRF   x9C
405C:  MOVFF  B4,19D
4060:  CLRF   x9E
4062:  CLRF   x9E
4064:  MOVF   x97,W
4066:  BTFSS  FA4.4
4068:  BRA    4066
406A:  MOVLB  F
406C:  MOVWF  x1C
406E:  MOVLB  1
4070:  MOVF   x99,W
4072:  BTFSS  FA4.4
4074:  BRA    4072
4076:  MOVLB  F
4078:  MOVWF  x1C
407A:  MOVLB  1
407C:  MOVF   x9B,W
407E:  BTFSS  FA4.4
4080:  BRA    407E
4082:  MOVLB  F
4084:  MOVWF  x1C
4086:  MOVLB  1
4088:  MOVF   x9D,W
408A:  BTFSS  FA4.4
408C:  BRA    408A
408E:  MOVLB  F
4090:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Proximity[ GROUNDLEFT ] & 0xFF, (IR_Proximity[ GROUNDLEFT ] >> 8) & 0xFF , IR_Proximity[ GROUNDFRONTLEFT ] & 0xFF, (IR_Proximity[ GROUNDFRONTLEFT ] >> 8) & 0xFF); 
4092:  MOVFF  BB,197
4096:  MOVLB  1
4098:  CLRF   x98
409A:  MOVFF  BC,199
409E:  CLRF   x9A
40A0:  CLRF   x9A
40A2:  MOVFF  B7,19B
40A6:  MOVLB  1
40A8:  CLRF   x9C
40AA:  MOVFF  B8,19D
40AE:  CLRF   x9E
40B0:  CLRF   x9E
40B2:  MOVF   x97,W
40B4:  BTFSS  FA4.4
40B6:  BRA    40B4
40B8:  MOVLB  F
40BA:  MOVWF  x1C
40BC:  MOVLB  1
40BE:  MOVF   x99,W
40C0:  BTFSS  FA4.4
40C2:  BRA    40C0
40C4:  MOVLB  F
40C6:  MOVWF  x1C
40C8:  MOVLB  1
40CA:  MOVF   x9B,W
40CC:  BTFSS  FA4.4
40CE:  BRA    40CC
40D0:  MOVLB  F
40D2:  MOVWF  x1C
40D4:  MOVLB  1
40D6:  MOVF   x9D,W
40D8:  BTFSS  FA4.4
40DA:  BRA    40D8
40DC:  MOVLB  F
40DE:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Proximity[ GROUNDFRONTRIGHT ] & 0xFF, (IR_Proximity[ GROUNDFRONTRIGHT]>>8) & 0xFF  , IR_Proximity[ GROUNDRIGHT ] & 0xFF, (IR_Proximity[ GROUNDRIGHT ] >> 8) & 0xFF ); 
40E0:  MOVFF  B9,197
40E4:  MOVLB  1
40E6:  CLRF   x98
40E8:  MOVFF  BA,199
40EC:  CLRF   x9A
40EE:  CLRF   x9A
40F0:  MOVFF  BD,19B
40F4:  MOVLB  1
40F6:  CLRF   x9C
40F8:  MOVFF  BE,19D
40FC:  CLRF   x9E
40FE:  CLRF   x9E
4100:  MOVF   x97,W
4102:  BTFSS  FA4.4
4104:  BRA    4102
4106:  MOVLB  F
4108:  MOVWF  x1C
410A:  MOVLB  1
410C:  MOVF   x99,W
410E:  BTFSS  FA4.4
4110:  BRA    410E
4112:  MOVLB  F
4114:  MOVWF  x1C
4116:  MOVLB  1
4118:  MOVF   x9B,W
411A:  BTFSS  FA4.4
411C:  BRA    411A
411E:  MOVLB  F
4120:  MOVWF  x1C
4122:  MOVLB  1
4124:  MOVF   x9D,W
4126:  BTFSS  FA4.4
4128:  BRA    4126
412A:  MOVLB  F
412C:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Light[ LEFT ] & 0x00FF, (IR_Light[ LEFT ]>>8) & 0x00FF  , IR_Light[ FrontLEFT ]  & 0xFF , (IR_Light[ FrontLEFT ] >> 8)  & 0xFF); 
412E:  MOVFF  91,197
4132:  MOVLB  1
4134:  CLRF   x98
4136:  MOVFF  92,199
413A:  CLRF   x9A
413C:  CLRF   x9A
413E:  MOVFF  93,19B
4142:  MOVLB  1
4144:  CLRF   x9C
4146:  MOVFF  94,19D
414A:  CLRF   x9E
414C:  CLRF   x9E
414E:  MOVF   x97,W
4150:  BTFSS  FA4.4
4152:  BRA    4150
4154:  MOVLB  F
4156:  MOVWF  x1C
4158:  MOVLB  1
415A:  MOVF   x99,W
415C:  BTFSS  FA4.4
415E:  BRA    415C
4160:  MOVLB  F
4162:  MOVWF  x1C
4164:  MOVLB  1
4166:  MOVF   x9B,W
4168:  BTFSS  FA4.4
416A:  BRA    4168
416C:  MOVLB  F
416E:  MOVWF  x1C
4170:  MOVLB  1
4172:  MOVF   x9D,W
4174:  BTFSS  FA4.4
4176:  BRA    4174
4178:  MOVLB  F
417A:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Light[ FRONT ]  & 0xFF, (IR_Light[ FRONT ] >> 8) & 0xFF , IR_Light[ FRONTRIGHT] & 0xFF, (IR_Light[ FRONTRIGHT] >> 8) & 0xFF ); 
417C:  MOVFF  95,197
4180:  MOVLB  1
4182:  CLRF   x98
4184:  MOVFF  96,199
4188:  CLRF   x9A
418A:  CLRF   x9A
418C:  MOVFF  97,19B
4190:  MOVLB  1
4192:  CLRF   x9C
4194:  MOVFF  98,19D
4198:  CLRF   x9E
419A:  CLRF   x9E
419C:  MOVF   x97,W
419E:  BTFSS  FA4.4
41A0:  BRA    419E
41A2:  MOVLB  F
41A4:  MOVWF  x1C
41A6:  MOVLB  1
41A8:  MOVF   x99,W
41AA:  BTFSS  FA4.4
41AC:  BRA    41AA
41AE:  MOVLB  F
41B0:  MOVWF  x1C
41B2:  MOVLB  1
41B4:  MOVF   x9B,W
41B6:  BTFSS  FA4.4
41B8:  BRA    41B6
41BA:  MOVLB  F
41BC:  MOVWF  x1C
41BE:  MOVLB  1
41C0:  MOVF   x9D,W
41C2:  BTFSS  FA4.4
41C4:  BRA    41C2
41C6:  MOVLB  F
41C8:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Light[ RIGHT] & 0xFF, (IR_Light[ RIGHT] >> 8) & 0xFF , IR_Light[ REAR ] & 0xFF ,(IR_Light[ REAR ] >> 8) & 0xFF);  
41CA:  MOVFF  99,197
41CE:  MOVLB  1
41D0:  CLRF   x98
41D2:  MOVFF  9A,199
41D6:  CLRF   x9A
41D8:  CLRF   x9A
41DA:  MOVFF  9B,19B
41DE:  MOVLB  1
41E0:  CLRF   x9C
41E2:  MOVFF  9C,19D
41E6:  CLRF   x9E
41E8:  CLRF   x9E
41EA:  MOVF   x97,W
41EC:  BTFSS  FA4.4
41EE:  BRA    41EC
41F0:  MOVLB  F
41F2:  MOVWF  x1C
41F4:  MOVLB  1
41F6:  MOVF   x99,W
41F8:  BTFSS  FA4.4
41FA:  BRA    41F8
41FC:  MOVLB  F
41FE:  MOVWF  x1C
4200:  MOVLB  1
4202:  MOVF   x9B,W
4204:  BTFSS  FA4.4
4206:  BRA    4204
4208:  MOVLB  F
420A:  MOVWF  x1C
420C:  MOVLB  1
420E:  MOVF   x9D,W
4210:  BTFSS  FA4.4
4212:  BRA    4210
4214:  MOVLB  F
4216:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Light[ GROUNDLEFT ] & 0xFF, (IR_Light[ GROUNDLEFT ] >> 8) & 0xFF , IR_Light[ GROUNDFRONTLEFT ] & 0xFF, (IR_Light[ GROUNDFRONTLEFT ] >> 8) & 0xFF); 
4218:  MOVFF  A3,197
421C:  MOVLB  1
421E:  CLRF   x98
4220:  MOVFF  A4,199
4224:  CLRF   x9A
4226:  CLRF   x9A
4228:  MOVFF  9F,19B
422C:  MOVLB  1
422E:  CLRF   x9C
4230:  MOVFF  A0,19D
4234:  CLRF   x9E
4236:  CLRF   x9E
4238:  MOVF   x97,W
423A:  BTFSS  FA4.4
423C:  BRA    423A
423E:  MOVLB  F
4240:  MOVWF  x1C
4242:  MOVLB  1
4244:  MOVF   x99,W
4246:  BTFSS  FA4.4
4248:  BRA    4246
424A:  MOVLB  F
424C:  MOVWF  x1C
424E:  MOVLB  1
4250:  MOVF   x9B,W
4252:  BTFSS  FA4.4
4254:  BRA    4252
4256:  MOVLB  F
4258:  MOVWF  x1C
425A:  MOVLB  1
425C:  MOVF   x9D,W
425E:  BTFSS  FA4.4
4260:  BRA    425E
4262:  MOVLB  F
4264:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Light[ GROUNDFRONTRIGHT ] & 0xFF, (IR_Light[ GROUNDFRONTRIGHT]>>8) & 0xFF  , IR_Light[ GROUNDRIGHT ] & 0xFF, (IR_Light[ GROUNDRIGHT ] >> 8) & 0xFF ); 
4266:  MOVFF  A1,197
426A:  MOVLB  1
426C:  CLRF   x98
426E:  MOVFF  A2,199
4272:  CLRF   x9A
4274:  CLRF   x9A
4276:  MOVFF  A5,19B
427A:  MOVLB  1
427C:  CLRF   x9C
427E:  MOVFF  A6,19D
4282:  CLRF   x9E
4284:  CLRF   x9E
4286:  MOVF   x97,W
4288:  BTFSS  FA4.4
428A:  BRA    4288
428C:  MOVLB  F
428E:  MOVWF  x1C
4290:  MOVLB  1
4292:  MOVF   x99,W
4294:  BTFSS  FA4.4
4296:  BRA    4294
4298:  MOVLB  F
429A:  MOVWF  x1C
429C:  MOVLB  1
429E:  MOVF   x9B,W
42A0:  BTFSS  FA4.4
42A2:  BRA    42A0
42A4:  MOVLB  F
42A6:  MOVWF  x1C
42A8:  MOVLB  1
42AA:  MOVF   x9D,W
42AC:  BTFSS  FA4.4
42AE:  BRA    42AC
42B0:  MOVLB  F
42B2:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c%c%c%c%c%c\r\n",PwmMotLeft, PwmMotRight, Switchs, TV_ADDR, TV_DATA, TimeTip & 0xFF, (TimeTip >> 8) &0xFF, (TimeTip >> 16) & 0xFF, (TimeTip >> 24) &0xFF ); 
42B4:  MOVFF  8A,197
42B8:  MOVLB  1
42BA:  CLRF   x98
42BC:  CLRF   x99
42BE:  CLRF   x9A
42C0:  MOVFF  8B,19C
42C4:  MOVFF  8C,19D
42C8:  MOVFF  8D,19E
42CC:  CLRF   x9F
42CE:  CLRF   x9D
42D0:  CLRF   x9E
42D2:  CLRF   x9F
42D4:  MOVFF  8C,1A1
42D8:  MOVFF  8D,1A2
42DC:  CLRF   xA3
42DE:  CLRF   xA4
42E0:  CLRF   xA2
42E2:  CLRF   xA3
42E4:  CLRF   xA4
42E6:  MOVFF  8D,1A6
42EA:  CLRF   xA7
42EC:  CLRF   xA8
42EE:  CLRF   xA9
42F0:  CLRF   xA7
42F2:  CLRF   xA8
42F4:  CLRF   xA9
42F6:  MOVF   1A,W
42F8:  BTFSS  FA4.4
42FA:  BRA    42F8
42FC:  MOVLB  F
42FE:  MOVWF  x1C
4300:  MOVF   1B,W
4302:  BTFSS  FA4.4
4304:  BRA    4302
4306:  MOVWF  x1C
4308:  MOVLB  1
430A:  MOVF   x01,W
430C:  BTFSS  FA4.4
430E:  BRA    430C
4310:  MOVLB  F
4312:  MOVWF  x1C
4314:  MOVLB  0
4316:  MOVF   x83,W
4318:  BTFSS  FA4.4
431A:  BRA    4318
431C:  MOVLB  F
431E:  MOVWF  x1C
4320:  MOVLB  0
4322:  MOVF   x84,W
4324:  BTFSS  FA4.4
4326:  BRA    4324
4328:  MOVLB  F
432A:  MOVWF  x1C
432C:  MOVLB  1
432E:  MOVF   x97,W
4330:  BTFSS  FA4.4
4332:  BRA    4330
4334:  MOVLB  F
4336:  MOVWF  x1C
4338:  MOVLB  1
433A:  MOVF   x9C,W
433C:  BTFSS  FA4.4
433E:  BRA    433C
4340:  MOVLB  F
4342:  MOVWF  x1C
4344:  MOVLB  1
4346:  MOVF   xA1,W
4348:  BTFSS  FA4.4
434A:  BRA    4348
434C:  MOVLB  F
434E:  MOVWF  x1C
4350:  MOVLB  1
4352:  MOVF   xA6,W
4354:  BTFSS  FA4.4
4356:  BRA    4354
4358:  MOVLB  F
435A:  MOVWF  x1C
435C:  MOVLW  0D
435E:  BTFSS  FA4.4
4360:  BRA    435E
4362:  MOVWF  x1C
4364:  MOVLW  0A
4366:  BTFSS  FA4.4
4368:  BRA    4366
436A:  MOVWF  x1C
436C:  MOVLB  1
....................   
....................  } 
....................  
.................... } 
436E:  MOVLB  0
4370:  GOTO   4832 (RETURN)
....................  
.................... void __C(void) 
.................... { 
....................   unsigned char BT_name; 
....................  
....................   SerialCounter = 0;   
*
1F56:  CLRF   x73
....................   SerialCommandOK = 0; 
1F58:  BCF    22.4
....................   BT_config = 1;                                                                // Set the flag to receive more than one line 
1F5A:  MOVLW  01
1F5C:  MOVLB  1
1F5E:  MOVWF  x22
....................   delay_ms(500); 
1F60:  MOVLW  02
1F62:  MOVWF  x98
1F64:  MOVLW  FA
1F66:  MOVWF  x99
1F68:  MOVLB  0
1F6A:  CALL   13F2
1F6E:  MOVLB  1
1F70:  DECFSZ x98,F
1F72:  BRA    1F64
....................   fprintf(BT,"+++");                                                                // Deconnect the Bluetooth communication 
1F74:  MOVLW  2B
1F76:  BTFSS  FA4.4
1F78:  BRA    1F76
1F7A:  MOVLB  F
1F7C:  MOVWF  x1C
1F7E:  MOVLW  2B
1F80:  BTFSS  FA4.4
1F82:  BRA    1F80
1F84:  MOVWF  x1C
1F86:  MOVLW  2B
1F88:  BTFSS  FA4.4
1F8A:  BRA    1F88
1F8C:  MOVWF  x1C
....................   delay_ms(800); 
1F8E:  MOVLW  04
1F90:  MOVLB  1
1F92:  MOVWF  x98
1F94:  MOVLW  C8
1F96:  MOVWF  x99
1F98:  MOVLB  0
1F9A:  CALL   13F2
1F9E:  MOVLB  1
1FA0:  DECFSZ x98,F
1FA2:  BRA    1F94
....................   SerialCounter = 0;   
1FA4:  MOVLB  0
1FA6:  CLRF   x73
....................   SerialCommandOK = 0; 
1FA8:  BCF    22.4
....................   fprintf(BT,"SET\n");                                                              // Ask for the different info of the Bluetooth module 
1FAA:  MOVLW  AE
1FAC:  MOVWF  FF6
1FAE:  MOVLW  12
1FB0:  MOVWF  FF7
1FB2:  CALL   1552
....................   delay_ms(1500); 
1FB6:  MOVLW  06
1FB8:  MOVLB  1
1FBA:  MOVWF  x98
1FBC:  MOVLW  FA
1FBE:  MOVWF  x99
1FC0:  MOVLB  0
1FC2:  CALL   13F2
1FC6:  MOVLB  1
1FC8:  DECFSZ x98,F
1FCA:  BRA    1FBC
....................   BT_Name = SerialBuffer[54];                                                   // Save the letter which define the Type of K-Junior 
1FCC:  MOVFF  59,197
....................   SerialCounter = 0;                                                            // Reset the serial buffer 
1FD0:  MOVLB  0
1FD2:  CLRF   x73
....................   fprintf(BT,"SELECT 0\n");                                                         // Re-active the communication 
1FD4:  MOVLW  B4
1FD6:  MOVWF  FF6
1FD8:  MOVLW  12
1FDA:  MOVWF  FF7
1FDC:  CALL   1552
....................   delay_ms(1000);                                                               // Wait until the communication has restart 
1FE0:  MOVLW  04
1FE2:  MOVLB  1
1FE4:  MOVWF  x98
1FE6:  MOVLW  FA
1FE8:  MOVWF  x99
1FEA:  MOVLB  0
1FEC:  CALL   13F2
1FF0:  MOVLB  1
1FF2:  DECFSZ x98,F
1FF4:  BRA    1FE6
....................   BT_config = 0; 
1FF6:  CLRF   x22
....................   if(SerialPort == SERIAL_USB) 
1FF8:  MOVLB  0
1FFA:  MOVF   x74,F
1FFC:  BNZ   202C
....................     fprintf(USB,"c,%c\r\n",BT_name) ;                                           // Send the return command and the type of the K-Junior (0 = Standard, P = Pedagogique) 
1FFE:  MOVLW  63
2000:  BTFSS  F9E.4
2002:  BRA    2000
2004:  MOVWF  FAD
2006:  MOVLW  2C
2008:  BTFSS  F9E.4
200A:  BRA    2008
200C:  MOVWF  FAD
200E:  MOVLB  1
2010:  MOVF   x97,W
2012:  BTFSS  F9E.4
2014:  BRA    2012
2016:  MOVWF  FAD
2018:  MOVLW  0D
201A:  BTFSS  F9E.4
201C:  BRA    201A
201E:  MOVWF  FAD
2020:  MOVLW  0A
2022:  BTFSS  F9E.4
2024:  BRA    2022
2026:  MOVWF  FAD
....................   else 
2028:  BRA    205C
202A:  MOVLB  0
....................     fprintf(BT,"c,%c\r\n",BT_name) ;                                            // Send the return command and the type of the K-Junior (0 = Standard, P = Pedagogique) 
202C:  MOVLW  63
202E:  BTFSS  FA4.4
2030:  BRA    202E
2032:  MOVLB  F
2034:  MOVWF  x1C
2036:  MOVLW  2C
2038:  BTFSS  FA4.4
203A:  BRA    2038
203C:  MOVWF  x1C
203E:  MOVLB  1
2040:  MOVF   x97,W
2042:  BTFSS  FA4.4
2044:  BRA    2042
2046:  MOVLB  F
2048:  MOVWF  x1C
204A:  MOVLW  0D
204C:  BTFSS  FA4.4
204E:  BRA    204C
2050:  MOVWF  x1C
2052:  MOVLW  0A
2054:  BTFSS  FA4.4
2056:  BRA    2054
2058:  MOVWF  x1C
205A:  MOVLB  1
.................... } 
205C:  MOVLB  0
205E:  GOTO   4832 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Write many Data on the I2C Bus                                               -// 
.................... //--------------------------------------------------------------------------------//  
.................... //#separate 
.................... void __Y(void) 
.................... { 
*
4374:  MOVLB  1
4376:  CLRF   x97
4378:  CLRF   x98
437A:  CLRF   xCB
....................    unsigned char Addresse = 0; 
....................    unsigned char registre = 0; 
....................    unsigned char rcvalue[50]; 
....................    unsigned char nb_bytes = 0; 
....................    unsigned char i; 
....................    Addresse = chartohex(SerialBuffer[2]); 
437C:  MOVFF  25,1D1
4380:  MOVLB  0
4382:  CALL   352C
4386:  MOVFF  01,197
....................    Addresse = (Addresse<<4) + chartohex(SerialBuffer[3]); 
438A:  MOVLB  1
438C:  SWAPF  x97,W
438E:  MOVWF  xCD
4390:  MOVLW  F0
4392:  ANDWF  xCD,F
4394:  MOVFF  26,1D1
4398:  MOVLB  0
439A:  CALL   352C
439E:  MOVF   01,W
43A0:  MOVLB  1
43A2:  ADDWF  xCD,W
43A4:  MOVWF  x97
....................  
....................    registre = chartohex(SerialBuffer[5]); 
43A6:  MOVFF  28,1D1
43AA:  MOVLB  0
43AC:  CALL   352C
43B0:  MOVFF  01,198
....................    registre = (registre<<4) + chartohex(SerialBuffer[6]); 
43B4:  MOVLB  1
43B6:  SWAPF  x98,W
43B8:  MOVWF  xCD
43BA:  MOVLW  F0
43BC:  ANDWF  xCD,F
43BE:  MOVFF  29,1D1
43C2:  MOVLB  0
43C4:  CALL   352C
43C8:  MOVF   01,W
43CA:  MOVLB  1
43CC:  ADDWF  xCD,W
43CE:  MOVWF  x98
....................    nb_bytes = chartohex(SerialBuffer[8]); 
43D0:  MOVFF  2B,1D1
43D4:  MOVLB  0
43D6:  CALL   352C
43DA:  MOVFF  01,1CB
....................    nb_bytes = (nb_bytes<<4) + chartohex(SerialBuffer[9]);        // Number of Data to Write 
43DE:  MOVLB  1
43E0:  SWAPF  xCB,W
43E2:  MOVWF  xCD
43E4:  MOVLW  F0
43E6:  ANDWF  xCD,F
43E8:  MOVFF  2C,1D1
43EC:  MOVLB  0
43EE:  CALL   352C
43F2:  MOVF   01,W
43F4:  MOVLB  1
43F6:  ADDWF  xCD,W
43F8:  MOVWF  xCB
....................  
....................    for(i=0;i<nb_bytes;i++) 
43FA:  CLRF   xCC
43FC:  MOVF   xCB,W
43FE:  SUBWF  xCC,W
4400:  BC    44A6
....................    { 
....................       rcvalue[i] = chartohex(SerialBuffer[11+i+i+i]); 
4402:  CLRF   03
4404:  MOVF   xCC,W
4406:  ADDLW  99
4408:  MOVWF  01
440A:  MOVLW  01
440C:  ADDWFC 03,F
440E:  MOVFF  01,1CD
4412:  MOVFF  03,1CE
4416:  MOVLW  0B
4418:  ADDWF  xCC,W
441A:  ADDWF  xCC,W
441C:  ADDWF  xCC,W
441E:  CLRF   03
4420:  ADDLW  23
4422:  MOVWF  FE9
4424:  MOVLW  00
4426:  ADDWFC 03,W
4428:  MOVWF  FEA
442A:  MOVFF  FEF,1CF
442E:  MOVFF  1CF,1D1
4432:  MOVLB  0
4434:  CALL   352C
4438:  MOVFF  1CE,FEA
443C:  MOVFF  1CD,FE9
4440:  MOVFF  01,FEF
....................       rcvalue[i] = (rcvalue[i]<<4) + chartohex(SerialBuffer[12+i+i+i]); 
4444:  CLRF   03
4446:  MOVLB  1
4448:  MOVF   xCC,W
444A:  ADDLW  99
444C:  MOVWF  01
444E:  MOVLW  01
4450:  ADDWFC 03,F
4452:  MOVFF  01,1CD
4456:  MOVFF  03,1CE
445A:  CLRF   03
445C:  MOVF   xCC,W
445E:  ADDLW  99
4460:  MOVWF  FE9
4462:  MOVLW  01
4464:  ADDWFC 03,W
4466:  MOVWF  FEA
4468:  SWAPF  FEF,W
446A:  MOVWF  xCF
446C:  MOVLW  F0
446E:  ANDWF  xCF,F
4470:  MOVLW  0C
4472:  ADDWF  xCC,W
4474:  ADDWF  xCC,W
4476:  ADDWF  xCC,W
4478:  CLRF   03
447A:  ADDLW  23
447C:  MOVWF  FE9
447E:  MOVLW  00
4480:  ADDWFC 03,W
4482:  MOVWF  FEA
4484:  MOVFF  FEF,1D0
4488:  MOVFF  1D0,1D1
448C:  MOVLB  0
448E:  CALL   352C
4492:  MOVF   01,W
4494:  MOVLB  1
4496:  ADDWF  xCF,W
4498:  MOVFF  1CE,FEA
449C:  MOVFF  1CD,FE9
44A0:  MOVWF  FEF
....................       //delay_ms(1);                     // Needed for module ??? 
....................    } 
44A2:  INCF   xCC,F
44A4:  BRA    43FC
....................     
....................    i2c_start(); 
44A6:  BSF    FC5.0
44A8:  BTFSC  FC5.0
44AA:  BRA    44A8
....................    i2c_write( Addresse );                                           // Writing Address of the module 
44AC:  MOVFF  197,1CE
44B0:  MOVLB  0
44B2:  CALL   2C4A
....................    i2c_write( registre );                                           // Writing Address of the register 
44B6:  MOVFF  198,1CE
44BA:  CALL   2C4A
....................    for(i=0;i<nb_bytes;i++) 
44BE:  MOVLB  1
44C0:  CLRF   xCC
44C2:  MOVF   xCB,W
44C4:  SUBWF  xCC,W
44C6:  BC    44EA
....................    { 
....................       i2c_write( rcvalue[i] );                                        // Writing Data in the register 
44C8:  CLRF   03
44CA:  MOVF   xCC,W
44CC:  ADDLW  99
44CE:  MOVWF  FE9
44D0:  MOVLW  01
44D2:  ADDWFC 03,W
44D4:  MOVWF  FEA
44D6:  MOVFF  FEF,1CD
44DA:  MOVFF  1CD,1CE
44DE:  MOVLB  0
44E0:  CALL   2C4A
....................    } 
44E4:  MOVLB  1
44E6:  INCF   xCC,F
44E8:  BRA    44C2
....................  
....................  
....................    i2c_stop(); 
44EA:  BSF    FC5.2
44EC:  BTFSC  FC5.2
44EE:  BRA    44EC
....................    if(SerialPort == SERIAL_USB) 
44F0:  MOVLB  0
44F2:  MOVF   x74,F
44F4:  BNZ   4510
....................      fprintf(USB,"y\r\n"); 
44F6:  MOVLW  79
44F8:  BTFSS  F9E.4
44FA:  BRA    44F8
44FC:  MOVWF  FAD
44FE:  MOVLW  0D
4500:  BTFSS  F9E.4
4502:  BRA    4500
4504:  MOVWF  FAD
4506:  MOVLW  0A
4508:  BTFSS  F9E.4
450A:  BRA    4508
450C:  MOVWF  FAD
....................    else 
450E:  BRA    452A
....................      fprintf(BT,"y\r\n"); 
4510:  MOVLW  79
4512:  BTFSS  FA4.4
4514:  BRA    4512
4516:  MOVLB  F
4518:  MOVWF  x1C
451A:  MOVLW  0D
451C:  BTFSS  FA4.4
451E:  BRA    451C
4520:  MOVWF  x1C
4522:  MOVLW  0A
4524:  BTFSS  FA4.4
4526:  BRA    4524
4528:  MOVWF  x1C
452A:  MOVLB  0
.................... } 
452C:  GOTO   4832 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- This function will be call when a serial command is completely received      -// 
.................... //--------------------------------------------------------------------------------//   
.................... //#separate 
.................... void SerialCommandHandler (void) 
.................... { 
....................  
....................    // If the second char is not a "," or "\r" or "\n" 
....................    if((SerialBuffer[ 1 ] != ',') &&  (SerialBuffer[ 1 ] != 10) && (SerialBuffer[ 1 ] != 13)) 
*
4592:  MOVF   24,W
4594:  SUBLW  2C
4596:  BZ    45AA
4598:  MOVF   24,W
459A:  SUBLW  0A
459C:  BZ    45AA
459E:  MOVF   24,W
45A0:  SUBLW  0D
45A2:  BZ    45AA
....................    { 
....................       SerialCounter = 0;                                                        // Flush the buffer and do nothing 
45A4:  CLRF   x73
....................       SerialCommandOK = 0;                                                      // For the Bluetooth when the connection is not made (communication with USB) 
45A6:  BCF    22.4
....................    } 
....................    else 
45A8:  BRA    4832
....................    { 
....................   
....................       switch( SerialBuffer[ 0 ] ) 
....................       { 
45AA:  MOVF   23,W
45AC:  XORLW  41
45AE:  BZ    4626
45B0:  XORLW  03
45B2:  BZ    462C
45B4:  XORLW  01
45B6:  BZ    4632
45B8:  XORLW  07
45BA:  BZ    4638
45BC:  XORLW  01
45BE:  BZ    463E
45C0:  XORLW  03
45C2:  BZ    4644
45C4:  XORLW  01
45C6:  BTFSC  FD8.2
45C8:  BRA    46C4
45CA:  XORLW  0F
45CC:  BTFSC  FD8.2
45CE:  BRA    4708
45D0:  XORLW  01
45D2:  BTFSC  FD8.2
45D4:  BRA    470E
45D6:  XORLW  02
45D8:  BTFSC  FD8.2
45DA:  BRA    477C
45DC:  XORLW  01
45DE:  BTFSC  FD8.2
45E0:  BRA    4782
45E2:  XORLW  06
45E4:  BTFSC  FD8.2
45E6:  BRA    4788
45E8:  XORLW  02
45EA:  BTFSC  FD8.2
45EC:  BRA    478E
45EE:  XORLW  01
45F0:  BTFSC  FD8.2
45F2:  BRA    4794
45F4:  XORLW  1D
45F6:  BTFSC  FD8.2
45F8:  BRA    479A
45FA:  XORLW  01
45FC:  BTFSC  FD8.2
45FE:  BRA    47A0
4600:  XORLW  07
4602:  BTFSC  FD8.2
4604:  BRA    4810
4606:  XORLW  02
4608:  BTFSC  FD8.2
460A:  BRA    4816
460C:  XORLW  01
460E:  BTFSC  FD8.2
4610:  BRA    481C
4612:  XORLW  0F
4614:  BTFSC  FD8.2
4616:  BRA    4822
4618:  XORLW  01
461A:  BTFSC  FD8.2
461C:  BRA    4828
461E:  XORLW  03
4620:  BTFSC  FD8.2
4622:  BRA    482C
4624:  BRA    4830
....................    //--------------------------------------------------------------------------------// 
....................    //- Turn the K-Junior on the left or the right for n ms                          -// 
....................    //--------------------------------------------------------------------------------//             
....................          case 'A' : 
....................            __A(); 
4626:  GOTO   1BEE
....................            break; 
462A:  BRA    4832
....................    //--------------------------------------------------------------------------------// 
....................    //- Read the KJunior OS version and revision                                     -// 
....................    //--------------------------------------------------------------------------------//             
....................          case 'B' :                                                             // KJOs Version 
....................             __B(); 
462C:  GOTO   1EBE
....................             break; 
4630:  BRA    4832
....................  
....................          case 'C' : 
....................             __C(); 
4632:  GOTO   1F56
....................             break; 
4636:  BRA    4832
....................         
....................    //--------------------------------------------------------------------------------// 
....................    //- Set the speed of the 2 motors. Valure are +/- 20 for each one                -// 
....................    //--------------------------------------------------------------------------------// 
....................          case 'D' :                                                             // Set Motors Speed 
....................             __D(); 
4638:  GOTO   2062
....................             break; 
463C:  BRA    4832
....................    //--------------------------------------------------------------------------------// 
....................    //- Read the Speed of the two motors (-20 to +20)                                -// 
....................    //--------------------------------------------------------------------------------//                
....................          case 'E' :                                                             // Read Motors Speed 
....................             __E(); 
463E:  GOTO   23E4
....................             break; 
4642:  BRA    4832
....................    //--------------------------------------------------------------------------------// 
....................    //- read the Time base in ms                                                     -// 
....................    //--------------------------------------------------------------------------------// 
....................          case 'F' : 
....................            if(SerialPort == SERIAL_USB) 
4644:  MOVF   x74,F
4646:  BNZ   4682
....................             fprintf(USB,"f,%ld\r\n" TimeTip); 
4648:  MOVLW  66
464A:  BTFSS  F9E.4
464C:  BRA    464A
464E:  MOVWF  FAD
4650:  MOVLW  2C
4652:  BTFSS  F9E.4
4654:  BRA    4652
4656:  MOVWF  FAD
4658:  MOVLW  41
465A:  MOVWF  FE9
465C:  MOVFF  8D,1A4
4660:  MOVFF  8C,1A3
4664:  MOVFF  8B,1A2
4668:  MOVFF  8A,1A1
466C:  CALL   2512
4670:  MOVLW  0D
4672:  BTFSS  F9E.4
4674:  BRA    4672
4676:  MOVWF  FAD
4678:  MOVLW  0A
467A:  BTFSS  F9E.4
467C:  BRA    467A
467E:  MOVWF  FAD
....................            else 
4680:  BRA    46C2
....................             fprintf(BT,"f,%ld\r\n" TimeTip); 
4682:  MOVLW  66
4684:  BTFSS  FA4.4
4686:  BRA    4684
4688:  MOVLB  F
468A:  MOVWF  x1C
468C:  MOVLW  2C
468E:  BTFSS  FA4.4
4690:  BRA    468E
4692:  MOVWF  x1C
4694:  MOVLW  41
4696:  MOVWF  FE9
4698:  MOVFF  8D,19A
469C:  MOVFF  8C,199
46A0:  MOVFF  8B,198
46A4:  MOVFF  8A,197
46A8:  MOVLB  0
46AA:  GOTO   2620
46AE:  MOVLW  0D
46B0:  BTFSS  FA4.4
46B2:  BRA    46B0
46B4:  MOVLB  F
46B6:  MOVWF  x1C
46B8:  MOVLW  0A
46BA:  BTFSS  FA4.4
46BC:  BRA    46BA
46BE:  MOVWF  x1C
46C0:  MOVLB  0
....................             break; 
46C2:  BRA    4832
....................    //--------------------------------------------------------------------------------// 
....................    //- reset the Time base                                                          -// 
....................    //--------------------------------------------------------------------------------// 
....................          case 'G' :  
....................             TimeTip = 0; 
46C4:  CLRF   x8D
46C6:  CLRF   x8C
46C8:  CLRF   x8B
46CA:  CLRF   x8A
....................             if(SerialPort == SERIAL_USB) 
46CC:  MOVF   x74,F
46CE:  BNZ   46EA
....................               fprintf(USB,"g\r\n"); 
46D0:  MOVLW  67
46D2:  BTFSS  F9E.4
46D4:  BRA    46D2
46D6:  MOVWF  FAD
46D8:  MOVLW  0D
46DA:  BTFSS  F9E.4
46DC:  BRA    46DA
46DE:  MOVWF  FAD
46E0:  MOVLW  0A
46E2:  BTFSS  F9E.4
46E4:  BRA    46E2
46E6:  MOVWF  FAD
....................             else 
46E8:  BRA    4706
....................               fprintf(BT,"g\r\n"); 
46EA:  MOVLW  67
46EC:  BTFSS  FA4.4
46EE:  BRA    46EC
46F0:  MOVLB  F
46F2:  MOVWF  x1C
46F4:  MOVLW  0D
46F6:  BTFSS  FA4.4
46F8:  BRA    46F6
46FA:  MOVWF  x1C
46FC:  MOVLW  0A
46FE:  BTFSS  FA4.4
4700:  BRA    46FE
4702:  MOVWF  x1C
4704:  MOVLB  0
....................             break; 
4706:  BRA    4832
....................    //--------------------------------------------------------------------------------// 
....................    //- Set the frequency of the buzzer, 0 = Off , 1 = 20Hz, 100 = 2kHz              -// 
....................    //--------------------------------------------------------------------------------//               
....................          case 'H' :  
....................             __H(); 
4708:  GOTO   2816
....................             break; 
470C:  BRA    4832
....................    //--------------------------------------------------------------------------------// 
....................    //- read the value of the mode switch                                            -// 
....................    //--------------------------------------------------------------------------------//                 
....................          case 'I' :  
....................            if(SerialPort == SERIAL_USB) 
470E:  MOVF   x74,F
4710:  BNZ   4744
....................             fprintf(USB, "i,%x\r\n" , Switchs); 
4712:  MOVLW  69
4714:  BTFSS  F9E.4
4716:  BRA    4714
4718:  MOVWF  FAD
471A:  MOVLW  2C
471C:  BTFSS  F9E.4
471E:  BRA    471C
4720:  MOVWF  FAD
4722:  MOVFF  101,19A
4726:  MOVLW  57
4728:  MOVLB  1
472A:  MOVWF  x9B
472C:  MOVLB  0
472E:  CALL   28EA
4732:  MOVLW  0D
4734:  BTFSS  F9E.4
4736:  BRA    4734
4738:  MOVWF  FAD
473A:  MOVLW  0A
473C:  BTFSS  F9E.4
473E:  BRA    473C
4740:  MOVWF  FAD
....................            else 
4742:  BRA    477A
....................             fprintf(BT, "i,%x\r\n" , Switchs); 
4744:  MOVLW  69
4746:  BTFSS  FA4.4
4748:  BRA    4746
474A:  MOVLB  F
474C:  MOVWF  x1C
474E:  MOVLW  2C
4750:  BTFSS  FA4.4
4752:  BRA    4750
4754:  MOVWF  x1C
4756:  MOVFF  101,19A
475A:  MOVLW  57
475C:  MOVLB  1
475E:  MOVWF  x9B
4760:  MOVLB  0
4762:  CALL   2930
4766:  MOVLW  0D
4768:  BTFSS  FA4.4
476A:  BRA    4768
476C:  MOVLB  F
476E:  MOVWF  x1C
4770:  MOVLW  0A
4772:  BTFSS  FA4.4
4774:  BRA    4772
4776:  MOVWF  x1C
4778:  MOVLB  0
....................             break; 
477A:  BRA    4832
....................              
....................    //--------------------------------------------------------------------------------// 
....................    //- Calibrate the IR sensor                                                      -// 
....................    //--------------------------------------------------------------------------------//                 
....................          case 'K' :  
....................             __K(); 
477C:  GOTO   297C
....................             break; 
4780:  BRA    4832
....................  
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Scan the I2C Bus                                                             -// 
.................... //--------------------------------------------------------------------------------//              
....................          case 'J' :                        // Scan I2C Bus 
....................             __J(); 
4782:  GOTO   2C82
....................             break; 
4786:  BRA    4832
....................          //case 'K' : Unused 
....................    //--------------------------------------------------------------------------------// 
....................    //- Set the LED value                                                            -// 
....................    //--------------------------------------------------------------------------------//                 
....................          case 'L' :    
....................             __L(); 
4788:  GOTO   2DC8
....................              break; 
478C:  BRA    4832
....................    //--------------------------------------------------------------------------------// 
....................    //- Return the values of the IR Proximity sensor                                 -// 
....................    //--------------------------------------------------------------------------------//                  
....................          case 'N' :  
....................             __N(); 
478E:  GOTO   30EC
....................             break; 
4792:  BRA    4832
....................    //--------------------------------------------------------------------------------// 
....................    //- Return the values of the IR Ambient light sensor                             -// 
....................    //--------------------------------------------------------------------------------//                   
....................          case 'O' :                       
....................             __O(); 
4794:  GOTO   330C
....................             break; 
4798:  BRA    4832
....................  
....................   
.................... //--------------------------------------------------------------------------------// 
.................... //- Read on the I2C Bus                                                          -// 
.................... //--------------------------------------------------------------------------------//   
....................          case 'R' :                        // Read I2C 
....................             __R(); 
479A:  GOTO   3658
....................             break; 
479E:  BRA    4832
....................              
.................... //--------------------------------------------------------------------------------// 
.................... //- Return the battery voltage                                                   -// 
.................... //--------------------------------------------------------------------------------//   
....................          case 'S' :                        // Read I2C 
....................            if(SerialPort == SERIAL_USB) 
47A0:  MOVF   x74,F
47A2:  BNZ   47D6
....................             fprintf(USB, "s,%4lu\r\n" , BatteryVoltage); 
47A4:  MOVLW  73
47A6:  BTFSS  F9E.4
47A8:  BRA    47A6
47AA:  MOVWF  FAD
47AC:  MOVLW  2C
47AE:  BTFSS  F9E.4
47B0:  BRA    47AE
47B2:  MOVWF  FAD
47B4:  MOVLW  01
47B6:  MOVWF  FE9
47B8:  MOVFF  100,198
47BC:  MOVFF  FF,197
47C0:  GOTO   37D8
47C4:  MOVLW  0D
47C6:  BTFSS  F9E.4
47C8:  BRA    47C6
47CA:  MOVWF  FAD
47CC:  MOVLW  0A
47CE:  BTFSS  F9E.4
47D0:  BRA    47CE
47D2:  MOVWF  FAD
....................            else 
47D4:  BRA    480E
....................             fprintf(BT, "s,%4lu\r\n" , BatteryVoltage); 
47D6:  MOVLW  73
47D8:  BTFSS  FA4.4
47DA:  BRA    47D8
47DC:  MOVLB  F
47DE:  MOVWF  x1C
47E0:  MOVLW  2C
47E2:  BTFSS  FA4.4
47E4:  BRA    47E2
47E6:  MOVWF  x1C
47E8:  MOVLW  01
47EA:  MOVWF  FE9
47EC:  MOVFF  100,198
47F0:  MOVFF  FF,197
47F4:  MOVLB  0
47F6:  GOTO   3884
47FA:  MOVLW  0D
47FC:  BTFSS  FA4.4
47FE:  BRA    47FC
4800:  MOVLB  F
4802:  MOVWF  x1C
4804:  MOVLW  0A
4806:  BTFSS  FA4.4
4808:  BRA    4806
480A:  MOVWF  x1C
480C:  MOVLB  0
....................             break; 
480E:  BRA    4832
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Return the receiving TV data                                                 -// 
.................... //--------------------------------------------------------------------------------//  
....................          case 'T' :                        // Read TV Remote Sensor 
....................             __T(); 
4810:  GOTO   3934
....................             break; 
4814:  BRA    4832
....................  
....................          case 'V' :  
....................             __V(); 
4816:  GOTO   39CE
....................             break; 
481A:  BRA    4832
.................... //--------------------------------------------------------------------------------// 
.................... //- Write a data on the I2C Bus                                                  -// 
.................... //--------------------------------------------------------------------------------//           
....................          case 'W' :                        // Write I2C 
....................             __W(); 
481C:  GOTO   3B92
....................             break; 
4820:  BRA    4832
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Read all K-Junior Data in binary mode                                        -// 
.................... //--------------------------------------------------------------------------------// 
....................          
....................          case 'X' :   // Fast binary read 
....................             __X(); 
4822:  GOTO   3C6C
....................             break; 
4826:  BRA    4832
....................     
....................  
....................  //--------------------------------------------------------------------------------// 
.................... //- Write many Data on the I2C Bus                                               -// 
.................... //--------------------------------------------------------------------------------//          
....................          case 'Y' :                                                            
....................             __Y(); 
4828:  BRA    4374
....................             break; 
482A:  BRA    4832
....................    //--------------------------------------------------------------------------------// 
....................    //- Reset the KJunior uC                                                         -// 
....................    //--------------------------------------------------------------------------------//                  
....................          case 'Z' : 
....................             __Z(); 
482C:  BRA    4530
....................             break; 
482E:  BRA    4832
....................       
....................          default :   // Unknown message command 
....................             __default();   
4830:  BRA    4570
....................             break; 
....................       } 
....................  
....................    } 
....................    SerialCounter = 0; 
4832:  CLRF   x73
....................    SerialCommandOK = 0; 
4834:  BCF    22.4
....................     
....................  
.................... } 
4836:  GOTO   4E12 (RETURN)
....................  
....................  
.................... #INT_RDA  
.................... void USB_Serial_Interrupt(void) 
.................... { 
....................  unsigned char FLUSH; 
....................     
....................    SerialPort = SERIAL_USB; 
*
12BE:  CLRF   x74
....................    while(kbhit(USB))                                                               // Read while data available 
....................    { 
12C0:  BTFSS  F9E.5
12C2:  BRA    132C
....................       if((SerialCommandOK == 1) && (BT_config == 0))                            // If a command is still in traitment (and no config Bluetooth is in process), Flush the buffer 
12C4:  BTFSS  22.4
12C6:  BRA    12E0
12C8:  MOVLB  1
12CA:  MOVF   x22,F
12CC:  BTFSC  FD8.2
12CE:  BRA    12D4
12D0:  MOVLB  0
12D2:  BRA    12E0
....................       { 
....................          FLUSH = getc(USB); 
12D4:  BTFSS  F9E.5
12D6:  BRA    12D4
12D8:  MOVFF  FAE,1D4
....................       } 
....................       else 
12DC:  BRA    1328
12DE:  MOVLB  0
....................       {       
....................          SerialBuffer[ SerialCounter ] = getc(USB); 
12E0:  CLRF   03
12E2:  MOVF   x73,W
12E4:  ADDLW  23
12E6:  MOVWF  FE9
12E8:  MOVLW  00
12EA:  ADDWFC 03,W
12EC:  MOVWF  FEA
12EE:  BTFSS  F9E.5
12F0:  BRA    12EE
12F2:  MOVFF  FAE,FEF
....................          if((SerialBuffer[ SerialCounter ] == 13) || (SerialBuffer[ SerialCounter ] == 10))   // '\n' & '\r' 
12F6:  CLRF   03
12F8:  MOVF   x73,W
12FA:  ADDLW  23
12FC:  MOVWF  FE9
12FE:  MOVLW  00
1300:  ADDWFC 03,W
1302:  MOVWF  FEA
1304:  MOVF   FEF,W
1306:  SUBLW  0D
1308:  BZ    131E
130A:  CLRF   03
130C:  MOVF   x73,W
130E:  ADDLW  23
1310:  MOVWF  FE9
1312:  MOVLW  00
1314:  ADDWFC 03,W
1316:  MOVWF  FEA
1318:  MOVF   FEF,W
131A:  SUBLW  0A
131C:  BNZ   1320
....................          {  
....................             SerialCommandOK = 1;                                                   // Set the Received command Flag 
131E:  BSF    22.4
....................          } 
....................          if (SerialCounter < ( SERIAL_BUFFER_SIZE-1 ))                             // To discard buffer overflow 
1320:  MOVF   x73,W
1322:  SUBLW  4E
1324:  BNC   1328
....................          { 
....................             SerialCounter++; 
1326:  INCF   x73,F
....................          } 
....................       } 
....................    } 
1328:  MOVLB  0
132A:  BRA    12C0
....................        
....................     
.................... } 
....................  
....................  
132C:  BCF    F9E.5
132E:  GOTO   00A8
.................... #INT_RDA2  
.................... void BT_Serial_Interrupt(void) 
.................... { 
....................  unsigned char FLUSH; 
....................    SerialPort = SERIAL_BT; 
1332:  MOVLW  01
1334:  MOVWF  x74
....................    while(kbhit(BT))                                                               // Read while data available 
....................    { 
1336:  BTFSS  FA4.5
1338:  BRA    13A8
....................       if((SerialCommandOK == 1) && (BT_config == 0))                            // If a command is still in traitment (and no config Bluetooth is in process), Flush the buffer 
133A:  BTFSS  22.4
133C:  BRA    1358
133E:  MOVLB  1
1340:  MOVF   x22,F
1342:  BTFSC  FD8.2
1344:  BRA    134A
1346:  MOVLB  0
1348:  BRA    1358
....................       { 
....................          FLUSH = getc(BT); 
134A:  BTFSS  FA4.5
134C:  BRA    134A
134E:  MOVFF  F1D,1D4
1352:  MOVLB  1
....................       } 
....................       else 
1354:  BRA    13A4
1356:  MOVLB  0
....................       {       
....................          SerialBuffer[ SerialCounter ] = getc(BT); 
1358:  CLRF   03
135A:  MOVF   x73,W
135C:  ADDLW  23
135E:  MOVWF  FE9
1360:  MOVLW  00
1362:  ADDWFC 03,W
1364:  MOVWF  FEA
1366:  BTFSS  FA4.5
1368:  BRA    1366
136A:  MOVLB  F
136C:  MOVFF  F1D,FEF
....................          if((SerialBuffer[ SerialCounter ] == 13) || (SerialBuffer[ SerialCounter ] == 10))   // '\n' & '\r' 
1370:  CLRF   03
1372:  MOVLB  0
1374:  MOVF   x73,W
1376:  ADDLW  23
1378:  MOVWF  FE9
137A:  MOVLW  00
137C:  ADDWFC 03,W
137E:  MOVWF  FEA
1380:  MOVF   FEF,W
1382:  SUBLW  0D
1384:  BZ    139A
1386:  CLRF   03
1388:  MOVF   x73,W
138A:  ADDLW  23
138C:  MOVWF  FE9
138E:  MOVLW  00
1390:  ADDWFC 03,W
1392:  MOVWF  FEA
1394:  MOVF   FEF,W
1396:  SUBLW  0A
1398:  BNZ   139C
....................          {  
....................             SerialCommandOK = 1;                                                   // Set the Received command Flag 
139A:  BSF    22.4
....................          } 
....................          if (SerialCounter < ( SERIAL_BUFFER_SIZE-1 ))                             // To discard buffer overflow 
139C:  MOVF   x73,W
139E:  SUBLW  4E
13A0:  BNC   13A4
....................          { 
....................             SerialCounter++; 
13A2:  INCF   x73,F
....................          } 
....................       } 
....................    } 
13A4:  MOVLB  0
13A6:  BRA    1336
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#org 0xFC00, 0xFFFE {}                                                          // Bootloader Protection 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \file KJunior.h 
....................       \brief This file is the library of all high level functions that can be used when programming KJunior 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /** 
....................    * \defgroup Configuration_Functions 
....................    */ 
.................... /*@{*/ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_init(void) 
....................       \brief KJunior Initialisation. This function initialise all KJunior peripherals 
....................       \param None 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
13A8:  BCF    FA4.5
13AA:  GOTO   00A8
.................... void KJunior_init(void); 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_config_auto_refresh_sensors(int1 Bit) 
....................       \brief Set the refresh mode of all IRs sensors 
....................       \param int1 Manual or Refresh (Default) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_config_auto_refresh_sensors(int1 Bit) 
.................... { 
....................      Auto_Refresh_Sensors=Bit; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_config_auto_refresh_tv_remote(int1 Bit) 
....................       \brief Configure the refresh mode of the TV remote receiver 
....................       \param int1 Manual or Refresh(Default) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_config_auto_refresh_tv_remote(int1 Bit) 
.................... { 
....................       Auto_Refresh_TV_Remote=Bit; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_config_rs232_control(int1 Bit) 
....................       \brief Configure the Serial Remote Control 
....................       \param int1 Disable or Enable (Default) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_config_rs232_control(int1 Bit) 
.................... { 
....................       Enable_RS232_Control=Bit; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_config_tv_remote_control(int1 Bit) 
....................       \brief Configure the TV Remote Control 
....................       \param int1 Disable or Enable (Default) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_config_tv_remote_control(int1 Bit) 
.................... { 
....................       Enable_TV_Remote_Control=Bit; 
.................... } 
.................... /*@}*/ 
....................  
.................... /** 
....................    * \defgroup Flags 
....................    */ 
.................... /*@{*/ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_flag_sensors_refreshed(void) 
....................       \brief Test if IRs sensors have been refreshed 
....................       \param None 
....................       \retval int1 1 if sensors have been refreshed 
....................       \warning You must then call KJunior_flag_sensors_reset() to clear the flag 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 KJunior_flag_sensors_refreshed(void) 
.................... { 
....................       return Sensors_Refreshed_Flag; 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_flag_sensors_reset(void) 
....................       \brief Clear IRs sensors refreshed flag 
....................       \param None 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_flag_sensors_reset(void) 
.................... { 
....................       Sensors_Refreshed_Flag = 0; 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_flag_rs232_filtering(void) 
....................       \brief Test if Serial Remote Control is active or not 
....................       \param None 
....................       \retval int1 1 if active otherwise 0 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 KJunior_flag_rs232_filtering(void) 
.................... { 
....................       return Enable_RS232_Control; 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_flag_tv_data_refreshed(void) 
....................       \brief Test if Tv Data have been refreshed 
....................       \param None 
....................       \retval int1 1 if active otherwise 0 
....................       \warning You must then call KJunior_flag_tv_data_reset() to clear the flag 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 KJunior_flag_tv_data_refreshed(void) 
.................... { 
....................       return TV_Data_Available; 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_flag_tv_data_emitting(void) 
....................       \brief Test if Tv Data the data is completely send 
....................       \param None 
....................       \retval int1 1 the data is still emitting otherwise 0 if it's done 
....................       \warning You must then call KJunior_flag_tv_data_reset() to clear the flag 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 KJunior_flag_tv_data_emitting(void) 
.................... { 
....................       return TV_Data_emitting; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_flag_tv_data_reset(void) 
....................       \brief Clear TV Data flag 
....................       \param None 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_flag_tv_data_reset(void) 
.................... { 
....................       TV_Data_Available = 0; 
.................... } 
.................... /*@}*/ 
....................  
.................... /** 
....................    * \defgroup Peripheral_Access_Functions 
....................    */ 
.................... /*@{*/ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn unsigned char KJunior_get_proximity(char Sensor) 
....................       \brief Get proximity value of one IR sensor 
....................       \param char Front, FrontLeft, FrontRight, Left, Right, Rear, GroundLeft, GroundRight 
....................       \retval unsigned_char Proximity Value (0 when nothing) 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... signed int16 KJunior_get_proximity(char Sensor) 
.................... { 
....................       return IR_Proximity[Sensor]; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn unsigned char KJunior_get_brightness(char Sensor) 
....................       \brief Get brightness value of one IR sensor 
....................       \param char Front, FrontLeft, FrontRight, Left, Right, Rear, GroundLeft, GroundRight 
....................       \retval unsigned_char Brightness Value (0 when lot of light) 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... signed int16 KJunior_get_brightness(char Sensor) 
.................... { 
....................       return IR_Light[Sensor]; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_get_switch_state(char Switch_Number) 
....................       \brief Get Switch State 
....................       \retval int8 Value of the 3 switch (0 to 7) 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned char KJunior_get_switch_state() 
.................... { 
....................       return Switchs; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn char KJunior_get_tv_data(void) 
....................       \brief Get latest data from the TV remote receiver 
....................       \param None 
....................       \retval char Byte that have been received 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned char KJunior_get_tv_data(void) 
.................... { 
....................       return TV_DATA; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn char KJunior_get_tv_addr(void) 
....................       \brief Get latest address from the TV remote receiver 
....................       \param None 
....................       \retval char Byte that have been received 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned char KJunior_get_tv_addr(void) 
.................... { 
....................       return TV_ADDR; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn char KJunior_send_tv_value(void) 
....................       \brief Send a value on the IR emitter 
....................       \param addr set the address of the communication 
....................       \param data value of the code to send 
....................       \retval char Byte that have been received 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_send_tv_value(unsigned char addr, unsigned char data) 
.................... { 
....................       TV_Addr_send = addr;                                                      // load the address register 
....................       TV_Data_send = data;                                                      // Set the data register 
....................       TV_Data_emitting = 1;                                                     // Set the flag to indicate that a mesasge must be send 
....................       while(TV_Data_pending == 1);                                              // If a IR data is receiving, wait until it's done 
....................       set_timer0(TIMER0_886); 
....................       setup_timer_0(T0_INTERNAL | T0_DIV_1);                                    // Interrupt every 886 us 
....................       TV_Counter = 0;                                                           // reset TV_Counter 
....................       TV_Counter_flag = 0;                                                      // reset the sending phase flag 
....................       disable_interrupts(INT_EXT);                                              // Disable interrupt of the receiving IR, to avoid receiving its own data 
....................       enable_interrupts(INT_TIMER0);                                            // enable the timer0 interrupt to start the emitting     
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_set_speed(signed int8 Left, signed int8 Right) 
....................       \brief Set speed of each motor 
....................       \param signed_int8 Speed of motor (from -20 to 20, 0 = Stop) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_set_speed(signed int8 LeftSpeed,signed int8 RightSpeed) 
.................... { 
....................       PwmMotLeft = LeftSpeed; 
*
4B7A:  MOVFF  1A2,1A
....................       PwmMotRight = RightSpeed; 
4B7E:  MOVFF  1A3,1B
....................       if(PwmMotLeft >20)                                                        // Limit the minimum and maximum PWM value to -20 and 20 
4B82:  BTFSC  1A.7
4B84:  BRA    4B92
4B86:  MOVF   1A,W
4B88:  SUBLW  14
4B8A:  BC    4B92
....................          PwmMotLeft = 20; 
4B8C:  MOVLW  14
4B8E:  MOVWF  1A
....................       else if(PwmMotLeft < -20)  
4B90:  BRA    4B9E
4B92:  MOVF   1A,W
4B94:  XORLW  80
4B96:  SUBLW  6B
4B98:  BNC   4B9E
....................          PwmMotLeft = -20; 
4B9A:  MOVLW  EC
4B9C:  MOVWF  1A
....................       if(PwmMotRight >20)                                                       // Limit the minimum and maximum PWM value to -20 and 20 
4B9E:  BTFSC  1B.7
4BA0:  BRA    4BAE
4BA2:  MOVF   1B,W
4BA4:  SUBLW  14
4BA6:  BC    4BAE
....................          PwmMotRight = 20; 
4BA8:  MOVLW  14
4BAA:  MOVWF  1B
....................       else if(PwmMotRight < -20)  
4BAC:  BRA    4BBA
4BAE:  MOVF   1B,W
4BB0:  XORLW  80
4BB2:  SUBLW  6B
4BB4:  BNC   4BBA
....................          PwmMotRight = -20;   
4BB6:  MOVLW  EC
4BB8:  MOVWF  1B
4BBA:  CLRF   19
4BBC:  BTFSC  FF2.7
4BBE:  BSF    19.7
4BC0:  BCF    FF2.7
....................           
....................       Motor_Conversion();                                                       // Convert the value to the real PWM and set the PWM output 
4BC2:  CALL   0B7E
4BC6:  BTFSC  19.7
4BC8:  BSF    FF2.7
....................  
.................... } 
4BCA:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_beep(int1 State) 
....................       \brief Set the buzzer State 
....................       \param int8 Freq (0 to 48), 1 = 131Hz (Do 2st Octave & 48 = 1.975kHz (Si 5st Octave) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_beep(unsigned char Freq) 
.................... { 
....................       buzzValue = Freq; 
....................       Set_Freq_note(); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_led_left(int1 State) 
....................       \brief Set the Left Led State 
....................       \param int1 State (0=Off,1=On) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_led_left(int1 State) 
.................... { 
....................       output_bit(LED0, State); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_led_frontleft(int1 State) 
....................       \brief Set the FrontLeft Led State 
....................       \param int1 State (0=Off,1=On) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_led_frontleft(int1 State) 
.................... { 
....................       output_bit(LED1, State); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_led_frontright(int1 State) 
....................       \brief Set the FrontRight Led State 
....................       \param int1 State (0=Off,1=On) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_led_frontright(int1 State) 
.................... { 
....................       output_bit(LED2, State); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_led_right(int1 State) 
....................       \brief Set the Right Led State 
....................       \param int1 State (0=Off,1=On) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_led_right(int1 State) 
.................... { 
....................       output_bit(LED3,State); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_led_onoff(int1 State) 
....................       \brief Set the OnOff Led State 
....................       \param int1 State (0=Off,1=On) 
....................       \retval None 
....................       \warning This Led is controlled in background by the Scheduler 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_led_onoff(int1 State) 
.................... { 
....................       output_bit(LED4,State); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_manual_refresh_sensors(char Zone) 
....................       \brief Manualy refresh a zone 
....................       \param None 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_manual_refresh_sensors() 
.................... { 
....................    Manual_Refresh_sensors = 1; 
....................    Sensors_Refreshed_Flag = 0; 
.................... } 
.................... /*@}*/ 
....................  
.................... /** 
....................    * \defgroup Time_Functions 
....................    */ 
.................... /*@{*/ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_delay_s(int16 Delay) 
....................       \brief This function stop program execution (but not the interrupts) during the defined time in second 
....................       \param Delay 0 to 65535 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void KJunior_delay_s(int16 Delay) 
.................... { 
....................    int i, b; 
....................    for(i = 0; i< Delay; i++) 
....................    { 
....................         b = delay_ms(1000); 
....................    } 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_delay_ms(int16 Delay) 
....................       \brief This function stop program execution (but not the interrupts) during the defined time in millisecond 
....................       \param Delay 0 to 65535 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_delay_ms(int16 Delay) 
.................... { 
....................    delay_ms(Delay); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_delay_us(int16 Delay) 
....................       \brief This function stop program execution (but not the interrupts) during the defined time in microsecond 
....................       \param Delay 0 to 65535 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_delay_us(int16 Delay) 
.................... { 
....................    delay_us(Delay); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn unsigned int32 KJunior_get_time(void) 
....................       \brief This function return a 32 bits value which is increased every ms 
....................       \param None 
....................       \retval unsigned int32 time value 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 KJunior_get_time(void) 
.................... { 
....................    return TimeTip; 
*
483A:  MOVFF  8A,00
483E:  MOVFF  8B,01
4842:  MOVFF  8C,02
4846:  MOVFF  8D,03
.................... } 
484A:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_set_time(unsigned int32 time) 
....................       \brief This function allow user to set the current time value 
....................       \param unsigned int32 time 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_set_time(unsigned int32 Time) 
.................... { 
....................    TimeTip = Time; 
.................... } 
....................  
.................... /*@}*/ 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_ext_read_PINB6(void) 
....................       \brief Read input PORTB.6 
....................       \param None 
....................       \retval int1 input value (0 or 1) 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 KJunior_ext_read_PINB6(void) 
.................... { 
....................    set_tris_b(TRISB|0x40); 
....................    return input(PIN_B6); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_ext_read_PINB7(void) 
....................       \brief Read input PORTB.7 
....................       \param None 
....................       \retval int1 input value (0 or 1) 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 KJunior_ext_read_PINB7(void) 
.................... { 
....................    set_tris_b(TRISB|0x80); 
....................    return input(PIN_B7); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_ext_write_PINB6(int1 Bit) 
....................       \brief Write output PORTB.6 
....................       \param int1 Value to write (0 or 1) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_ext_write_PINB6(int1 Bit) 
.................... { 
....................    set_tris_b(TRISB & 0xBF); 
....................    output_bit(PIN_B6,bit); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_ext_write_PINB7(int1 Bit) 
....................       \brief Write output PORTB.7 
....................       \param int1 Value to write (0 or 1) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_ext_write_PINB7(int1 Bit) 
.................... { 
....................    set_tris_b(TRISB & 0x7F); 
....................    output_bit(PIN_B7,bit); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_get_Battery(void) 
....................       \brief Read the battery voltage 
....................       \param None 
....................       \retval BatteryVoltage 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned int16 KJunior_get_Battery(void) 
.................... { 
....................   return BatteryVoltage; 
.................... } 
.................... /*@}*/ 
....................  
....................  
....................  
....................  
....................  
.................... #include "HemLinCam.h" 
.................... //--------------------------------------------------------------------------------// 
.................... //-                             HemLinCam Lib. 1.6                               -// 
.................... //-                           -// 
.................... //-  Copyright (C) Alexandre Colot, K-Team S.A. 2002                             -// 
.................... //-  This library is free software; you can redistribute it and/or               -// 
.................... //-  modify it under the terms of the GNU Lesser General Public                  -// 
.................... //-  License as published by the Free Software Foundation; either                -// 
.................... //-  version 2.1 of the License, or any later version.                           -// 
.................... //-                          -// 
.................... //-  This library is distributed in the hope that it will be useful,      -// 
.................... //-  but WITHOUT ANY WARRANTY; without even the implied warranty of     -// 
.................... //-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           -// 
.................... //-  Lesser General Public License for more details.                             -// 
.................... //-                                                                              -// 
.................... //-  You should have received a copy of the GNU Lesser General Public            -// 
.................... //-  License along with this library; if not, write to the Free Software         -// 
.................... //-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   -// 
.................... //-                           -// 
.................... //-                           -// 
.................... //-                               __  __  ________                           -// 
.................... //- K-Team S.A.                  |  |/  /|__    __|___  _____  ___  ___          -// 
.................... //- Chemin de Vuasset, CP 111    |     / __ |  | _____|/  _  \|   \/   |         -// 
.................... //- 1028 Preverenges             |  |  \    |  | ____|/  /_\  |        |         -// 
.................... //- Switzerland                  |__|\__\   |__|______|_/   \_|__|\/|__|         -// 
.................... //- alexandre.colot@k-team.com   tel:+41 21 802 5472 fax:+41 21 802 5471         -// 
.................... //-                           -// 
.................... //--------------------------------------------------------------------------------// 
....................  
.................... #define HEMLINCAM_I2C_ADDRESS 0xC0 
....................  
.................... unsigned char HemLinCam_Pixels_Zone1[34]; 
.................... //#locate HemLinCam_Pixels_Zone1=0x0A0 
.................... unsigned char HemLinCam_Pixels_Zone2[34]; 
.................... //#locate HemLinCam_Pixels_Zone2=0x120 
.................... unsigned char HemLinCam_Pixels_Zone3[34]; 
.................... //#locate HemLinCam_Pixels_Zone3=0x1A0 
....................  
.................... void HemLinCam_Init( void ) 
.................... { 
....................   delay_ms(1000); 
*
1A24:  MOVLW  04
1A26:  MOVLB  1
1A28:  MOVWF  x97
1A2A:  MOVLW  FA
1A2C:  MOVWF  x99
1A2E:  MOVLB  0
1A30:  RCALL  13F2
1A32:  MOVLB  1
1A34:  DECFSZ x97,F
1A36:  BRA    1A2A
.................... } 
1A38:  MOVLB  0
1A3A:  GOTO   4DF8 (RETURN)
....................  
.................... char HemLinCam_Read_Version( void ) 
.................... { 
....................       unsigned char value = 0x00; 
....................       i2c_start();                                                // I2C Start Sequence 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
....................       i2c_write(0x00);                                            // Firmware version Register 
....................       i2c_start(); 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS + 1 );                      // HemLinCam I2C Read Address 
....................       value = i2c_read(0); 
....................       i2c_stop();                                                 // I2C Stop Sequence 
....................       return value; 
.................... } 
....................  
.................... //----------------------------------------------------------------// 
.................... //-                Settings Functions                            -// 
....................  
.................... void HemLinCam_Set_Threshold( unsigned char value) 
.................... { 
....................       i2c_start();                                                // I2C Start Sequence 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
....................       i2c_write(0x20);                                            // Threshold Register 
....................       i2c_write(value); 
....................       i2c_stop();                                                 // I2C Stop Sequence 
....................       delay_ms(1); 
.................... } 
....................  
.................... unsigned char HemLinCam_Read_Threshold( void ) 
.................... { 
....................       unsigned char value = 0x00; 
....................       i2c_start();                                                // I2C Start Sequence 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
....................       i2c_write(0x20);                                            // Exposition Time Register 
....................       i2c_start(); 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS + 1 );                      // HemLinCam I2C Read Address 
....................       value = i2c_read(0); 
....................       i2c_stop();                                                 // I2C Stop Sequence 
....................       delay_ms(1); 
....................       return value; 
.................... } 
....................  
.................... void HemLinCam_Set_Exposition_Time( unsigned char value) 
.................... { 
....................       i2c_start();                                                // I2C Start Sequence 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
....................       i2c_write(0x21);                                            // Exposition Time Register 
....................       i2c_write(value); 
....................       i2c_stop();                                                 // I2C Stop Sequence 
....................       delay_ms(1); 
.................... } 
....................  
.................... unsigned char HemLinCam_Read_Exposition_Time( void ) 
.................... { 
....................       unsigned char value = 0x00; 
....................       i2c_start();                                                // I2C Start Sequence 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
....................       i2c_write(0x21);                                            // Exposition Time Register 
....................       i2c_start(); 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS + 1 );                      // HemLinCam I2C Read Address 
....................       value = i2c_read(0); 
....................       i2c_stop();                                                 // I2C Stop Sequence 
....................       delay_ms(1); 
....................       return value; 
.................... } 
....................  
.................... void HemLinCam_Read_Pixels( void ) 
.................... { 
....................       int i; 
....................       delay_ms(HemLinCam_Read_Exposition_Time()); 
....................       i2c_start();                                                // I2C Start Sequence 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
....................       i2c_write(0x10); 
....................       i2c_start(); 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS + 1 );                      // HemLinCam I2C Read Address 
....................       for( i = 0 ; i < 34 ; i++ ) 
....................       { 
....................          HemLinCam_Pixels_Zone1[i] = i2c_read(); 
....................       } 
....................       for( i = 0 ; i < 34 ; i++ ) 
....................       { 
....................          HemLinCam_Pixels_Zone2[i] = i2c_read(); 
....................       } 
....................       for( i = 0 ; i < 33 ; i++ ) 
....................       { 
....................          HemLinCam_Pixels_Zone3[i] = i2c_read(); 
....................       } 
....................       HemLinCam_Pixels_Zone3[33] = i2c_read(0); 
....................       i2c_stop(); 
....................       delay_ms(1); 
.................... } 
....................  
.................... void HemLinCam_Read_Pixels_Thresholded( void ) 
.................... { 
....................       int i; 
....................       delay_ms(HemLinCam_Read_Exposition_Time()); 
....................       i2c_start();                                                // I2C Start Sequence 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
....................       i2c_write(0x11); 
....................       i2c_start(); 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS + 1 );                      // HemLinCam I2C Read Address 
....................       for( i = 0 ; i < 34 ; i++ ) 
....................       { 
....................          HemLinCam_Pixels_Zone1[i] = i2c_read(); 
....................       } 
....................       for( i = 0 ; i < 34 ; i++ ) 
....................       { 
....................          HemLinCam_Pixels_Zone2[i] = i2c_read(); 
....................       } 
....................       for( i = 0 ; i < 33 ; i++ ) 
....................       { 
....................          HemLinCam_Pixels_Zone3[i] = i2c_read(); 
....................       } 
....................       HemLinCam_Pixels_Zone3[33] = i2c_read(0); 
....................       i2c_stop(); 
....................       delay_ms(1); 
.................... } 
....................  
.................... void HemLinCam_Set_Led_State( char value) 
.................... { 
....................       i2c_start();                                                // I2C Start Sequence 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
....................       i2c_write(0x30);                                            // Led Register 
....................       i2c_write(value); 
....................       i2c_stop();                                                 // I2C Stop Sequence 
....................       delay_ms(1); 
.................... } 
....................  
.................... #include "Basic_functions.h" 
.................... #define DIAMETER 100 
.................... #define PI 3.141592653 
.................... #define PERIM (DIAMETER * PI) 
....................  
....................   
.................... #define SECONDS_LOOP_CONTROL 46 
.................... #define MS_LOOP_CONTROL 100 
....................  
.................... void sleep_s(unsigned int32); 
.................... void sleep_ms(unsigned int32); 
.................... void rotate_no_move(unsigned int32 angle, int speed); 
.................... unsigned int get_speed_in_mms(int32 speed); 
....................  
....................  
....................  
.................... #include "Basic_functions.c" 
....................   
....................  
.................... void sleep_s(unsigned int32 seconds) 
.................... { 
....................     unsigned int32 t1 = KJunior_get_time(); 
....................     while( (KJunior_get_time() - t1) < seconds); 
.................... } 
....................  
.................... void rotate_no_move(unsigned int32 angle, int speed) 
.................... { 
*
4BCC:  MOVLB  1
4BCE:  CLRF   xA4
4BD0:  CLRF   xA3
4BD2:  CLRF   xA2
4BD4:  MOVFF  19B,1A1
4BD8:  MOVLB  0
4BDA:  BRA    4916
4BDC:  MOVFF  01,19C
....................    unsigned int speed_ms = get_speed_in_mms(speed); 
....................    fprintf(USB, "speed ms : %ud \r\n", speed_ms); 
4BE0:  MOVLW  AE
4BE2:  MOVWF  FF6
4BE4:  MOVLW  13
4BE6:  MOVWF  FF7
4BE8:  MOVLW  0B
4BEA:  MOVLB  1
4BEC:  MOVWF  xA1
4BEE:  MOVLB  0
4BF0:  CALL   143E
4BF4:  MOVFF  19C,1A1
4BF8:  MOVLW  1B
4BFA:  MOVLB  1
4BFC:  MOVWF  xA2
4BFE:  MOVLB  0
4C00:  CALL   354C
4C04:  MOVLW  BB
4C06:  MOVWF  FF6
4C08:  MOVLW  13
4C0A:  MOVWF  FF7
4C0C:  MOVLW  04
4C0E:  MOVLB  1
4C10:  MOVWF  xA1
4C12:  MOVLB  0
4C14:  CALL   143E
....................    unsigned int32 ms = (unsigned int32) (PERIM / speed_ms)  * 1000; 
4C18:  MOVLB  1
4C1A:  CLRF   xA2
4C1C:  MOVFF  19C,1A1
4C20:  MOVLB  0
4C22:  BRA    499E
4C24:  MOVLW  63
4C26:  MOVLB  1
4C28:  MOVWF  xA4
4C2A:  MOVLW  14
4C2C:  MOVWF  xA3
4C2E:  MOVLW  1D
4C30:  MOVWF  xA2
4C32:  MOVLW  87
4C34:  MOVWF  xA1
4C36:  MOVFF  03,1A8
4C3A:  MOVFF  02,1A7
4C3E:  MOVFF  01,1A6
4C42:  MOVFF  00,1A5
4C46:  MOVLB  0
4C48:  BRA    49D6
4C4A:  MOVFF  03,1A4
4C4E:  MOVFF  02,1A3
4C52:  MOVFF  01,1A2
4C56:  MOVFF  00,1A1
4C5A:  BRA    4B36
4C5C:  MOVFF  03,1A4
4C60:  MOVFF  02,1A3
4C64:  MOVFF  01,1A2
4C68:  MOVFF  00,1A1
4C6C:  MOVFF  03,1A8
4C70:  MOVFF  02,1A7
4C74:  MOVFF  01,1A6
4C78:  MOVFF  00,1A5
4C7C:  MOVLB  1
4C7E:  CLRF   xAC
4C80:  CLRF   xAB
4C82:  MOVLW  03
4C84:  MOVWF  xAA
4C86:  MOVLW  E8
4C88:  MOVWF  xA9
4C8A:  MOVLB  0
4C8C:  RCALL  48BC
4C8E:  MOVFF  03,1A0
4C92:  MOVFF  02,19F
4C96:  MOVFF  01,19E
4C9A:  MOVFF  00,19D
....................    fprintf(USB, "ms : %Ld \r\n", ms); 
4C9E:  MOVLW  C0
4CA0:  MOVWF  FF6
4CA2:  MOVLW  13
4CA4:  MOVWF  FF7
4CA6:  MOVLW  05
4CA8:  MOVLB  1
4CAA:  MOVWF  xA1
4CAC:  MOVLB  0
4CAE:  CALL   143E
4CB2:  MOVLW  41
4CB4:  MOVWF  FE9
4CB6:  MOVFF  1A0,1A4
4CBA:  MOVFF  19F,1A3
4CBE:  MOVFF  19E,1A2
4CC2:  MOVFF  19D,1A1
4CC6:  CALL   2512
4CCA:  MOVLW  20
4CCC:  BTFSS  F9E.4
4CCE:  BRA    4CCC
4CD0:  MOVWF  FAD
4CD2:  MOVLW  0D
4CD4:  BTFSS  F9E.4
4CD6:  BRA    4CD4
4CD8:  MOVWF  FAD
4CDA:  MOVLW  0A
4CDC:  BTFSS  F9E.4
4CDE:  BRA    4CDC
4CE0:  MOVWF  FAD
....................    KJunior_set_speed(speed, -speed); 
4CE2:  MOVLB  1
4CE4:  COMF   x9B,W
4CE6:  MOVWF  xA1
4CE8:  INCF   xA1,F
4CEA:  MOVFF  19B,1A2
4CEE:  MOVFF  1A1,1A3
4CF2:  MOVLB  0
4CF4:  RCALL  4B7A
....................    sleep_ms(ms); 
4CF6:  MOVFF  1A0,1A4
4CFA:  MOVFF  19F,1A3
4CFE:  MOVFF  19E,1A2
4D02:  MOVFF  19D,1A1
4D06:  RCALL  484C
....................    KJunior_set_speed(0, 0); 
4D08:  MOVLB  1
4D0A:  CLRF   xA2
4D0C:  CLRF   xA3
4D0E:  MOVLB  0
4D10:  RCALL  4B7A
....................     
.................... } 
4D12:  GOTO   4EB2 (RETURN)
....................  
.................... unsigned int get_speed_in_mms(int32 speed) 
.................... { 
....................    return (speed * 70 / 20) + 30; 
*
4916:  MOVFF  1A4,1A8
491A:  MOVFF  1A3,1A7
491E:  MOVFF  1A2,1A6
4922:  MOVFF  1A1,1A5
4926:  MOVLB  1
4928:  CLRF   xAC
492A:  CLRF   xAB
492C:  CLRF   xAA
492E:  MOVLW  46
4930:  MOVWF  xA9
4932:  MOVLB  0
4934:  RCALL  48BC
4936:  MOVFF  03,1A8
493A:  MOVFF  02,1A7
493E:  MOVFF  01,1A6
4942:  MOVFF  00,1A5
4946:  BCF    FD8.1
4948:  MOVFF  03,1B0
494C:  MOVFF  02,1AF
4950:  MOVFF  01,1AE
4954:  MOVFF  00,1AD
4958:  MOVLB  1
495A:  CLRF   xB4
495C:  CLRF   xB3
495E:  CLRF   xB2
4960:  MOVLW  14
4962:  MOVWF  xB1
4964:  MOVLB  0
4966:  CALL   247E
496A:  MOVFF  03,1A8
496E:  MOVFF  02,1A7
4972:  MOVFF  01,1A6
4976:  MOVFF  00,1A5
497A:  MOVLW  1E
497C:  MOVLB  1
497E:  ADDWF  00,W
4980:  MOVWF  00
4982:  MOVLW  00
4984:  ADDWFC 01,W
4986:  MOVWF  01
4988:  MOVLW  00
498A:  ADDWFC 02,W
498C:  MOVWF  02
498E:  MOVLW  00
4990:  ADDWFC 03,W
4992:  MOVWF  03
4994:  MOVFF  00,01
.................... } 
4998:  MOVLB  0
499A:  GOTO   4BDC (RETURN)
....................  
.................... void sleep_ms(unsigned int32 ms) 
.................... { 
*
484C:  RCALL  483A
484E:  MOVFF  03,1A8
4852:  MOVFF  02,1A7
4856:  MOVFF  01,1A6
485A:  MOVFF  00,1A5
....................     unsigned int32 t1 = KJunior_get_time(); 
....................     while( (KJunior_get_time() - t1) < ms); 
485E:  RCALL  483A
4860:  MOVFF  03,1AC
4864:  MOVFF  02,1AB
4868:  MOVFF  01,1AA
486C:  MOVFF  00,1A9
4870:  MOVLB  1
4872:  MOVF   xA5,W
4874:  SUBWF  xA9,F
4876:  MOVF   xA6,W
4878:  SUBWFB xAA,F
487A:  MOVF   xA7,W
487C:  SUBWFB xAB,F
487E:  MOVF   xA8,W
4880:  SUBWFB xAC,F
4882:  MOVF   xAC,W
4884:  SUBWF  xA4,W
4886:  BNC   48B8
4888:  BTFSC  FD8.2
488A:  BRA    4890
488C:  MOVLB  0
488E:  BRA    485E
4890:  MOVF   xAB,W
4892:  SUBWF  xA3,W
4894:  BNC   48B8
4896:  BTFSC  FD8.2
4898:  BRA    489E
489A:  MOVLB  0
489C:  BRA    485E
489E:  MOVF   xAA,W
48A0:  SUBWF  xA2,W
48A2:  BNC   48B8
48A4:  BTFSC  FD8.2
48A6:  BRA    48AC
48A8:  MOVLB  0
48AA:  BRA    485E
48AC:  MOVF   xA1,W
48AE:  SUBWF  xA9,W
48B0:  BTFSC  FD8.0
48B2:  BRA    48B8
48B4:  MOVLB  0
48B6:  BRA    485E
.................... } 
48B8:  MOVLB  0
48BA:  RETURN 0
....................  
....................  
....................  
....................  
....................  
.................... #define  MUTE          0 
.................... #define  SOUND_LA     22 
.................... #define  LIMIT       500 
.................... #define  SLEEP_TIME  500 
....................  
.................... //----------------------------------------------------------------------------// 
.................... // Main program   
....................  
....................  
....................  
....................  
....................                        // 
.................... //----------------------------------------------------------------------------// 
.................... #separate 
.................... void main(void) 
.................... { 
*
4D16:  CLRF   FF8
4D18:  BCF    FD0.7
4D1A:  BSF    07.7
4D1C:  CLRF   FEA
4D1E:  CLRF   FE9
4D20:  MOVLW  72
4D22:  MOVWF  FD3
4D24:  CLRF   F9B
4D26:  CLRF   F64
4D28:  BSF    F65.3
4D2A:  MOVLW  44
4D2C:  MOVWF  FAF
4D2E:  MOVLW  00
4D30:  MOVWF  FD4
4D32:  MOVLW  A6
4D34:  MOVWF  FAC
4D36:  MOVLW  90
4D38:  MOVWF  FAB
4D3A:  MOVLB  F
4D3C:  BSF    x20.3
4D3E:  MOVLW  44
4D40:  MOVWF  x1E
4D42:  MOVLW  00
4D44:  MOVWF  x1F
4D46:  MOVLW  A6
4D48:  MOVWF  x21
4D4A:  MOVLW  90
4D4C:  MOVWF  x22
4D4E:  BSF    F94.3
4D50:  BSF    F94.4
4D52:  MOVLW  27
4D54:  MOVWF  FC8
4D56:  MOVLW  29
4D58:  MOVWF  FC6
4D5A:  BSF    FC7.7
4D5C:  BCF    FC7.6
4D5E:  SETF   FC8
4D60:  MOVLW  28
4D62:  MOVWF  FC6
4D64:  CLRF   1A
4D66:  CLRF   1B
4D68:  CLRF   1C
4D6A:  CLRF   1D
4D6C:  CLRF   1E
4D6E:  CLRF   1F
4D70:  CLRF   20
4D72:  CLRF   21
4D74:  BSF    22.0
4D76:  BSF    22.1
4D78:  BSF    22.2
4D7A:  BSF    22.3
4D7C:  BCF    22.4
4D7E:  MOVLB  0
4D80:  CLRF   x73
4D82:  CLRF   x74
4D84:  BCF    22.5
4D86:  CLRF   x83
4D88:  CLRF   x84
4D8A:  CLRF   x85
4D8C:  BCF    22.6
4D8E:  CLRF   x86
4D90:  CLRF   x87
4D92:  BCF    22.7
4D94:  BCF    x88.0
4D96:  BCF    x88.1
4D98:  BCF    x88.2
4D9A:  CLRF   x89
4D9C:  BCF    x88.3
4D9E:  CLRF   x8D
4DA0:  CLRF   x8C
4DA2:  CLRF   x8B
4DA4:  CLRF   x8A
4DA6:  CLRF   x8E
4DA8:  CLRF   x8F
4DAA:  CLRF   x90
4DAC:  CLRF   xF1
4DAE:  CLRF   xF2
4DB0:  BCF    x88.4
4DB2:  MOVLB  1
4DB4:  CLRF   x00
4DB6:  MOVLB  0
4DB8:  CLRF   xFF
4DBA:  MOVLW  10
4DBC:  MOVLB  1
4DBE:  MOVWF  x02
4DC0:  CLRF   x04
4DC2:  CLRF   x03
4DC4:  CLRF   x05
4DC6:  CLRF   x07
4DC8:  CLRF   x06
4DCA:  CLRF   x22
4DCC:  MOVLW  00
4DCE:  MOVLB  F
4DD0:  MOVWF  x23
4DD2:  MOVWF  x24
4DD4:  MOVWF  x25
4DD6:  BCF    FC1.3
4DD8:  BCF    FC1.4
4DDA:  BCF    FC1.5
4DDC:  MOVLB  1
4DDE:  CLRF   x88
4DE0:  MOVLB  F
4DE2:  CLRF   x2E
4DE4:  CLRF   x2F
4DE6:  CLRF   x54
4DE8:  MOVLB  1
4DEA:  CLRF   x23
4DEC:  CLRF   x24
....................   //--- Initialization 
....................   KJunior_init(); 
4DEE:  MOVLB  0
4DF0:  GOTO   1670
....................   HemLinCam_Init(); 
4DF4:  GOTO   1A24
....................   unsigned int32 loopcontrol = 54; 
4DF8:  MOVLB  1
4DFA:  CLRF   x92
4DFC:  CLRF   x91
4DFE:  CLRF   x90
4E00:  MOVLW  36
4E02:  MOVWF  x8F
....................  
....................   //_______________________________ Main loop __________________________________ 
....................   while (1) 
....................   { 
....................     // Test if a Serial Command was received and execute the selected function 
....................     if((SerialCommandOK==1) && (Enable_RS232_Control==1)) SerialCommandHandler(); 
4E04:  BTFSS  22.4
4E06:  BRA    4E12
4E08:  BTFSS  22.2
4E0A:  BRA    4E12
4E0C:  MOVLB  0
4E0E:  GOTO   4592
....................  
....................     //-------------------------------------------------------------------------- 
....................     //      ***  ADD YOUR CODE HERE (replace the following lines)  *** 
....................     //-------------------------------------------------------------------------- 
....................   
....................   
....................    unsigned int32 before = KJunior_get_time(); 
4E12:  MOVLB  0
4E14:  RCALL  483A
4E16:  MOVFF  03,196
4E1A:  MOVFF  02,195
4E1E:  MOVFF  01,194
4E22:  MOVFF  00,193
....................    sleep_ms(4000); 
4E26:  MOVLB  1
4E28:  CLRF   xA4
4E2A:  CLRF   xA3
4E2C:  MOVLW  0F
4E2E:  MOVWF  xA2
4E30:  MOVLW  A0
4E32:  MOVWF  xA1
4E34:  MOVLB  0
4E36:  RCALL  484C
....................    fprintf(USB, "sleep 4s : %Ld \r\n", (int32)KJunior_get_time() - before); 
4E38:  RCALL  483A
4E3A:  MOVFF  03,19A
4E3E:  MOVFF  02,199
4E42:  MOVFF  01,198
4E46:  MOVFF  00,197
4E4A:  MOVLB  1
4E4C:  MOVF   x93,W
4E4E:  SUBWF  x97,F
4E50:  MOVF   x94,W
4E52:  SUBWFB x98,F
4E54:  MOVF   x95,W
4E56:  SUBWFB x99,F
4E58:  MOVF   x96,W
4E5A:  SUBWFB x9A,F
4E5C:  MOVLW  CC
4E5E:  MOVWF  FF6
4E60:  MOVLW  13
4E62:  MOVWF  FF7
4E64:  MOVLW  0B
4E66:  MOVWF  xA1
4E68:  MOVLB  0
4E6A:  CALL   143E
4E6E:  MOVLW  41
4E70:  MOVWF  FE9
4E72:  MOVFF  19A,1A4
4E76:  MOVFF  199,1A3
4E7A:  MOVFF  198,1A2
4E7E:  MOVFF  197,1A1
4E82:  CALL   2512
4E86:  MOVLW  20
4E88:  BTFSS  F9E.4
4E8A:  BRA    4E88
4E8C:  MOVWF  FAD
4E8E:  MOVLW  0D
4E90:  BTFSS  F9E.4
4E92:  BRA    4E90
4E94:  MOVWF  FAD
4E96:  MOVLW  0A
4E98:  BTFSS  F9E.4
4E9A:  BRA    4E98
4E9C:  MOVWF  FAD
....................     
....................    rotate_no_move(10, 5); 
4E9E:  MOVLB  1
4EA0:  CLRF   x9A
4EA2:  CLRF   x99
4EA4:  CLRF   x98
4EA6:  MOVLW  0A
4EA8:  MOVWF  x97
4EAA:  MOVLW  05
4EAC:  MOVWF  x9B
4EAE:  MOVLB  0
4EB0:  BRA    4BCC
....................     
....................    before = KJunior_get_time(); 
4EB2:  RCALL  483A
4EB4:  MOVFF  03,196
4EB8:  MOVFF  02,195
4EBC:  MOVFF  01,194
4EC0:  MOVFF  00,193
....................    sleep_ms(15000); 
4EC4:  MOVLB  1
4EC6:  CLRF   xA4
4EC8:  CLRF   xA3
4ECA:  MOVLW  3A
4ECC:  MOVWF  xA2
4ECE:  MOVLW  98
4ED0:  MOVWF  xA1
4ED2:  MOVLB  0
4ED4:  RCALL  484C
....................    fprintf(USB, "sleep 15s : %Ld  \r\n", (int32)KJunior_get_time() - before); 
4ED6:  RCALL  483A
4ED8:  MOVFF  03,19A
4EDC:  MOVFF  02,199
4EE0:  MOVFF  01,198
4EE4:  MOVFF  00,197
4EE8:  MOVLB  1
4EEA:  MOVF   x93,W
4EEC:  SUBWF  x97,F
4EEE:  MOVF   x94,W
4EF0:  SUBWFB x98,F
4EF2:  MOVF   x95,W
4EF4:  SUBWFB x99,F
4EF6:  MOVF   x96,W
4EF8:  SUBWFB x9A,F
4EFA:  MOVLW  DE
4EFC:  MOVWF  FF6
4EFE:  MOVLW  13
4F00:  MOVWF  FF7
4F02:  MOVLW  0C
4F04:  MOVWF  xA1
4F06:  MOVLB  0
4F08:  CALL   143E
4F0C:  MOVLW  41
4F0E:  MOVWF  FE9
4F10:  MOVFF  19A,1A4
4F14:  MOVFF  199,1A3
4F18:  MOVFF  198,1A2
4F1C:  MOVFF  197,1A1
4F20:  CALL   2512
4F24:  MOVLW  ED
4F26:  MOVWF  FF6
4F28:  MOVLW  13
4F2A:  MOVWF  FF7
4F2C:  MOVLW  04
4F2E:  MOVLB  1
4F30:  MOVWF  xA1
4F32:  MOVLB  0
4F34:  CALL   143E
....................     
....................   }//end while true 
4F38:  MOVLB  1
4F3A:  BRA    4E04
....................    
.................... }//end main  
....................  
4F3C:  SLEEP 

Configuration Fuses:
   Word  1: C915   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC NOPLLEN FCMEN IESO
   Word  2: 7C7E   PUT BROWNOUT BORV18 ZPBORM NOWDT WDT1048576
   Word  3: 8901   RTCOSC_T1 CCP2C1 MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

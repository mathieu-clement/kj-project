CCS PCH C Compiler, Version 4.136, 4828               10-mars-13 16:29

               Filename: D:\Git\kj-project\Main_presentation.lst

               ROM used: 29198 bytes (61%)
                         Largest free fragment is 18334
               RAM used: 408 (11%) at main() level
                         519 (13%) worst case
               Stack:    11 worst case (6 in main + 5 for interrupts)

*
0000:  GOTO   707C
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   12C4
0060:  BTFSS  FA3.5
0062:  GOTO   006C
0066:  BTFSC  FA4.5
0068:  GOTO   133A
006C:  BTFSS  FF2.5
006E:  GOTO   0078
0072:  BTFSC  FF2.2
0074:  GOTO   0E8C
0078:  BTFSS  FF2.4
007A:  GOTO   0084
007E:  BTFSC  FF2.1
0080:  GOTO   0D94
0084:  BTFSS  F9D.0
0086:  GOTO   0090
008A:  BTFSC  F9E.0
008C:  GOTO   0BAA
0090:  BTFSS  FA0.1
0092:  GOTO   009C
0096:  BTFSC  FA1.1
0098:  GOTO   0D66
009C:  BTFSS  F9D.6
009E:  GOTO   00A8
00A2:  BTFSC  F9E.6
00A4:  GOTO   01CA
00A8:  MOVFF  0E,00
00AC:  MOVFF  0F,01
00B0:  MOVFF  10,02
00B4:  MOVFF  11,03
00B8:  MOVFF  0C,FE9
00BC:  MOVFF  07,FEA
00C0:  BSF    07.7
00C2:  MOVFF  08,FE1
00C6:  MOVFF  09,FE2
00CA:  MOVFF  0A,FD9
00CE:  MOVFF  0B,FDA
00D2:  MOVFF  12,FF3
00D6:  MOVFF  13,FF4
00DA:  MOVFF  14,FFA
00DE:  MOVFF  15,FF5
00E2:  MOVFF  16,FF6
00E6:  MOVFF  17,FF7
00EA:  MOVF   04,W
00EC:  MOVFF  06,FE0
00F0:  MOVFF  05,FD8
00F4:  RETFIE 0
.................... /** 
....................  * @file 
....................  *  
....................  * @brief File containing the Main function for the presentation. 
....................  */ 
....................  
.................... // K-Junior 
.................... #include "KJunior.h"  
.................... //--------------------------------------------------------------------------------// 
.................... //-                   KJOs ( K-Junior Operating System )                         -// 
.................... //                                                                               -// 
.................... //-  Copyright (C) Frédéric Lambercy, K-Team S.A. 2008                           -// 
.................... //-  This library is free software; you can redistribute it and/or               -// 
.................... //-  modify it under the terms of the GNU Lesser General Public                  -// 
.................... //-  License as published by the Free Software Foundation; either                -// 
.................... //-  version 2.1 of the License, or any later version.                           -// 
.................... //-                                                                              -// 
.................... //-  This library is distributed in the hope that it will be useful,             -// 
.................... //-  but WITHOUT ANY WARRANTY; without even the implied warranty of              -// 
.................... //-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           -// 
.................... //-  Lesser General Public License for more details.                             -// 
.................... //-                                                                              -// 
.................... //-  You should have received a copy of the GNU Lesser General Public            -// 
.................... //-  License along with this library; if not, write to the Free Software         -// 
.................... //-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   -// 
.................... //-                                                                              -// 
.................... //-                               __  __  ________                               -// 
.................... //- K-Team S.A.                  |  |/  /|__    __|___  _____  ___  ___          -// 
.................... //- Z.I. les Plans-Praz          |     / __ |  | _____|/  _  \|   \/   |         -// 
.................... //- 1337 Vallorbe                |  |  \    |  | ____|/  /_\  |        |         -// 
.................... //- Switzerland                  |__|\__\   |__|______|_/   \_|__|\/|__|         -// 
.................... //- lambercy@k-team.com   tel:+41 24 423 89 73 fax:+41 24 423 8960               -// 
.................... //-                                                                              -// 
.................... //--------------------------------------------------------------------------------// 
....................  
....................  
.................... #include "18f66k22.h" 
.................... //////// Standard Header file for the PIC18F66K22 device //////////////// 
.................... #device PIC18F66K22 
.................... #list 
....................  
.................... #device *=16 ADC=10  
....................  
....................  
.................... #fuses INTRC,NOWDT,NOPROTECT,BROWNOUT,NOWDT,NOCPD,SOSC_DIG                      // Configuration Bits 
.................... #use   delay(clock=16000000)                                                    // Clock @ 16 MHz 
*
13F2:  MOVLW  01
13F4:  MOVWF  FEA
13F6:  MOVLW  96
13F8:  MOVWF  FE9
13FA:  MOVF   FEF,W
13FC:  BZ    141A
13FE:  MOVLW  05
1400:  MOVWF  01
1402:  CLRF   00
1404:  DECFSZ 00,F
1406:  BRA    1404
1408:  DECFSZ 01,F
140A:  BRA    1402
140C:  MOVLW  2E
140E:  MOVWF  00
1410:  DECFSZ 00,F
1412:  BRA    1410
1414:  BRA    1416
1416:  DECFSZ FEF,F
1418:  BRA    13FE
141A:  RETURN 0
.................... #use   rs232(stream=USB, baud=57600,parity=N,bits=8,xmit=PIN_C6,rcv=PIN_C7)     // USB Serial Config. 57600,8,N,1 
.................... #use   rs232(stream=BT, baud=57600,parity=N,bits=8,xmit=PIN_G1,rcv=PIN_G2)      // Bluetooth Serial Config. 57600,8,N,1 
.................... #use   i2c(master,sda=PIN_C4,scl=PIN_C3,FORCE_HW,SLOW)                          // I2C Master Configuration 
*
2DEC:  BCF    FC6.7
2DEE:  BCF    F9E.3
2DF0:  MOVFF  1CB,FC9
2DF4:  MOVLW  02
2DF6:  BTFSC  FC6.7
2DF8:  BRA    2E04
2DFA:  BTFSS  F9E.3
2DFC:  BRA    2DFA
2DFE:  MOVLW  00
2E00:  BTFSC  FC5.6
2E02:  MOVLW  01
2E04:  MOVWF  01
2E06:  RETURN 0
2E08:  BCF    FC6.6
2E0A:  BSF    FC5.3
2E0C:  BTFSC  FC5.3
2E0E:  BRA    2E0C
2E10:  BTFSC  00.0
2E12:  BCF    FC5.5
2E14:  BTFSS  00.0
2E16:  BSF    FC5.5
2E18:  BSF    FC5.4
2E1A:  BTFSC  FC5.4
2E1C:  BRA    2E1A
2E1E:  MOVFF  FC9,01
2E22:  RETURN 0
.................... #use   fast_io(A) 
.................... #use   fast_io(B) 
.................... #use   fast_io(C) 
.................... #use   fast_io(D) 
.................... #use   fast_io(E) 
.................... #use   fast_io(F) 
.................... #use   fast_io(G) 
....................  
....................  
....................  
.................... #include "constants.h" 
.................... //--------------------------------------------------------------------------------// 
.................... //-                   KJOs ( K-Junior Operating System )                         -// 
.................... //                                                                               -// 
.................... //-  Copyright (C) Frédéric Lambercy, K-Team S.A. 2008                           -// 
.................... //-  This library is free software; you can redistribute it and/or               -// 
.................... //-  modify it under the terms of the GNU Lesser General Public                  -// 
.................... //-  License as published by the Free Software Foundation; either                -// 
.................... //-  version 2.1 of the License, or any later version.                           -// 
.................... //-                                                                              -// 
.................... //-  This library is distributed in the hope that it will be useful,             -// 
.................... //-  but WITHOUT ANY WARRANTY; without even the implied warranty of              -// 
.................... //-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           -// 
.................... //-  Lesser General Public License for more details.                             -// 
.................... //-                                                                              -// 
.................... //-  You should have received a copy of the GNU Lesser General Public            -// 
.................... //-  License along with this library; if not, write to the Free Software         -// 
.................... //-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   -// 
.................... //-                                                                              -// 
.................... //-                               __  __  ________                               -// 
.................... //- K-Team S.A.                  |  |/  /|__    __|___  _____  ___  ___          -// 
.................... //- Z.I. les Plans-Praz          |     / __ |  | _____|/  _  \|   \/   |         -// 
.................... //- 1337 Vallorbe                |  |  \    |  | ____|/  /_\  |        |         -// 
.................... //- Switzerland                  |__|\__\   |__|______|_/   \_|__|\/|__|         -// 
.................... //- lambercy@k-team.com   tel:+41 24 423 89 73 fax:+41 24 423 8960               -// 
.................... //-                                                                              -// 
.................... //--------------------------------------------------------------------------------// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \file constants.h 
....................       \brief In this file all constants are defined 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define INIT_TRISA            0x2F   // b0010 1111 
.................... #define INIT_PORTA            0x00   // b0000 0000 
....................  
.................... #define INIT_TRISB            0xC1   // b1100 0001 
.................... #define INIT_PORTB            0x00   // b0000 0000 
....................  
.................... //#define INIT_TRISC            0x87   // b1000 0111 
.................... #define INIT_TRISC            0x9F   // b1001 1111 
.................... #define INIT_PORTC            0x00   // b0000 0000 
....................  
.................... #define INIT_TRISD            0x00   // b0000 0000 
.................... #define INIT_PORTD            0x00   // b0000 0000 
....................  
.................... #define INIT_TRISE            0x00   // b0000 0000 
.................... #define INIT_PORTE            0x00   // b0000 0000 
....................  
.................... #define INIT_TRISF            0xBF   // b1011 1111 
.................... #define INIT_PORTF            0x00   // b0000 0000 
....................  
.................... #define INIT_TRISG            0x04   // b0000 0100 
.................... #define INIT_PORTG            0x00   // b0000 0000 
....................  
....................  
.................... #BIT BOR = 0x8E.0 
.................... #BIT POR = 0x8E.1 
....................  
.................... #define SERIAL_BUFFER_SIZE  80 
.................... #define SERIAL_USB      0 
.................... #define SERIAL_BT       1 
....................  
.................... #define NB_IR                 10 
....................  
.................... #locate ADCON0      =       0x0FC2 
.................... #locate ADCON1      =       0x0FC1 
.................... #locate ADCON2      =       0x0FC0 
.................... #locate OSCCON      =       0x0FD3 
.................... #locate RCON        =       0x0FD0 
.................... #define IPEN        0x80 
....................  
.................... #locate IPR1        =       0x0F9F 
.................... #define RC1IP       0x20 
.................... #locate IPR2        =       0x0FA2 
.................... #locate IPR3        =       0x0FA5 
.................... #define RC2IP       0x20 
.................... #locate IPR4        =       0x0FB8 
.................... #locate IPR5        =       0x0FD2 
.................... #locate IPR6        =       0x0FA9 
....................  
.................... #define LEFT                  0 
.................... #define FRONTLEFT             1 
.................... #define FRONT                 2 
.................... #define FRONTRIGHT            3 
.................... #define RIGHT                 4 
.................... #define REAR                  5 
.................... #define GROUNDLEFT            9 
.................... #define GROUNDFRONTLEFT       7  
.................... #define GROUNDFRONTRIGHT      8 
.................... #define GROUNDRIGHT           10 
....................  
.................... #define VBAT_AN               6 
....................  
.................... #define EEPROM_ADD            10 
....................  
.................... #define IR_GROUP1             PIN_D1 
.................... #define IR_GROUP2             PIN_D2 
.................... #define IR_GROUP3             PIN_D3 
....................  
.................... #define IR_CALIB_TH           20 
....................  
.................... #define LEFT_EMITTER                  PIN_D1 
.................... #define FRONTLEFT_EMITTER             PIN_D2 
.................... #define FRONT_EMITTER                 PIN_D1 
.................... #define FRONTRIGHT_EMITTER            PIN_D3 
.................... #define RIGHT_EMITTER                 PIN_D1 
.................... #define REAR_EMITTER                  PIN_D3 
.................... #define GROUNDLEFT_EMITTER            PIN_D2 
.................... #define GROUNDFRONTLEFT_EMITTER       PIN_D3 
.................... #define GROUNDFRONTRIGHT_EMITTER      PIN_D2 
.................... #define GROUNDRIGHT_EMITTER           PIN_D3 
....................  
....................  
.................... #define ENABLE                1 
.................... #define DISABLE               0 
.................... #define FAST                  1 
.................... #define NORMAL                0 
.................... #define MANUAL                0 
.................... #define REFRESH               1 
.................... #define ON                    1 
.................... #define OFF                   0 
....................  
.................... #define KJ_FW_VERSION   "B" 
.................... #define KJ_FW_REVISION  1                                                       // Please set revision! 
.................... #define KJ_FW_REFERENCE "510.0055" 
....................  
.................... #define RC5_HEADER       0xC0 
.................... #define RC5_TOGGLE       0x20 
.................... #define MANCHESTER_0     0x2 
.................... #define MANCHESTER_1     0x1 
....................  
.................... #define RC5_KJ_ADDR      0x00             // RC5 address of the K-Junior robot ! it's a TV! 
.................... #define RC5_KJ_CMD_GO    0x02 
.................... #define RC5_KJ_CMD_BACK  0x00 
.................... #define RC5_KJ_CMD_LEFT  0x04 
.................... #define RC5_KJ_CMD_RIGHT 0x06 
.................... #define RC5_KJ_CMD_STOP  0x05 
.................... #define RC5_KJ_CMD_Sp    0x10             // Speed+ = Vol + 
.................... #define RC5_KJ_CMD_Sm    0x11             // Speed- = Vol - 
....................  
.................... #define StartBit1        0 
.................... #define StartBit2        1 
.................... #define ToggleBit        2 
.................... #define AddrBit4       3 
.................... #define AddrBit3       4 
.................... #define AddrBit2       5 
.................... #define AddrBit1       6 
.................... #define AddrBit0       7 
.................... #define DataBit5         8 
.................... #define DataBit4         9 
.................... #define DataBit3         10 
.................... #define DataBit2         11 
.................... #define DataBit1         12 
.................... #define DataBit0         13 
....................  
.................... #define MotD1           PIN_E6 
.................... #define MotD2           PIN_E5 
.................... #define MotG1           PIN_E4 
.................... #define MotG2           PIN_E3 
....................  
.................... #define BUZZER          PIN_E2 
....................  
.................... #define IR_IN           PIN_B0 
.................... #define IR_OUT          PIN_D4 
....................  
.................... #define VBAT_M          PIN_F1 
....................  
.................... #define LED0            PIN_B1 
.................... #define LED1            PIN_B2 
.................... #define LED2            PIN_B3 
.................... #define LED3            PIN_B4 
.................... #define LED4            PIN_B5 
....................  
.................... #define MODE1           PIN_C0 
.................... #define MODE2           PIN_C1 
.................... #define MODE3           PIN_C2 
....................  
.................... #define TIMER1_VALUE    64585 
.................... #locate INTCON =        0x0FF2 
.................... #locate PIR1   =        0x0F9E 
....................  
.................... // Timer 0 is used for the rc5 decoding      
.................... #define TIMER0_1780     58415                                                   // = 1.78ms 
.................... #define TIMER0_1140     60975                                                   // = 1.14ms 
.................... #define TIMER0_2100     57135                                                   // = 2.10ms 
.................... #define TIMER0_886      61991                                                   // = 886us 
....................  
.................... // Timer 2 used for the Buzzer, Timer4 For the motors 
.................... #define MOTOR_MAX       200                                                     // Define the frequency of the PWM motor (=20kHz) 
.................... #define MOTOR_MIN       60                                                      // Minimum PWM set on the motor 
.................... #define MOTOR_CONV      7                                                       // value to convert the 0-20 speed value to the PWM 
.................... #define SPEED_MIN       15                                                      // Define the speed where an acceleration is needed 
.................... #define ACCEL           30                                                      // Time of the acceleration in us 
....................  
.................... #locate CCP1CON   =     0x0FBB 
.................... #locate CCP2CON   =     0x0F4E 
.................... #locate CCP3CON   =     0x0F49 
.................... #locate CCPTMRS0  =     0x0F2D 
.................... #locate PSTR1CON  =     0x0F9C     
.................... #locate PSTR2CON  =     0x0F1B 
.................... #locate PSTR3CON  =     0x0F1A 
.................... #locate SSP1CON1  =     0x0FC6 
....................  
.................... // Timer3 value for the note frequency 
.................... #define BUZ_NUMBER      48                                                      // Number of available notes 
.................... #define BUZ_DO          63626                                                   // = 262Hz (if Timer3/4) 
.................... #define BUZ_RE_BEMOL    63729                                                   // = 277Hz (if Timer3/4) 
.................... #define BUZ_RE          63834                                                   // = 294Hz (if Timer3/4) 
.................... #define BUZ_MI_BEMOL    63927                                                   // = 311Hz (if Timer3/4) 
.................... #define BUZ_MI          64019                                                   // = 330Hz (if Timer3/4) 
.................... #define BUZ_FA          64115                                                   // = 349Hz (if Timer3/4) 
.................... #define BUZ_SOL_BEMOL   64183                                                   // = 370Hz (if Timer3/4) 
.................... #define BUZ_SOL         64259                                                   // = 392Hz (if Timer3/4) 
.................... #define BUZ_LA_BEMOL    64330                                                   // = 415Hz (if Timer3/4) 
.................... #define BUZ_LA          64398                                                   // = 440Hz (if Timer3/4) 
.................... #define BUZ_SI_BEMOL    64462                                                   // = 466Hz (if Timer3/4) 
.................... #define BUZ_SI          64522                                                   // = 494Hz (if Timer3/4) 
....................  
....................  
....................  
....................  
.................... #include "variables.c" 
.................... //--------------------------------------------------------------------------------// 
.................... //-                   KJOs ( K-Junior Operating System )                         -// 
.................... //                                                                               -// 
.................... //-  Copyright (C) Frédéric Lambercy, K-Team S.A. 2008                           -// 
.................... //-  This library is free software; you can redistribute it and/or               -// 
.................... //-  modify it under the terms of the GNU Lesser General Public                  -// 
.................... //-  License as published by the Free Software Foundation; either                -// 
.................... //-  version 2.1 of the License, or any later version.                           -// 
.................... //-                                                                              -// 
.................... //-  This library is distributed in the hope that it will be useful,             -// 
.................... //-  but WITHOUT ANY WARRANTY; without even the implied warranty of              -// 
.................... //-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           -// 
.................... //-  Lesser General Public License for more details.                             -// 
.................... //-                                                                              -// 
.................... //-  You should have received a copy of the GNU Lesser General Public            -// 
.................... //-  License along with this library; if not, write to the Free Software         -// 
.................... //-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   -// 
.................... //-                                                                              -// 
.................... //-                               __  __  ________                               -// 
.................... //- K-Team S.A.                  |  |/  /|__    __|___  _____  ___  ___          -// 
.................... //- Z.I. les Plans-Praz          |     / __ |  | _____|/  _  \|   \/   |         -// 
.................... //- 1337 Vallorbe                |  |  \    |  | ____|/  /_\  |        |         -// 
.................... //- Switzerland                  |__|\__\   |__|______|_/   \_|__|\/|__|         -// 
.................... //- lambercy@k-team.com   tel:+41 24 423 89 73 fax:+41 24 423 8960               -// 
.................... //-                                                                              -// 
.................... //--------------------------------------------------------------------------------// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \file variables.c 
....................       \brief Definition of all global functions 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //- Motors 
.................... signed int8 PwmMotLeft = 0;                                                     // 0 : Stop ; 20 : Max Speed 
.................... signed int8 PwmMotRight = 0;                                                    // 0 : Stop ; 20 : Max Speed 
.................... signed int8 Old_PwmMotRight = 0;                                                // Save the speed value to compare with the new one 
.................... signed int8 Old_PwmMotLeft = 0;                                                 // Save the speed value to compare with the new one 
.................... signed int8 TimerMotLeft = 0;                                                   // Value which will be set in the PWM timer register 
.................... signed int8 TimerMotRight = 0;                                                  // Value which will be set in the PWM timer register 
.................... unsigned char Acceleration_Timer = 0; 
.................... unsigned char Acceleration_flag = 0;                                            // flag to indicate if an acceleration is needed 
.................... #define   ACCEL_LEFT      0x01 
.................... #define   ACCEL_RIGHT     0x02 
....................  
....................  
....................  
.................... //- Configuration Bits 
.................... int1 Auto_Refresh_Sensors = 1;                                                  // 1 : Auto   ; 0 : Manual 
.................... int1 Auto_Refresh_TV_Remote = 1;                                                // 1 : Auto   ; 0 : Never 
.................... int1 Enable_RS232_Control = 1;                                                  // 1 : Enable ; 0 : Disable 
.................... int1 Enable_TV_Remote_Control = 1;                                              // 1 : Enable ; 0 : Disable 
....................  
....................  
....................  
.................... //- RS232 
.................... char SerialBuffer[ SERIAL_BUFFER_SIZE ]; 
.................... int1 SerialCommandOK = 0; 
.................... char SerialCounter = 0; 
.................... char SerialPort = 0; 
....................  
.................... //- Flag 
.................... int1 Sensors_Refreshed_Flag = 0; 
....................  
.................... //- TV Remote Control Bit 
.................... int8 TV_table[14]; 
.................... int8 TV_ADDR = 0;                                                               // Address of the received RC5 code 
.................... int8 TV_DATA = 0;                                                               // Data of the received RC5 code 
.................... int8 TV_Counter = 0;                                                            // Counter for the RC5 code 
.................... int1 TV_Counter_flag = 0;                                                       // Flag to know if the emitting is in the first phase (=0) or the second (=1) of the bit to send 
.................... int8 TV_Data_send = 0;                                                          // Value of the rc5 code to send 
.................... int8 TV_Addr_send = 0;                                                          // Address of the rc5 code to send 
.................... int1 TV_Data_Available = 0;                                                     // Flag to indicate that a Data is available 
.................... int1 TV_Data_pending = 0;                                                       // Flag indicate that a data is coming on the IR receiver 
.................... int1 TV_Data_emitting = 0;                                                      // Flag indicate that a data must be send via the IR emitter 
.................... int1 TV_Data_loop = 0;                                                          // Flag to loop when a 1 is following by a zero 
.................... char TV_RX_Toggle_Bit = 0;                                                      // Flag to identify the tag of the message, only a different toggle bit means that the message is different than before 
.................... int1 TV_TX_Toggle_Bit = 0;                                                      // Flag to identify the tag of the message, only a different toggle bit means that the message is different than before 
....................  
....................  
....................  
.................... //- Time 
.................... unsigned int32 TimeTip = 0; 
.................... char TimeTipDivider = 0; 
.................... unsigned char MotorTime = 0; 
.................... unsigned char MotorTimeDivider = 0; 
....................  
.................... //- Irs Sensors 
.................... signed int16 IR_Light[ 12 ]; 
.................... signed int16 IR_Proximity[ 12 ];                                                // 0 : nothing detected ; 4096 : obstacle near KJunior 
.................... signed int16 IR_Calibrate[ 12 ];                                                 // Value of the calibrated sensor 
.................... signed int16 IR_Temp_Proximity[ 12 ];                                           // 0 : nothing detected ; 4096 : obstacle near KJunior 
.................... unsigned char IR_Counter = 0 ;                                                  // counter to manage the refresh of the IR sensor 
.................... unsigned char IR_ADC_Flag = 0;                                                  // Flag to indicate when a sensor is completely refreshed 
.................... unsigned char IR_AN_Table[12];                                                  // Table where the analog pin map of the IR sensor are saved 
.................... int1 Manual_Refresh_sensors = 0;                                                // Flag to refresh manually the sensor 
....................  
.................... //- Battery voltage 
.................... unsigned int16  BatteryVoltage = 0;                                             // Analog value of the battery voltage 
....................  
.................... //- Switchs 
.................... char Switchs; 
....................  
....................  
.................... //- LED state (0 = Normal, 1 = Mode auto activate (chenillard)) 
.................... unsigned char LED_mode = 0x10;                                                  // Start with the LED4 in auto mode 
.................... unsigned int16 LED_counter = 0; 
....................  
.................... //- Buzzer variable 
.................... unsigned char buzzValue   = 0;                                                  // Value of the Buzzer frequency  
.................... unsigned int16 Buzzer_Timer = 0; 
.................... unsigned int16 Buzzer_Table[13]; 
....................  
.................... // Variable for Bluetooth configuration 
.................... unsigned char BT_config = 0; 
....................  
.................... //- TRIS 
.................... #locate TRISB = 0x0F93 
....................  
....................  
....................  
....................  
.................... #include "KJunior.c" 
.................... //--------------------------------------------------------------------------------// 
.................... //-                   KJOs ( K-Junior Operating System )                         -// 
.................... //                                                                               -// 
.................... //-  Copyright (C) Frédéric Lambercy, K-Team S.A. 2008                           -// 
.................... //-  This library is free software; you can redistribute it and/or               -// 
.................... //-  modify it under the terms of the GNU Lesser General Public                  -// 
.................... //-  License as published by the Free Software Foundation; either                -// 
.................... //-  version 2.1 of the License, or any later version.                           -// 
.................... //-                                                                              -// 
.................... //-  This library is distributed in the hope that it will be useful,             -// 
.................... //-  but WITHOUT ANY WARRANTY; without even the implied warranty of              -// 
.................... //-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           -// 
.................... //-  Lesser General Public License for more details.                             -// 
.................... //-                                                                              -// 
.................... //-  You should have received a copy of the GNU Lesser General Public            -// 
.................... //-  License along with this library; if not, write to the Free Software         -// 
.................... //-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   -// 
.................... //-                                                                              -// 
.................... //-                               __  __  ________                               -// 
.................... //- K-Team S.A.                  |  |/  /|__    __|___  _____  ___  ___          -// 
.................... //- Z.I. les Plans-Praz          |     / __ |  | _____|/  _  \|   \/   |         -// 
.................... //- 1337 Vallorbe                |  |  \    |  | ____|/  /_\  |        |         -// 
.................... //- Switzerland                  |__|\__\   |__|______|_/   \_|__|\/|__|         -// 
.................... //- lambercy@k-team.com   tel:+41 24 423 89 73 fax:+41 24 423 8960               -// 
.................... //-                                                                              -// 
.................... //--------------------------------------------------------------------------------// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \file KJunior.c 
....................       \brief The Os functions, all functions are called through an interrupt 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
1BDC:  MOVLB  1
1BDE:  CLRF   xA1
....................    sign = 0; 
1BE0:  CLRF   x9F
....................    base = 10; 
1BE2:  MOVLW  0A
1BE4:  MOVWF  xA0
....................    result = 0; 
1BE6:  CLRF   x9E
....................  
....................    if (!s) 
1BE8:  MOVF   x9C,W
1BEA:  IORWF  x9D,W
1BEC:  BNZ   1BF4
....................       return 0; 
1BEE:  MOVLW  00
1BF0:  MOVWF  01
1BF2:  BRA    1D8A
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
1BF4:  MOVF   xA1,W
1BF6:  INCF   xA1,F
1BF8:  CLRF   03
1BFA:  ADDWF  x9C,W
1BFC:  MOVWF  FE9
1BFE:  MOVF   x9D,W
1C00:  ADDWFC 03,W
1C02:  MOVWF  FEA
1C04:  MOVFF  FEF,1A2
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
1C08:  MOVF   xA2,W
1C0A:  SUBLW  2D
1C0C:  BNZ   1C28
....................    { 
....................       sign = 1;         // Set the sign to negative 
1C0E:  MOVLW  01
1C10:  MOVWF  x9F
....................       c = s[index++]; 
1C12:  MOVF   xA1,W
1C14:  INCF   xA1,F
1C16:  CLRF   03
1C18:  ADDWF  x9C,W
1C1A:  MOVWF  FE9
1C1C:  MOVF   x9D,W
1C1E:  ADDWFC 03,W
1C20:  MOVWF  FEA
1C22:  MOVFF  FEF,1A2
....................    } 
....................    else if (c == '+') 
1C26:  BRA    1C42
1C28:  MOVF   xA2,W
1C2A:  SUBLW  2B
1C2C:  BNZ   1C42
....................    { 
....................       c = s[index++]; 
1C2E:  MOVF   xA1,W
1C30:  INCF   xA1,F
1C32:  CLRF   03
1C34:  ADDWF  x9C,W
1C36:  MOVWF  FE9
1C38:  MOVF   x9D,W
1C3A:  ADDWFC 03,W
1C3C:  MOVWF  FEA
1C3E:  MOVFF  FEF,1A2
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1C42:  MOVF   xA2,W
1C44:  SUBLW  2F
1C46:  BTFSC  FD8.0
1C48:  BRA    1D7A
1C4A:  MOVF   xA2,W
1C4C:  SUBLW  39
1C4E:  BTFSS  FD8.0
1C50:  BRA    1D7A
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1C52:  MOVF   xA2,W
1C54:  SUBLW  30
1C56:  BNZ   1C9A
1C58:  CLRF   03
1C5A:  MOVF   xA1,W
1C5C:  ADDWF  x9C,W
1C5E:  MOVWF  FE9
1C60:  MOVF   x9D,W
1C62:  ADDWFC 03,W
1C64:  MOVWF  FEA
1C66:  MOVF   FEF,W
1C68:  SUBLW  78
1C6A:  BZ    1C80
1C6C:  CLRF   03
1C6E:  MOVF   xA1,W
1C70:  ADDWF  x9C,W
1C72:  MOVWF  FE9
1C74:  MOVF   x9D,W
1C76:  ADDWFC 03,W
1C78:  MOVWF  FEA
1C7A:  MOVF   FEF,W
1C7C:  SUBLW  58
1C7E:  BNZ   1C9A
....................       { 
....................          base = 16; 
1C80:  MOVLW  10
1C82:  MOVWF  xA0
....................          index++; 
1C84:  INCF   xA1,F
....................          c = s[index++]; 
1C86:  MOVF   xA1,W
1C88:  INCF   xA1,F
1C8A:  CLRF   03
1C8C:  ADDWF  x9C,W
1C8E:  MOVWF  FE9
1C90:  MOVF   x9D,W
1C92:  ADDWFC 03,W
1C94:  MOVWF  FEA
1C96:  MOVFF  FEF,1A2
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1C9A:  MOVF   xA0,W
1C9C:  SUBLW  0A
1C9E:  BNZ   1CEA
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
1CA0:  MOVF   xA2,W
1CA2:  SUBLW  2F
1CA4:  BC    1CE8
1CA6:  MOVF   xA2,W
1CA8:  SUBLW  39
1CAA:  BNC   1CE8
1CAC:  CLRF   19
1CAE:  BTFSC  FF2.7
1CB0:  BSF    19.7
1CB2:  BCF    FF2.7
....................             result = 10*result + (c - '0'); 
1CB4:  MOVLW  0A
1CB6:  MOVLB  2
1CB8:  MOVWF  x03
1CBA:  MOVFF  19E,204
1CBE:  MOVLB  0
1CC0:  CALL   09E8
1CC4:  BTFSC  19.7
1CC6:  BSF    FF2.7
1CC8:  MOVLW  30
1CCA:  MOVLB  1
1CCC:  SUBWF  xA2,W
1CCE:  ADDWF  01,W
1CD0:  MOVWF  x9E
....................             c = s[index++]; 
1CD2:  MOVF   xA1,W
1CD4:  INCF   xA1,F
1CD6:  CLRF   03
1CD8:  ADDWF  x9C,W
1CDA:  MOVWF  FE9
1CDC:  MOVF   x9D,W
1CDE:  ADDWFC 03,W
1CE0:  MOVWF  FEA
1CE2:  MOVFF  FEF,1A2
....................          } 
1CE6:  BRA    1CA0
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
1CE8:  BRA    1D7A
1CEA:  MOVF   xA0,W
1CEC:  SUBLW  10
1CEE:  BNZ   1D7A
....................       { 
....................          c = toupper(c); 
1CF0:  MOVF   xA2,W
1CF2:  SUBLW  60
1CF4:  BC    1D02
1CF6:  MOVF   xA2,W
1CF8:  SUBLW  7A
1CFA:  BNC   1D02
1CFC:  MOVF   xA2,W
1CFE:  ANDLW  DF
1D00:  BRA    1D04
1D02:  MOVF   xA2,W
1D04:  MOVWF  xA2
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
1D06:  MOVF   xA2,W
1D08:  SUBLW  2F
1D0A:  BC    1D12
1D0C:  MOVF   xA2,W
1D0E:  SUBLW  39
1D10:  BC    1D1E
1D12:  MOVF   xA2,W
1D14:  SUBLW  40
1D16:  BC    1D7A
1D18:  MOVF   xA2,W
1D1A:  SUBLW  46
1D1C:  BNC   1D7A
....................             if (c >= '0' && c <= '9') 
1D1E:  MOVF   xA2,W
1D20:  SUBLW  2F
1D22:  BC    1D3C
1D24:  MOVF   xA2,W
1D26:  SUBLW  39
1D28:  BNC   1D3C
....................                result = (result << 4) + (c - '0'); 
1D2A:  SWAPF  x9E,W
1D2C:  MOVWF  xA3
1D2E:  MOVLW  F0
1D30:  ANDWF  xA3,F
1D32:  MOVLW  30
1D34:  SUBWF  xA2,W
1D36:  ADDWF  xA3,W
1D38:  MOVWF  x9E
....................             else 
1D3A:  BRA    1D4E
....................                result = (result << 4) + (c - 'A' + 10); 
1D3C:  SWAPF  x9E,W
1D3E:  MOVWF  xA3
1D40:  MOVLW  F0
1D42:  ANDWF  xA3,F
1D44:  MOVLW  41
1D46:  SUBWF  xA2,W
1D48:  ADDLW  0A
1D4A:  ADDWF  xA3,W
1D4C:  MOVWF  x9E
....................  
....................             c = s[index++]; 
1D4E:  MOVF   xA1,W
1D50:  INCF   xA1,F
1D52:  CLRF   03
1D54:  ADDWF  x9C,W
1D56:  MOVWF  FE9
1D58:  MOVF   x9D,W
1D5A:  ADDWFC 03,W
1D5C:  MOVWF  FEA
1D5E:  MOVFF  FEF,1A2
....................             c = toupper(c); 
1D62:  MOVF   xA2,W
1D64:  SUBLW  60
1D66:  BC    1D74
1D68:  MOVF   xA2,W
1D6A:  SUBLW  7A
1D6C:  BNC   1D74
1D6E:  MOVF   xA2,W
1D70:  ANDLW  DF
1D72:  BRA    1D76
1D74:  MOVF   xA2,W
1D76:  MOVWF  xA2
....................          } 
1D78:  BRA    1D06
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
1D7A:  DECFSZ x9F,W
1D7C:  BRA    1D86
1D7E:  MOVF   xA0,W
1D80:  SUBLW  0A
1D82:  BNZ   1D86
....................        result = -result; 
1D84:  NEGF   x9E
....................  
....................    return(result); 
1D86:  MOVFF  19E,01
.................... } 
1D8A:  MOVLB  0
1D8C:  RETURN 0
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #PRIORITY RDA,RDA2,TIMER0,EXT 
....................  
.................... //----------------------------------------------------------------// 
.................... //-                Conversion Function                           -// 
.................... char chartohex( char valuetoconvert ) 
.................... { 
....................    char convertedval; 
....................       if( valuetoconvert >= 'A' ) 
*
36CE:  MOVLB  1
36D0:  MOVF   xCE,W
36D2:  SUBLW  40
36D4:  BC    36E0
....................       { 
....................             convertedval = valuetoconvert-'A'+10; 
36D6:  MOVLW  41
36D8:  SUBWF  xCE,W
36DA:  ADDLW  0A
36DC:  MOVWF  xCF
....................       }    
....................       else 
36DE:  BRA    36E6
....................       { 
....................             convertedval = valuetoconvert -'0'; 
36E0:  MOVLW  30
36E2:  SUBWF  xCE,W
36E4:  MOVWF  xCF
....................       } 
....................       return convertedval; 
36E6:  MOVFF  1CF,01
.................... } 
36EA:  MOVLB  0
36EC:  RETURN 0
....................  
.................... //----------------------------------------------------------------// 
.................... //-                Robot Initialisation                          -// 
....................  
.................... void KJunior_init(void) 
.................... { 
*
1670:  MOVLB  1
1672:  CLRF   x94
....................  unsigned int i=0; 
....................  // configure ports direction 
....................  set_tris_a(INIT_TRISA); 
1674:  MOVLW  2F
1676:  MOVWF  F92
....................  set_tris_b(INIT_TRISB); 
1678:  MOVLW  C1
167A:  MOVWF  F93
....................  set_tris_c(INIT_TRISC); 
167C:  MOVLW  9F
167E:  MOVWF  F94
....................  set_tris_d(INIT_TRISD); 
1680:  MOVLW  00
1682:  MOVWF  F95
....................  set_tris_e(INIT_TRISE); 
1684:  MOVWF  F96
....................  set_tris_f(INIT_TRISF); 
1686:  MOVLW  BF
1688:  MOVWF  F97
....................  set_tris_g(INIT_TRISG); 
168A:  MOVLW  04
168C:  MOVWF  F98
....................  
....................  // set default value for each pin 
....................  output_a(INIT_PORTA); 
168E:  CLRF   F89
....................  output_b(INIT_PORTB); 
1690:  CLRF   F8A
....................  output_c(INIT_PORTC); 
1692:  CLRF   F8B
....................  output_d(INIT_PORTD); 
1694:  CLRF   F8C
....................  output_e(INIT_PORTE); 
1696:  CLRF   F8D
....................  output_f(INIT_PORTF); 
1698:  CLRF   F8E
....................  output_g(INIT_PORTG); 
169A:  CLRF   F8F
....................     
....................  
....................  
....................    
....................  setup_oscillator(OSC_16MHZ);                                                   // use internal osc@16 MHz, no clockout 
169C:  MOVLW  70
169E:  MOVWF  FD3
16A0:  CLRF   F9B
16A2:  CLRF   F64
....................  for (i=0;i<=GROUNDRIGHT;i++)                                                   // Init the IR table values and the read the calibrate value in the EEPROM 
16A4:  CLRF   x94
16A6:  MOVF   x94,W
16A8:  SUBLW  0A
16AA:  BTFSS  FD8.0
16AC:  BRA    17D2
....................              { 
....................    IR_Light[i]= 0; 
16AE:  BCF    FD8.0
16B0:  RLCF   x94,W
16B2:  CLRF   03
16B4:  ADDLW  91
16B6:  MOVWF  FE9
16B8:  MOVLW  00
16BA:  ADDWFC 03,W
16BC:  MOVWF  FEA
16BE:  CLRF   FEC
16C0:  MOVF   FED,F
16C2:  CLRF   FEF
....................    IR_Proximity[i] = 0; 
16C4:  BCF    FD8.0
16C6:  RLCF   x94,W
16C8:  CLRF   03
16CA:  ADDLW  A9
16CC:  MOVWF  FE9
16CE:  MOVLW  00
16D0:  ADDWFC 03,W
16D2:  MOVWF  FEA
16D4:  CLRF   FEC
16D6:  MOVF   FED,F
16D8:  CLRF   FEF
....................    IR_Calibrate[i] = read_eeprom((EEPROM_ADD*2*i)+1); 
16DA:  BCF    FD8.0
16DC:  RLCF   x94,W
16DE:  CLRF   03
16E0:  ADDLW  C1
16E2:  MOVWF  FE9
16E4:  MOVLW  00
16E6:  ADDWFC 03,W
16E8:  MOVWF  FEA
16EA:  MOVF   x94,W
16EC:  MULLW  14
16EE:  MOVF   FF3,W
16F0:  ADDLW  01
16F2:  MOVWF  x97
16F4:  MOVFF  FF2,198
16F8:  BCF    FF2.7
16FA:  CLRF   F63
16FC:  MOVFF  197,F62
1700:  BCF    F7F.6
1702:  BCF    F7F.7
1704:  BSF    F7F.0
1706:  MOVF   F61,W
1708:  BTFSC  x98.7
170A:  BSF    FF2.7
170C:  CLRF   03
170E:  MOVWF  FEF
1710:  MOVFF  03,FEC
1714:  MOVF   FED,F
....................    IR_Calibrate[i] = (signed int16)(IR_Calibrate[i]<<8) + read_eeprom(EEPROM_ADD*2*i); 
1716:  BCF    FD8.0
1718:  RLCF   x94,W
171A:  CLRF   03
171C:  ADDLW  C1
171E:  MOVWF  01
1720:  MOVLW  00
1722:  ADDWFC 03,F
1724:  MOVF   01,W
1726:  MOVWF  x95
1728:  MOVFF  03,196
172C:  BCF    FD8.0
172E:  RLCF   x94,W
1730:  CLRF   03
1732:  ADDLW  C1
1734:  MOVWF  FE9
1736:  MOVLW  00
1738:  ADDWFC 03,W
173A:  MOVWF  FEA
173C:  MOVFF  FEC,198
1740:  MOVF   FED,F
1742:  MOVFF  FEF,197
1746:  MOVFF  197,03
174A:  MOVLW  00
174C:  MOVWF  x97
174E:  MOVFF  03,198
1752:  MOVF   x94,W
1754:  MULLW  14
1756:  MOVF   FF3,W
1758:  MOVWF  x99
175A:  MOVFF  FF2,19A
175E:  BCF    FF2.7
1760:  CLRF   F63
1762:  MOVFF  199,F62
1766:  BCF    F7F.6
1768:  BCF    F7F.7
176A:  BSF    F7F.0
176C:  MOVF   F61,W
176E:  BTFSC  x9A.7
1770:  BSF    FF2.7
1772:  ADDWF  x97,W
1774:  MOVWF  01
1776:  MOVLW  00
1778:  ADDWFC x98,W
177A:  MOVWF  03
177C:  MOVF   01,W
177E:  MOVWF  x97
1780:  MOVFF  03,198
1784:  MOVFF  196,FEA
1788:  MOVFF  195,FE9
178C:  MOVFF  198,FEC
1790:  MOVF   FED,F
1792:  MOVFF  197,FEF
....................    if(IR_Calibrate[i] == 0xFFFF)                                                // If the Eeprom has not been initialize, reset the value 
1796:  BCF    FD8.0
1798:  RLCF   x94,W
179A:  CLRF   03
179C:  ADDLW  C1
179E:  MOVWF  FE9
17A0:  MOVLW  00
17A2:  ADDWFC 03,W
17A4:  MOVWF  FEA
17A6:  MOVFF  FEC,196
17AA:  MOVF   FED,F
17AC:  MOVFF  FEF,195
17B0:  INCFSZ x95,W
17B2:  BRA    17CE
17B4:  INCFSZ x96,W
17B6:  BRA    17CE
....................      IR_Calibrate[i] = 0; 
17B8:  BCF    FD8.0
17BA:  RLCF   x94,W
17BC:  CLRF   03
17BE:  ADDLW  C1
17C0:  MOVWF  FE9
17C2:  MOVLW  00
17C4:  ADDWFC 03,W
17C6:  MOVWF  FEA
17C8:  CLRF   FEC
17CA:  MOVF   FED,F
17CC:  CLRF   FEF
....................     
....................  }   
17CE:  INCF   x94,F
17D0:  BRA    16A6
....................  PwmMotLeft = 0;                                                                // Init the Speed to 0 
17D2:  CLRF   1A
....................  PwmMotRight = 0; 
17D4:  CLRF   1B
....................   
....................  // Disable IR sensor emitter 
....................  output_low(IR_GROUP1); 
17D6:  BCF    F8C.1
....................  output_low(IR_GROUP2); 
17D8:  BCF    F8C.2
....................  output_low(IR_GROUP3); 
17DA:  BCF    F8C.3
....................   
....................  // init the pin map table for the IR sensor 
....................  // Emitter E0 
....................  IR_AN_Table[0]       = LEFT; 
17DC:  MOVLB  0
17DE:  CLRF   xF3
....................  IR_AN_Table[1]       = FRONT; 
17E0:  MOVLW  02
17E2:  MOVWF  xF4
....................  IR_AN_Table[2]       = RIGHT; 
17E4:  MOVLW  04
17E6:  MOVWF  xF5
....................  // Emitter E1 
....................  IR_AN_Table[3]       = FRONTLEFT; 
17E8:  MOVLW  01
17EA:  MOVWF  xF6
....................  IR_AN_Table[4]       = GROUNDFRONTRIGHT; 
17EC:  MOVLW  08
17EE:  MOVWF  xF7
....................  IR_AN_Table[5]       = GROUNDLEFT; 
17F0:  MOVLW  09
17F2:  MOVWF  xF8
....................  // Emitter E2 
....................  IR_AN_Table[6]       = FRONTRIGHT; 
17F4:  MOVLW  03
17F6:  MOVWF  xF9
....................  IR_AN_Table[7]       = REAR; 
17F8:  MOVLW  05
17FA:  MOVWF  xFA
....................  IR_AN_Table[8]       = GROUNDFRONTLEFT; 
17FC:  MOVLW  07
17FE:  MOVWF  xFB
....................  IR_AN_Table[9]       = GROUNDRIGHT; 
1800:  MOVLW  0A
1802:  MOVWF  xFC
....................   
....................   
....................   
....................    
....................   
....................  
....................  // Setup the adc converter to start with the LEFT IR sensor 
....................  setup_adc_ports(sAN0 | sAN1 | sAN2 | sAN3 | sAN4 | sAN5 | sAN6 | sAN7 | sAN8| sAN9 | sAN10 ); 
1804:  MOVLW  00
1806:  MOVLB  F
1808:  MOVWF  x23
180A:  MOVLW  07
180C:  MOVWF  x24
180E:  MOVLW  FF
1810:  MOVWF  x25
1812:  BCF    FC1.3
1814:  BCF    FC1.4
1816:  BCF    FC1.5
....................  ADCON1 = 0x00;                                                                 // Set the ADC reference to AVdd and AVss 
1818:  CLRF   FC1
....................  //ADCON1 = 0x30;                                                                 // Set the ADC reference to AVdd and AVss 
....................  set_adc_channel( IR_AN_Table[0] ); 
181A:  MOVLB  0
181C:  RLCF   xF3,W
181E:  MOVWF  00
1820:  RLCF   00,F
1822:  MOVLW  FC
1824:  ANDWF  00,F
1826:  MOVF   FC2,W
1828:  ANDLW  83
182A:  IORWF  00,W
182C:  MOVWF  FC2
182E:  MOVLW  00
1830:  MOVWF  01
1832:  MOVF   FC1,W
1834:  ANDLW  F8
1836:  IORWF  01,W
1838:  MOVWF  FC1
....................  ADCON2 = 0xA5;                                                                 // Configure the ADC clock DIV/16 with 8TAD 
183A:  MOVLW  A5
183C:  MOVWF  FC0
....................  ADCON0 |= 0x01;                                                                // Turn on the AD module 
183E:  BSF    FC2.0
....................  enable_interrupts(INT_AD); 
1840:  BSF    F9D.6
....................  
....................  
....................  
....................  // Set the timer 1 used for the internal tasks management 
....................  set_timer1(TIMER1_VALUE);                                                      // set default value to get an interrupt each 250us 
1842:  MOVLW  FC
1844:  MOVWF  FCF
1846:  MOVLW  49
1848:  MOVWF  FCE
....................  setup_timer_1(T1_INTERNAL);                                                    // used for scheduler 
184A:  MOVLW  07
184C:  MOVWF  FCD
184E:  CLRF   FAA
....................  // Activate the interrupts 
....................  enable_interrupts(INT_TIMER1); 
1850:  BSF    F9D.0
....................  if( Enable_RS232_Control == 1 ) 
1852:  BTFSS  22.2
1854:  BRA    185A
....................  { 
....................     enable_interrupts(INT_RDA); 
1856:  BSF    F9D.5
....................     enable_interrupts(INT_RDA2); 
1858:  BSF    FA3.5
.................... //    RCON |= IPEN;                                                               // Enable the level interrupt 
....................  } 
....................  while(kbhit(BT)) fgetc(BT);                                                    // Flush the RS232 buffer 
185A:  BTFSS  FA4.5
185C:  BRA    186A
185E:  BTFSS  FA4.5
1860:  BRA    185E
1862:  MOVLB  F
1864:  MOVF   x1D,W
1866:  MOVLB  0
1868:  BRA    185A
....................  while(kbhit(USB)) fgetc(USB); 
186A:  BTFSS  F9E.5
186C:  BRA    1876
186E:  BTFSS  F9E.5
1870:  BRA    186E
1872:  MOVF   FAE,W
1874:  BRA    186A
....................   
....................  // Read the Switch the first time 
....................  Switchs  =   !input(MODE1);         
1876:  MOVLB  1
1878:  CLRF   x01
187A:  BTFSS  F82.0
187C:  INCF   x01,F
....................  Switchs |= ((!input(MODE2))<<1);    
187E:  MOVLW  00
1880:  BTFSS  F82.1
1882:  MOVLW  01
1884:  MOVWF  00
1886:  BCF    FD8.0
1888:  RLCF   00,F
188A:  MOVF   00,W
188C:  IORWF  x01,F
....................  Switchs |= ((!input(MODE3))<<2);    
188E:  MOVLW  00
1890:  BTFSS  F82.2
1892:  MOVLW  01
1894:  MOVWF  00
1896:  RLCF   00,F
1898:  RLCF   00,F
189A:  MOVLW  FC
189C:  ANDWF  00,F
189E:  MOVF   00,W
18A0:  IORWF  x01,F
....................   
....................  setup_timer_0(T0_OFF);                                                         // used for Rc5 decoding, Initially OFF 
18A2:  CLRF   FD5
....................   
....................  setup_timer_3(T3_DISABLED | T3_DIV_BY_4);                                      // Configure the Timer3 for the buzzer, initially OFF 
18A4:  CLRF   FB0
18A6:  MOVLW  20
18A8:  MOVWF  FB1
....................  Buzzer_Table[1] = BUZ_DO;                                                      // Configure the frequency note table 
18AA:  MOVLW  F8
18AC:  MOVWF  x0B
18AE:  MOVLW  8A
18B0:  MOVWF  x0A
....................  Buzzer_Table[2] = BUZ_RE_BEMOL; 
18B2:  MOVLW  F8
18B4:  MOVWF  x0D
18B6:  MOVLW  F1
18B8:  MOVWF  x0C
....................  Buzzer_Table[3] = BUZ_RE; 
18BA:  MOVLW  F9
18BC:  MOVWF  x0F
18BE:  MOVLW  5A
18C0:  MOVWF  x0E
....................  Buzzer_Table[4] = BUZ_MI_BEMOL; 
18C2:  MOVLW  F9
18C4:  MOVWF  x11
18C6:  MOVLW  B7
18C8:  MOVWF  x10
....................  Buzzer_Table[5] = BUZ_MI; 
18CA:  MOVLW  FA
18CC:  MOVWF  x13
18CE:  MOVLW  13
18D0:  MOVWF  x12
....................  Buzzer_Table[6] = BUZ_FA; 
18D2:  MOVLW  FA
18D4:  MOVWF  x15
18D6:  MOVLW  73
18D8:  MOVWF  x14
....................  Buzzer_Table[7] = BUZ_SOL_BEMOL; 
18DA:  MOVLW  FA
18DC:  MOVWF  x17
18DE:  MOVLW  B7
18E0:  MOVWF  x16
....................  Buzzer_Table[8] = BUZ_SOL; 
18E2:  MOVLW  FB
18E4:  MOVWF  x19
18E6:  MOVLW  03
18E8:  MOVWF  x18
....................  Buzzer_Table[9] = BUZ_LA_BEMOL; 
18EA:  MOVLW  FB
18EC:  MOVWF  x1B
18EE:  MOVLW  4A
18F0:  MOVWF  x1A
....................  Buzzer_Table[10] = BUZ_LA; 
18F2:  MOVLW  FB
18F4:  MOVWF  x1D
18F6:  MOVLW  8E
18F8:  MOVWF  x1C
....................  Buzzer_Table[11] = BUZ_SI_BEMOL; 
18FA:  MOVLW  FB
18FC:  MOVWF  x1F
18FE:  MOVLW  CE
1900:  MOVWF  x1E
....................  Buzzer_Table[12] = BUZ_SI; 
1902:  MOVLW  FC
1904:  MOVWF  x21
1906:  MOVLW  0A
1908:  MOVWF  x20
....................   
....................  
....................  setup_timer_4(T4_DIV_BY_1,MOTOR_MAX,1);                                        // Configure the PWM motor at 20kHz 
190A:  MOVLW  00
190C:  IORLW  04
190E:  MOVWF  F6B
1910:  MOVLW  C8
1912:  MOVWF  F6C
....................   
....................  CCP1CON = 0x0C;                                                                // Configure the ECCP1 module in single PWM mode 
1914:  MOVLW  0C
1916:  MOVWF  FBB
....................  CCP3CON = 0x0C;                                                                // Configure the ECCP3 module in single PWM mode 
1918:  MOVLB  F
191A:  MOVWF  x49
....................   
....................  CCPTMRS0 = 0x41;                                                               // Select the Timer4 for the Motor, and the Timer2 for the Buzzer 
191C:  MOVLW  41
191E:  MOVWF  x2D
....................  PSTR1CON = 0x00;                                                               // Set M1_A and M1_B as standard output 
1920:  CLRF   F9C
....................  PSTR3CON = 0x00;                                                               // Set M2_A and M2_B as standard output 
1922:  CLRF   x1A
....................   
....................  // Configure the I2C bus 
....................  SSP1CON1 = 0x28;                                                               // Configure the I2C bus as Master and enable it 
1924:  MOVLW  28
1926:  MOVWF  FC6
....................  
....................  
....................  // Enable and configure the interrupts 
....................  ext_int_edge(H_TO_L);                                                          
1928:  BCF    FF1.6
....................  enable_interrupts(INT_EXT); 
192A:  BSF    FF2.4
....................  enable_interrupts(GLOBAL); 
192C:  MOVLW  C0
192E:  IORWF  FF2,F
....................  
....................  
....................  // Display boot message 
....................  delay_ms(50); 
1930:  MOVLW  32
1932:  MOVLB  1
1934:  MOVWF  x96
1936:  MOVLB  0
1938:  RCALL  13F2
....................   
....................  fprintf(USB,"\r\nK-Junior v2 Operating System\r\n"); 
193A:  MOVLW  F6
193C:  MOVWF  FF6
193E:  MOVLW  00
1940:  MOVWF  FF7
1942:  RCALL  141C
....................  fprintf(USB,"kJOS %s-%02d (%s), K-Team SA\r\n",KJ_FW_VERSION,KJ_FW_REVISION, KJ_FW_REFERENCE ); 
1944:  MOVLW  18
1946:  MOVWF  FF6
1948:  MOVLW  01
194A:  MOVWF  FF7
194C:  MOVLW  05
194E:  MOVLB  1
1950:  MOVWF  xA4
1952:  MOVLB  0
1954:  RCALL  143E
1956:  MOVLW  38
1958:  MOVWF  FF6
195A:  MOVLW  01
195C:  MOVWF  FF7
195E:  RCALL  141C
1960:  MOVLW  2D
1962:  BTFSS  F9E.4
1964:  BRA    1962
1966:  MOVWF  FAD
1968:  MOVLW  01
196A:  MOVLB  1
196C:  MOVWF  x95
196E:  MOVWF  x96
1970:  MOVLB  0
1972:  RCALL  1494
1974:  MOVLW  20
1976:  BTFSS  F9E.4
1978:  BRA    1976
197A:  MOVWF  FAD
197C:  MOVLW  28
197E:  BTFSS  F9E.4
1980:  BRA    197E
1982:  MOVWF  FAD
1984:  MOVLW  3A
1986:  MOVWF  FF6
1988:  MOVLW  01
198A:  MOVWF  FF7
198C:  RCALL  141C
198E:  MOVLW  28
1990:  MOVWF  FF6
1992:  MOVLW  01
1994:  MOVWF  FF7
1996:  MOVLW  0E
1998:  MOVLB  1
199A:  MOVWF  xA4
199C:  MOVLB  0
199E:  RCALL  143E
....................  fprintf(USB,"E-Mail : info@k-team.com\r\n"); 
19A0:  MOVLW  44
19A2:  MOVWF  FF6
19A4:  MOVLW  01
19A6:  MOVWF  FF7
19A8:  RCALL  141C
....................  fprintf(BT,"\r\nK-Junior v2 Operating System\r\n"); 
19AA:  MOVLW  60
19AC:  MOVWF  FF6
19AE:  MOVLW  01
19B0:  MOVWF  FF7
19B2:  RCALL  1552
....................  fprintf(BT,"kJOS %s-%02d (%s), K-Team SA\r\n",KJ_FW_VERSION,KJ_FW_REVISION, KJ_FW_REFERENCE ); 
19B4:  MOVLW  82
19B6:  MOVWF  FF6
19B8:  MOVLW  01
19BA:  MOVWF  FF7
19BC:  MOVLW  05
19BE:  MOVLB  1
19C0:  MOVWF  x95
19C2:  MOVLB  0
19C4:  RCALL  1578
19C6:  MOVLW  A2
19C8:  MOVWF  FF6
19CA:  MOVLW  01
19CC:  MOVWF  FF7
19CE:  RCALL  1552
19D0:  MOVLW  2D
19D2:  BTFSS  FA4.4
19D4:  BRA    19D2
19D6:  MOVLB  F
19D8:  MOVWF  x1C
19DA:  MOVLW  01
19DC:  MOVLB  1
19DE:  MOVWF  x95
19E0:  MOVWF  x96
19E2:  MOVLB  0
19E4:  RCALL  15A4
19E6:  MOVLW  20
19E8:  BTFSS  FA4.4
19EA:  BRA    19E8
19EC:  MOVLB  F
19EE:  MOVWF  x1C
19F0:  MOVLW  28
19F2:  BTFSS  FA4.4
19F4:  BRA    19F2
19F6:  MOVWF  x1C
19F8:  MOVLW  A4
19FA:  MOVWF  FF6
19FC:  MOVLW  01
19FE:  MOVWF  FF7
1A00:  MOVLB  0
1A02:  RCALL  1552
1A04:  MOVLW  92
1A06:  MOVWF  FF6
1A08:  MOVLW  01
1A0A:  MOVWF  FF7
1A0C:  MOVLW  0E
1A0E:  MOVLB  1
1A10:  MOVWF  x95
1A12:  MOVLB  0
1A14:  RCALL  1578
....................  fprintf(BT,"E-Mail : info@k-team.com\r\n"); 
1A16:  MOVLW  AE
1A18:  MOVWF  FF6
1A1A:  MOVLW  01
1A1C:  MOVWF  FF7
1A1E:  RCALL  1552
....................  
....................  
....................  
.................... } 
1A20:  GOTO   7178 (RETURN)
....................  
.................... //---------------------------------------------------------------// 
.................... // Convert the intial motor value (0-20) to the final PWM (0-100%) 
.................... //---------------------------------------------------------------// 
.................... void Set_left_motor(void) 
.................... { 
....................       if(PwmMotLeft == 0)                                                       // Stop the motor left 
*
0AD4:  MOVF   1A,F
0AD6:  BNZ   0AE4
....................       { 
....................         set_pwm3_duty(0);                                                       // Set the duty cycle to 0 
0AD8:  MOVLB  F
0ADA:  CLRF   x4A
....................         PSTR3CON = 0x00;                                                        // Set M2_A and M2_B as standard output 
0ADC:  CLRF   x1A
....................         return; 
0ADE:  BRA    0B7A
....................       } 
....................       else if(PwmMotLeft > 0) 
0AE0:  BRA    0B76
0AE2:  MOVLB  0
0AE4:  BTFSC  1A.7
0AE6:  BRA    0B28
0AE8:  MOVF   1A,W
0AEA:  SUBLW  00
0AEC:  BC    0B28
....................       { 
....................         if((PwmMotLeft < SPEED_MIN) && (Old_PwmMotLeft <= 0) && (PwmMotLeft != Old_PwmMotLeft))            // If the actual and new speed is too low 
0AEE:  BTFSC  1A.7
0AF0:  BRA    0AF8
0AF2:  MOVF   1A,W
0AF4:  SUBLW  0E
0AF6:  BNC   0B0A
0AF8:  BTFSC  1D.7
0AFA:  BRA    0B02
0AFC:  MOVF   1D,W
0AFE:  SUBLW  00
0B00:  BNC   0B0A
0B02:  MOVF   1D,W
0B04:  SUBWF  1A,W
0B06:  BZ    0B0A
....................          Acceleration_flag |= ACCEL_LEFT; 
0B08:  BSF    21.0
....................         TimerMotLeft = (MOTOR_CONV * PwmMotLeft)+MOTOR_MIN;                     // calculate the duty cycle 
0B0A:  MOVLW  07
0B0C:  MOVLB  2
0B0E:  MOVWF  x03
0B10:  MOVFF  1A,204
0B14:  MOVLB  0
0B16:  RCALL  09E8
0B18:  MOVLW  3C
0B1A:  ADDWF  01,W
0B1C:  MOVWF  1E
....................         PSTR3CON = 0x04;                                                        // Enable M2_A as PWM output 
0B1E:  MOVLW  04
0B20:  MOVLB  F
0B22:  MOVWF  x1A
....................       } 
....................       else 
0B24:  BRA    0B76
0B26:  MOVLB  0
....................       { 
....................         if((-PwmMotLeft < SPEED_MIN) && (-Old_PwmMotLeft <= 0) && (PwmMotLeft != Old_PwmMotLeft))          // If the actual and new speed is too low 
0B28:  MOVLW  00
0B2A:  BSF    FD8.0
0B2C:  SUBFWB 1A,W
0B2E:  MOVWF  00
0B30:  BTFSC  FE8.7
0B32:  BRA    0B3A
0B34:  MOVF   00,W
0B36:  SUBLW  0E
0B38:  BNC   0B54
0B3A:  MOVLW  00
0B3C:  BSF    FD8.0
0B3E:  SUBFWB 1D,W
0B40:  MOVWF  00
0B42:  BTFSC  FE8.7
0B44:  BRA    0B4C
0B46:  MOVF   00,W
0B48:  SUBLW  00
0B4A:  BNC   0B54
0B4C:  MOVF   1D,W
0B4E:  SUBWF  1A,W
0B50:  BZ    0B54
....................          Acceleration_flag |= ACCEL_LEFT; 
0B52:  BSF    21.0
....................         TimerMotLeft = (MOTOR_CONV * -PwmMotLeft)+MOTOR_MIN;                    // calculate the duty cycle 
0B54:  MOVLW  00
0B56:  BSF    FD8.0
0B58:  SUBFWB 1A,W
0B5A:  MOVLB  2
0B5C:  MOVWF  x02
0B5E:  MOVLW  07
0B60:  MOVWF  x03
0B62:  MOVFF  202,204
0B66:  MOVLB  0
0B68:  RCALL  09E8
0B6A:  MOVLW  3C
0B6C:  ADDWF  01,W
0B6E:  MOVWF  1E
....................         PSTR3CON = 0x02;                                                        // And enable M2_B as PWM output 
0B70:  MOVLW  02
0B72:  MOVLB  F
0B74:  MOVWF  x1A
....................       } 
....................       set_pwm3_duty(TimerMotLeft);                                              // Set the duty cycle 
0B76:  MOVFF  1E,F4A
....................  
.................... } 
0B7A:  MOVLB  0
0B7C:  RETURN 0
....................  
.................... void Set_right_motor(void) 
.................... { 
....................       if(PwmMotRight == 0)                                                       // Stop the motor right 
*
0A36:  MOVF   1B,F
0A38:  BNZ   0A42
....................       { 
....................         set_pwm1_duty(0);                                                       // Set the duty cycle to 0 
0A3A:  CLRF   FBC
....................         PSTR1CON = 0x00;                                                        // Set M2_A and M2_B as standard output 
0A3C:  CLRF   F9C
....................         return; 
0A3E:  BRA    0AD2
....................       } 
....................       else if(PwmMotRight > 0) 
0A40:  BRA    0ACE
0A42:  BTFSC  1B.7
0A44:  BRA    0A82
0A46:  MOVF   1B,W
0A48:  SUBLW  00
0A4A:  BC    0A82
....................       { 
....................         if((PwmMotRight < SPEED_MIN) && (Old_PwmMotRight <= 0) && (PwmMotRight != Old_PwmMotRight))            // If the actual and new speed is too low 
0A4C:  BTFSC  1B.7
0A4E:  BRA    0A56
0A50:  MOVF   1B,W
0A52:  SUBLW  0E
0A54:  BNC   0A68
0A56:  BTFSC  1C.7
0A58:  BRA    0A60
0A5A:  MOVF   1C,W
0A5C:  SUBLW  00
0A5E:  BNC   0A68
0A60:  MOVF   1C,W
0A62:  SUBWF  1B,W
0A64:  BZ    0A68
....................          Acceleration_flag |= ACCEL_RIGHT; 
0A66:  BSF    21.1
....................         TimerMotRight = (MOTOR_CONV * PwmMotRight)+MOTOR_MIN;                   // Calculate the duty cycle 
0A68:  MOVLW  07
0A6A:  MOVLB  2
0A6C:  MOVWF  x03
0A6E:  MOVFF  1B,204
0A72:  MOVLB  0
0A74:  RCALL  09E8
0A76:  MOVLW  3C
0A78:  ADDWF  01,W
0A7A:  MOVWF  1F
....................         PSTR1CON = 0x04;                                                        // And enable M1_A as PWM output 
0A7C:  MOVLW  04
0A7E:  MOVWF  F9C
....................       } 
....................       else 
0A80:  BRA    0ACE
....................       { 
....................         if((-PwmMotRight < SPEED_MIN) && (-Old_PwmMotRight <= 0) && (PwmMotRight != Old_PwmMotRight))            // If the actual and new speed is too low 
0A82:  MOVLW  00
0A84:  BSF    FD8.0
0A86:  SUBFWB 1B,W
0A88:  MOVWF  00
0A8A:  BTFSC  FE8.7
0A8C:  BRA    0A94
0A8E:  MOVF   00,W
0A90:  SUBLW  0E
0A92:  BNC   0AAE
0A94:  MOVLW  00
0A96:  BSF    FD8.0
0A98:  SUBFWB 1C,W
0A9A:  MOVWF  00
0A9C:  BTFSC  FE8.7
0A9E:  BRA    0AA6
0AA0:  MOVF   00,W
0AA2:  SUBLW  00
0AA4:  BNC   0AAE
0AA6:  MOVF   1C,W
0AA8:  SUBWF  1B,W
0AAA:  BZ    0AAE
....................          Acceleration_flag |= ACCEL_RIGHT; 
0AAC:  BSF    21.1
....................         TimerMotRight = (MOTOR_CONV * -PwmMotRight)+MOTOR_MIN;                  // Calculate the duty cycle 
0AAE:  MOVLW  00
0AB0:  BSF    FD8.0
0AB2:  SUBFWB 1B,W
0AB4:  MOVLB  2
0AB6:  MOVWF  x02
0AB8:  MOVLW  07
0ABA:  MOVWF  x03
0ABC:  MOVFF  202,204
0AC0:  MOVLB  0
0AC2:  RCALL  09E8
0AC4:  MOVLW  3C
0AC6:  ADDWF  01,W
0AC8:  MOVWF  1F
....................         PSTR1CON = 0x02;                                                        // And enable M1_B as PWM output 
0ACA:  MOVLW  02
0ACC:  MOVWF  F9C
....................       }  
....................       set_pwm1_duty(TimerMotRight); 
0ACE:  MOVFF  1F,FBC
....................  
.................... } 
0AD2:  RETURN 0
....................  
....................  
.................... void  Motor_Conversion(void) 
.................... { 
....................    Acceleration_flag = 0;                                                       // reset the flag 
*
0B7E:  CLRF   21
....................    Set_right_motor();                                                           // Set the right motor PWM 
0B80:  RCALL  0A36
....................    Set_left_motor();                                                            // Set the left motor PWM 
0B82:  RCALL  0AD4
....................    if(Acceleration_flag != 0)                                                   // If too low speed is set, make a small acceleration on the desired motor 
0B84:  MOVF   21,F
0B86:  BZ    0BA0
....................    { 
....................      if(Acceleration_flag & ACCEL_RIGHT) 
0B88:  BTFSS  21.1
0B8A:  BRA    0B90
....................      { 
....................        set_pwm1_duty(MOTOR_MAX);                                                // make a small acceleration to start the rotation of the motor 
0B8C:  MOVLW  C8
0B8E:  MOVWF  FBC
....................      } 
....................      if(Acceleration_flag & ACCEL_LEFT) 
0B90:  BTFSS  21.0
0B92:  BRA    0B9C
....................      { 
....................        set_pwm3_duty(MOTOR_MAX);                                                // make a small acceleration to start the rotation of the motor 
0B94:  MOVLW  C8
0B96:  MOVLB  F
0B98:  MOVWF  x4A
0B9A:  MOVLB  0
....................      } 
....................      Acceleration_Timer = ACCEL;                                                // Set the timer to stop the acceleration after x ms 
0B9C:  MOVLW  1E
0B9E:  MOVWF  20
....................    } 
....................    Old_PwmMotLeft = PwmMotLeft;                                                 // Save the speed value  
0BA0:  MOVFF  1A,1D
....................    Old_PwmMotRight = PwmMotRight; 
0BA4:  MOVFF  1B,1C
.................... } 
0BA8:  RETURN 0
....................  
.................... //---------------------------------------------------------------// 
.................... // Convert the intial buzzer value (0-48) to the corresponding frequency note 
.................... //---------------------------------------------------------------// 
.................... void Set_Freq_note(void) 
.................... { 
....................   if(buzzValue == 0)                                                            // Turn off the buzzer 
*
28E0:  MOVLB  1
28E2:  MOVF   x05,F
28E4:  BNZ   28F2
....................   { 
....................     disable_interrupts(INT_TIMER3); 
28E6:  BCF    FA0.1
....................     setup_timer_3(T3_DISABLED | T3_DIV_BY_4); 
28E8:  CLRF   FB0
28EA:  MOVLW  20
28EC:  MOVWF  FB1
....................     output_low(BUZZER); 
28EE:  BCF    F8D.2
....................   } 
....................   else 
28F0:  BRA    29B4
....................   { 
....................     if(buzzValue <= 12 )                                                        // Octave n°2 (131Hz-247Hz) 
28F2:  MOVF   x05,W
28F4:  SUBLW  0C
28F6:  BNC   291E
....................     { 
....................       Buzzer_Timer = Buzzer_Table[buzzValue];                                   // Set the timer3 to the frequency of the selected note 
28F8:  BCF    FD8.0
28FA:  RLCF   x05,W
28FC:  CLRF   03
28FE:  ADDLW  08
2900:  MOVWF  FE9
2902:  MOVLW  01
2904:  ADDWFC 03,W
2906:  MOVWF  FEA
2908:  MOVFF  FEC,03
290C:  MOVF   FED,F
290E:  MOVFF  FEF,106
2912:  MOVFF  03,107
....................       setup_timer_3(T3_INTERNAL | T3_DIV_BY_8);                                 // Set the timer to play on the second Octave 
2916:  CLRF   FB0
2918:  MOVLW  37
291A:  MOVWF  FB1
....................     } 
....................     else if(buzzValue <= 24 )                                                   // Octave n°3 (262Hz-494Hz) 
291C:  BRA    29B2
291E:  MOVF   x05,W
2920:  SUBLW  18
2922:  BNC   2952
....................     { 
....................       Buzzer_Timer = Buzzer_Table[buzzValue-12];                                // Set the timer3 to the frequency of the selected note 
2924:  MOVLW  0C
2926:  SUBWF  x05,W
2928:  MOVWF  00
292A:  BCF    FD8.0
292C:  RLCF   00,F
292E:  MOVF   00,W
2930:  CLRF   03
2932:  ADDLW  08
2934:  MOVWF  FE9
2936:  MOVLW  01
2938:  ADDWFC 03,W
293A:  MOVWF  FEA
293C:  MOVFF  FEC,03
2940:  MOVF   FED,F
2942:  MOVFF  FEF,106
2946:  MOVFF  03,107
....................       setup_timer_3(T3_INTERNAL | T3_DIV_BY_4);                                 // Set the timer to play on the third Octave 
294A:  CLRF   FB0
294C:  MOVLW  27
294E:  MOVWF  FB1
....................     } 
....................     else if(buzzValue <= 36 )                                                   // Octave n°4 (523Hz-988Hz) 
2950:  BRA    29B2
2952:  MOVF   x05,W
2954:  SUBLW  24
2956:  BNC   2986
....................     { 
....................       Buzzer_Timer = Buzzer_Table[buzzValue-24];                                // Set the timer3 to the frequency of the selected note 
2958:  MOVLW  18
295A:  SUBWF  x05,W
295C:  MOVWF  00
295E:  BCF    FD8.0
2960:  RLCF   00,F
2962:  MOVF   00,W
2964:  CLRF   03
2966:  ADDLW  08
2968:  MOVWF  FE9
296A:  MOVLW  01
296C:  ADDWFC 03,W
296E:  MOVWF  FEA
2970:  MOVFF  FEC,03
2974:  MOVF   FED,F
2976:  MOVFF  FEF,106
297A:  MOVFF  03,107
....................       setup_timer_3(T3_INTERNAL | T3_DIV_BY_2);                                 // Set the timer to play on the fourth Octave 
297E:  CLRF   FB0
2980:  MOVLW  17
2982:  MOVWF  FB1
....................     } 
....................     else                                                                        // Octave n°5 (1046.5Hz-1975Hz) 
2984:  BRA    29B2
....................     { 
....................       Buzzer_Timer = Buzzer_Table[buzzValue-36];                                // Set the timer3 to the frequency of the selected note 
2986:  MOVLW  24
2988:  SUBWF  x05,W
298A:  MOVWF  00
298C:  BCF    FD8.0
298E:  RLCF   00,F
2990:  MOVF   00,W
2992:  CLRF   03
2994:  ADDLW  08
2996:  MOVWF  FE9
2998:  MOVLW  01
299A:  ADDWFC 03,W
299C:  MOVWF  FEA
299E:  MOVFF  FEC,03
29A2:  MOVF   FED,F
29A4:  MOVFF  FEF,106
29A8:  MOVFF  03,107
....................       setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);                                 // Set the timer to play on the fifth Octave 
29AC:  CLRF   FB0
29AE:  MOVLW  07
29B0:  MOVWF  FB1
....................     } 
....................     enable_interrupts(INT_TIMER3); 
29B2:  BSF    FA0.1
....................   } 
....................  
.................... } 
29B4:  MOVLB  0
29B6:  RETURN 0
....................  
....................  
.................... //---------------------------------------------------------------// 
.................... //-                        TV Remote                            -// 
....................  
.................... // TV Remote Control 
.................... void TV_Remote_Control( void ) 
.................... { 
....................    switch( TV_DATA ) 
....................    { 
*
0DC8:  MOVF   x84,W
0DCA:  XORLW  01
0DCC:  BZ    0DFC
0DCE:  XORLW  03
0DD0:  BZ    0E06
0DD2:  XORLW  01
0DD4:  BZ    0E0E
0DD6:  XORLW  07
0DD8:  BZ    0E18
0DDA:  XORLW  01
0DDC:  BZ    0E22
0DDE:  XORLW  03
0DE0:  BZ    0E28
0DE2:  XORLW  01
0DE4:  BZ    0E32
0DE6:  XORLW  0F
0DE8:  BZ    0E3C
0DEA:  XORLW  01
0DEC:  BZ    0E44
0DEE:  XORLW  05
0DF0:  BZ    0E4E
0DF2:  XORLW  1C
0DF4:  BZ    0E52
0DF6:  XORLW  01
0DF8:  BZ    0E56
0DFA:  BRA    0E5A
....................       case 1 : 
....................          PwmMotLeft = 5; 
0DFC:  MOVLW  05
0DFE:  MOVWF  1A
....................          PwmMotRight = 18; 
0E00:  MOVLW  12
0E02:  MOVWF  1B
....................          break; 
0E04:  BRA    0E5C
....................       case 2 : 
....................          PwmMotLeft = 14; 
0E06:  MOVLW  0E
0E08:  MOVWF  1A
....................          PwmMotRight = 14; 
0E0A:  MOVWF  1B
....................          break; 
0E0C:  BRA    0E5C
....................       case 3 : 
....................          PwmMotLeft = 18; 
0E0E:  MOVLW  12
0E10:  MOVWF  1A
....................          PwmMotRight = 5; 
0E12:  MOVLW  05
0E14:  MOVWF  1B
....................          break; 
0E16:  BRA    0E5C
....................       case 4: 
....................          PwmMotLeft = -14; 
0E18:  MOVLW  F2
0E1A:  MOVWF  1A
....................          PwmMotRight = 14; 
0E1C:  MOVLW  0E
0E1E:  MOVWF  1B
....................          break; 
0E20:  BRA    0E5C
....................       case 5 : 
....................          PwmMotLeft = 0; 
0E22:  CLRF   1A
....................          PwmMotRight = 0; 
0E24:  CLRF   1B
....................          break; 
0E26:  BRA    0E5C
....................       case 6 : 
....................          PwmMotLeft = 14; 
0E28:  MOVLW  0E
0E2A:  MOVWF  1A
....................          PwmMotRight = -14; 
0E2C:  MOVLW  F2
0E2E:  MOVWF  1B
....................          break; 
0E30:  BRA    0E5C
....................       case 7 : 
....................          PwmMotLeft = -5; 
0E32:  MOVLW  FB
0E34:  MOVWF  1A
....................          PwmMotRight = -18; 
0E36:  MOVLW  EE
0E38:  MOVWF  1B
....................          break; 
0E3A:  BRA    0E5C
....................       case 8: 
....................          PwmMotLeft = -14; 
0E3C:  MOVLW  F2
0E3E:  MOVWF  1A
....................          PwmMotRight = -14; 
0E40:  MOVWF  1B
....................          break; 
0E42:  BRA    0E5C
....................       case 9 : 
....................          PwmMotLeft = -18; 
0E44:  MOVLW  EE
0E46:  MOVWF  1A
....................          PwmMotRight = -5; 
0E48:  MOVLW  FB
0E4A:  MOVWF  1B
....................          break; 
0E4C:  BRA    0E5C
....................       case 12 :            // Touche On/Off 
....................          return; 
0E4E:  BRA    0E5E
....................          break; 
0E50:  BRA    0E5C
....................       case 16 :            // Touche Son + 
....................          return; 
0E52:  BRA    0E5E
....................          break; 
0E54:  BRA    0E5C
....................       case 17 :            // Touche Son - 
....................          return; 
0E56:  BRA    0E5E
....................          break; 
0E58:  BRA    0E5C
....................       default: 
....................         return; 
0E5A:  BRA    0E5E
....................         break; 
....................    } 
....................    Motor_Conversion();   
0E5C:  RCALL  0B7E
.................... } 
0E5E:  GOTO   0F74 (RETURN)
.................... #INT_AD 
.................... void Analog_Interrupt(void) 
.................... { 
....................     
....................    // Read the battery voltage 
....................    if(IR_ADC_flag == 0) 
*
01CA:  MOVF   xF2,F
01CC:  BNZ   0214
....................    {    
....................      BatteryVoltage = read_adc(ADC_READ_ONLY);                                // Read the battery voltage 
01CE:  BTFSC  FC2.1
01D0:  BRA    01CE
01D2:  MOVFF  FC3,FF
01D6:  MOVFF  FC4,100
....................      IR_ADC_flag++; 
01DA:  INCF   xF2,F
....................      set_adc_channel(IR_AN_Table[ IR_Counter ]);                                // Set the analog input to the first sensor 
01DC:  CLRF   03
01DE:  MOVF   xF1,W
01E0:  ADDLW  F3
01E2:  MOVWF  FE9
01E4:  MOVLW  00
01E6:  ADDWFC 03,W
01E8:  MOVWF  FEA
01EA:  MOVFF  FEF,201
01EE:  MOVLB  2
01F0:  RLCF   x01,W
01F2:  MOVWF  00
01F4:  RLCF   00,F
01F6:  MOVLW  FC
01F8:  ANDWF  00,F
01FA:  MOVF   FC2,W
01FC:  ANDLW  83
01FE:  IORWF  00,W
0200:  MOVWF  FC2
0202:  MOVLW  00
0204:  MOVWF  01
0206:  MOVF   FC1,W
0208:  ANDLW  F8
020A:  IORWF  01,W
020C:  MOVWF  FC1
....................    } 
....................   
....................     // Read all the ambiant value 
....................    else if(IR_ADC_flag == 1) 
020E:  GOTO   09E0
0212:  MOVLB  0
0214:  DECFSZ xF2,W
0216:  BRA    02C6
....................    { 
....................      IR_light[IR_AN_Table[ IR_Counter ]] = read_adc(ADC_READ_ONLY);             // Read the ambiant light value 
0218:  CLRF   03
021A:  MOVF   xF1,W
021C:  ADDLW  F3
021E:  MOVWF  FE9
0220:  MOVLW  00
0222:  ADDWFC 03,W
0224:  MOVWF  FEA
0226:  BCF    FD8.0
0228:  RLCF   FEF,W
022A:  CLRF   03
022C:  ADDLW  91
022E:  MOVWF  FE9
0230:  MOVLW  00
0232:  ADDWFC 03,W
0234:  MOVWF  FEA
0236:  BTFSC  FC2.1
0238:  BRA    0236
023A:  MOVFF  FC3,FEF
023E:  MOVFF  FC4,FEC
....................      if(++IR_Counter >= NB_IR)                                                   // If all the ambiant light value are readed 
0242:  INCF   xF1,F
0244:  MOVF   xF1,W
0246:  SUBLW  09
0248:  BC    0284
....................      { 
....................        IR_Counter = 0;                                                          // Reset the counter 
024A:  CLRF   xF1
....................        set_adc_channel(IR_AN_Table[ IR_Counter ]);                              // And set the Analog input to the first IR 
024C:  CLRF   03
024E:  MOVF   xF1,W
0250:  ADDLW  F3
0252:  MOVWF  FE9
0254:  MOVLW  00
0256:  ADDWFC 03,W
0258:  MOVWF  FEA
025A:  MOVFF  FEF,201
025E:  MOVLB  2
0260:  RLCF   x01,W
0262:  MOVWF  00
0264:  RLCF   00,F
0266:  MOVLW  FC
0268:  ANDWF  00,F
026A:  MOVF   FC2,W
026C:  ANDLW  83
026E:  IORWF  00,W
0270:  MOVWF  FC2
0272:  MOVLW  00
0274:  MOVWF  01
0276:  MOVF   FC1,W
0278:  ANDLW  F8
027A:  IORWF  01,W
027C:  MOVWF  FC1
....................        IR_ADC_flag++; 
027E:  MOVLB  0
0280:  INCF   xF2,F
....................      } 
....................      else 
0282:  BRA    02C4
....................      { 
....................        set_adc_channel(IR_AN_Table[ IR_Counter ]);                              // Set the analog input to next sensor 
0284:  CLRF   03
0286:  MOVF   xF1,W
0288:  ADDLW  F3
028A:  MOVWF  FE9
028C:  MOVLW  00
028E:  ADDWFC 03,W
0290:  MOVWF  FEA
0292:  MOVFF  FEF,201
0296:  MOVLB  2
0298:  RLCF   x01,W
029A:  MOVWF  00
029C:  RLCF   00,F
029E:  MOVLW  FC
02A0:  ANDWF  00,F
02A2:  MOVF   FC2,W
02A4:  ANDLW  83
02A6:  IORWF  00,W
02A8:  MOVWF  FC2
02AA:  MOVLW  00
02AC:  MOVWF  01
02AE:  MOVF   FC1,W
02B0:  ANDLW  F8
02B2:  IORWF  01,W
02B4:  MOVWF  FC1
....................        delay_us(2); 
02B6:  MOVLW  02
02B8:  MOVWF  00
02BA:  DECFSZ 00,F
02BC:  BRA    02BA
02BE:  NOP   
....................        read_adc(ADC_START_ONLY);                                                // Start the new conversion 
02C0:  BSF    FC2.1
02C2:  MOVLB  0
....................      } 
....................    } 
....................    // Read distance value of the first group 
....................    else if(IR_ADC_flag == 3) 
02C4:  BRA    09DE
02C6:  MOVF   xF2,W
02C8:  SUBLW  03
02CA:  BTFSS  FD8.2
02CC:  BRA    051A
....................    { 
....................      IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] = read_adc(ADC_READ_ONLY);    // Read the Distance 
02CE:  CLRF   03
02D0:  MOVF   xF1,W
02D2:  ADDLW  F3
02D4:  MOVWF  FE9
02D6:  MOVLW  00
02D8:  ADDWFC 03,W
02DA:  MOVWF  FEA
02DC:  BCF    FD8.0
02DE:  RLCF   FEF,W
02E0:  CLRF   03
02E2:  ADDLW  D9
02E4:  MOVWF  FE9
02E6:  MOVLW  00
02E8:  ADDWFC 03,W
02EA:  MOVWF  FEA
02EC:  BTFSC  FC2.1
02EE:  BRA    02EC
02F0:  MOVFF  FC3,FEF
02F4:  MOVFF  FC4,FEC
....................      IR_Temp_Proximity[ IR_AN_Table[ IR_Counter ]] = abs(IR_light[IR_AN_Table[ IR_Counter ]] - IR_Temp_Proximity[ IR_AN_Table[ IR_Counter ] ]); // Substract the proximity to the ambiant value to obtain the correct distance value 
02F8:  CLRF   03
02FA:  MOVF   xF1,W
02FC:  ADDLW  F3
02FE:  MOVWF  FE9
0300:  MOVLW  00
0302:  ADDWFC 03,W
0304:  MOVWF  FEA
0306:  BCF    FD8.0
0308:  RLCF   FEF,W
030A:  CLRF   03
030C:  ADDLW  D9
030E:  MOVWF  01
0310:  MOVLW  00
0312:  ADDWFC 03,F
0314:  MOVFF  01,201
0318:  MOVLB  2
031A:  MOVFF  03,202
031E:  CLRF   03
0320:  MOVLB  0
0322:  MOVF   xF1,W
0324:  ADDLW  F3
0326:  MOVWF  FE9
0328:  MOVLW  00
032A:  ADDWFC 03,W
032C:  MOVWF  FEA
032E:  BCF    FD8.0
0330:  RLCF   FEF,W
0332:  CLRF   03
0334:  ADDLW  91
0336:  MOVWF  FE9
0338:  MOVLW  00
033A:  ADDWFC 03,W
033C:  MOVWF  FEA
033E:  MOVFF  FEC,204
0342:  MOVF   FED,F
0344:  MOVFF  FEF,203
0348:  CLRF   03
034A:  MOVF   xF1,W
034C:  ADDLW  F3
034E:  MOVWF  FE9
0350:  MOVLW  00
0352:  ADDWFC 03,W
0354:  MOVWF  FEA
0356:  BCF    FD8.0
0358:  RLCF   FEF,W
035A:  CLRF   03
035C:  ADDLW  D9
035E:  MOVWF  FE9
0360:  MOVLW  00
0362:  ADDWFC 03,W
0364:  MOVWF  FEA
0366:  MOVFF  FEC,03
036A:  MOVF   FED,F
036C:  MOVF   FEF,W
036E:  MOVLB  2
0370:  SUBWF  x03,F
0372:  MOVF   03,W
0374:  SUBWFB x04,F
0376:  MOVFF  204,03
037A:  MOVF   x03,W
037C:  BTFSS  x04.7
037E:  BRA    0390
0380:  MOVLW  00
0382:  BSF    FD8.0
0384:  SUBFWB x03,W
0386:  MOVWF  00
0388:  MOVLW  00
038A:  SUBFWB x04,W
038C:  MOVWF  03
038E:  MOVF   00,W
0390:  MOVFF  202,FEA
0394:  MOVFF  201,FE9
0398:  MOVFF  03,FEC
039C:  MOVF   FED,F
039E:  MOVWF  FEF
....................      if(IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] < IR_Calibrate[IR_AN_Table[ IR_Counter ]])  // Check if the value is greater than the calibrated value 
03A0:  CLRF   03
03A2:  MOVLB  0
03A4:  MOVF   xF1,W
03A6:  ADDLW  F3
03A8:  MOVWF  FE9
03AA:  MOVLW  00
03AC:  ADDWFC 03,W
03AE:  MOVWF  FEA
03B0:  BCF    FD8.0
03B2:  RLCF   FEF,W
03B4:  CLRF   03
03B6:  ADDLW  D9
03B8:  MOVWF  FE9
03BA:  MOVLW  00
03BC:  ADDWFC 03,W
03BE:  MOVWF  FEA
03C0:  MOVFF  FEC,202
03C4:  MOVF   FED,F
03C6:  MOVFF  FEF,201
03CA:  CLRF   03
03CC:  MOVF   xF1,W
03CE:  ADDLW  F3
03D0:  MOVWF  FE9
03D2:  MOVLW  00
03D4:  ADDWFC 03,W
03D6:  MOVWF  FEA
03D8:  BCF    FD8.0
03DA:  RLCF   FEF,W
03DC:  CLRF   03
03DE:  ADDLW  C1
03E0:  MOVWF  FE9
03E2:  MOVLW  00
03E4:  ADDWFC 03,W
03E6:  MOVWF  FEA
03E8:  MOVFF  FEC,03
03EC:  MOVF   FED,F
03EE:  MOVFF  FEF,01
03F2:  MOVLB  2
03F4:  BTFSS  x02.7
03F6:  BRA    03FE
03F8:  BTFSS  03.7
03FA:  BRA    0410
03FC:  BRA    0402
03FE:  BTFSC  03.7
0400:  BRA    043A
0402:  MOVF   x02,W
0404:  SUBWF  03,W
0406:  BNC   043A
0408:  BNZ   0410
040A:  MOVF   01,W
040C:  SUBWF  x01,W
040E:  BC    043A
....................        IR_Proximity[IR_AN_Table[ IR_Counter ]] = 0; 
0410:  CLRF   03
0412:  MOVLB  0
0414:  MOVF   xF1,W
0416:  ADDLW  F3
0418:  MOVWF  FE9
041A:  MOVLW  00
041C:  ADDWFC 03,W
041E:  MOVWF  FEA
0420:  BCF    FD8.0
0422:  RLCF   FEF,W
0424:  CLRF   03
0426:  ADDLW  A9
0428:  MOVWF  FE9
042A:  MOVLW  00
042C:  ADDWFC 03,W
042E:  MOVWF  FEA
0430:  CLRF   FEC
0432:  MOVF   FED,F
0434:  CLRF   FEF
....................      else 
0436:  BRA    04CA
0438:  MOVLB  2
....................        IR_Proximity[IR_AN_Table[ IR_Counter ]] = IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] - IR_Calibrate[IR_AN_Table[ IR_Counter ]]; 
043A:  CLRF   03
043C:  MOVLB  0
043E:  MOVF   xF1,W
0440:  ADDLW  F3
0442:  MOVWF  FE9
0444:  MOVLW  00
0446:  ADDWFC 03,W
0448:  MOVWF  FEA
044A:  BCF    FD8.0
044C:  RLCF   FEF,W
044E:  CLRF   03
0450:  ADDLW  A9
0452:  MOVWF  01
0454:  MOVLW  00
0456:  ADDWFC 03,F
0458:  MOVLB  2
045A:  MOVFF  03,202
045E:  CLRF   03
0460:  MOVLB  0
0462:  MOVF   xF1,W
0464:  ADDLW  F3
0466:  MOVWF  FE9
0468:  MOVLW  00
046A:  ADDWFC 03,W
046C:  MOVWF  FEA
046E:  BCF    FD8.0
0470:  RLCF   FEF,W
0472:  CLRF   03
0474:  ADDLW  D9
0476:  MOVWF  FE9
0478:  MOVLW  00
047A:  ADDWFC 03,W
047C:  MOVWF  FEA
047E:  MOVFF  FEC,204
0482:  MOVF   FED,F
0484:  MOVFF  FEF,203
0488:  CLRF   03
048A:  MOVF   xF1,W
048C:  ADDLW  F3
048E:  MOVWF  FE9
0490:  MOVLW  00
0492:  ADDWFC 03,W
0494:  MOVWF  FEA
0496:  BCF    FD8.0
0498:  RLCF   FEF,W
049A:  CLRF   03
049C:  ADDLW  C1
049E:  MOVWF  FE9
04A0:  MOVLW  00
04A2:  ADDWFC 03,W
04A4:  MOVWF  FEA
04A6:  MOVFF  FEC,03
04AA:  MOVF   FED,F
04AC:  MOVF   FEF,W
04AE:  MOVLB  2
04B0:  SUBWF  x03,W
04B2:  MOVWF  00
04B4:  MOVF   03,W
04B6:  SUBWFB x04,W
04B8:  MOVFF  202,FEA
04BC:  MOVFF  01,FE9
04C0:  MOVWF  FEC
04C2:  MOVF   FED,F
04C4:  MOVFF  00,FEF
04C8:  MOVLB  0
....................      IR_Counter++; 
04CA:  INCF   xF1,F
....................      set_adc_channel(IR_AN_Table[ IR_Counter ]);                                 // Set the analog input to next sensor 
04CC:  CLRF   03
04CE:  MOVF   xF1,W
04D0:  ADDLW  F3
04D2:  MOVWF  FE9
04D4:  MOVLW  00
04D6:  ADDWFC 03,W
04D8:  MOVWF  FEA
04DA:  MOVFF  FEF,201
04DE:  MOVLB  2
04E0:  RLCF   x01,W
04E2:  MOVWF  00
04E4:  RLCF   00,F
04E6:  MOVLW  FC
04E8:  ANDWF  00,F
04EA:  MOVF   FC2,W
04EC:  ANDLW  83
04EE:  IORWF  00,W
04F0:  MOVWF  FC2
04F2:  MOVLW  00
04F4:  MOVWF  01
04F6:  MOVF   FC1,W
04F8:  ANDLW  F8
04FA:  IORWF  01,W
04FC:  MOVWF  FC1
....................      delay_us(2); 
04FE:  MOVLW  02
0500:  MOVWF  00
0502:  DECFSZ 00,F
0504:  BRA    0502
0506:  NOP   
....................     if(IR_Counter > 2) 
0508:  MOVLB  0
050A:  MOVF   xF1,W
050C:  SUBLW  02
050E:  BC    0516
....................     { 
....................       output_low(IR_GROUP1);                                                    // Turn off the IR emitter of the first Group 
0510:  BCF    F8C.1
....................       IR_ADC_flag++; 
0512:  INCF   xF2,F
....................     } 
....................     else 
0514:  BRA    0518
....................       read_adc(ADC_START_ONLY);                                                 // Start the new conversion 
0516:  BSF    FC2.1
....................  
....................    
....................    } 
....................    // Read distance value of the second group 
....................    else if(IR_ADC_flag == 5) 
0518:  BRA    09DE
051A:  MOVF   xF2,W
051C:  SUBLW  05
051E:  BTFSS  FD8.2
0520:  BRA    076E
....................    { 
....................       IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] = read_adc(ADC_READ_ONLY);    // Read the Distance 
0522:  CLRF   03
0524:  MOVF   xF1,W
0526:  ADDLW  F3
0528:  MOVWF  FE9
052A:  MOVLW  00
052C:  ADDWFC 03,W
052E:  MOVWF  FEA
0530:  BCF    FD8.0
0532:  RLCF   FEF,W
0534:  CLRF   03
0536:  ADDLW  D9
0538:  MOVWF  FE9
053A:  MOVLW  00
053C:  ADDWFC 03,W
053E:  MOVWF  FEA
0540:  BTFSC  FC2.1
0542:  BRA    0540
0544:  MOVFF  FC3,FEF
0548:  MOVFF  FC4,FEC
....................      IR_Temp_Proximity[ IR_AN_Table[ IR_Counter ]] = abs(IR_light[IR_AN_Table[ IR_Counter ]] - IR_Temp_Proximity[ IR_AN_Table[ IR_Counter ] ]); // Substract the proximity to the ambiant value to obtain the correct distance value 
054C:  CLRF   03
054E:  MOVF   xF1,W
0550:  ADDLW  F3
0552:  MOVWF  FE9
0554:  MOVLW  00
0556:  ADDWFC 03,W
0558:  MOVWF  FEA
055A:  BCF    FD8.0
055C:  RLCF   FEF,W
055E:  CLRF   03
0560:  ADDLW  D9
0562:  MOVWF  01
0564:  MOVLW  00
0566:  ADDWFC 03,F
0568:  MOVFF  01,201
056C:  MOVLB  2
056E:  MOVFF  03,202
0572:  CLRF   03
0574:  MOVLB  0
0576:  MOVF   xF1,W
0578:  ADDLW  F3
057A:  MOVWF  FE9
057C:  MOVLW  00
057E:  ADDWFC 03,W
0580:  MOVWF  FEA
0582:  BCF    FD8.0
0584:  RLCF   FEF,W
0586:  CLRF   03
0588:  ADDLW  91
058A:  MOVWF  FE9
058C:  MOVLW  00
058E:  ADDWFC 03,W
0590:  MOVWF  FEA
0592:  MOVFF  FEC,204
0596:  MOVF   FED,F
0598:  MOVFF  FEF,203
059C:  CLRF   03
059E:  MOVF   xF1,W
05A0:  ADDLW  F3
05A2:  MOVWF  FE9
05A4:  MOVLW  00
05A6:  ADDWFC 03,W
05A8:  MOVWF  FEA
05AA:  BCF    FD8.0
05AC:  RLCF   FEF,W
05AE:  CLRF   03
05B0:  ADDLW  D9
05B2:  MOVWF  FE9
05B4:  MOVLW  00
05B6:  ADDWFC 03,W
05B8:  MOVWF  FEA
05BA:  MOVFF  FEC,03
05BE:  MOVF   FED,F
05C0:  MOVF   FEF,W
05C2:  MOVLB  2
05C4:  SUBWF  x03,F
05C6:  MOVF   03,W
05C8:  SUBWFB x04,F
05CA:  MOVFF  204,03
05CE:  MOVF   x03,W
05D0:  BTFSS  x04.7
05D2:  BRA    05E4
05D4:  MOVLW  00
05D6:  BSF    FD8.0
05D8:  SUBFWB x03,W
05DA:  MOVWF  00
05DC:  MOVLW  00
05DE:  SUBFWB x04,W
05E0:  MOVWF  03
05E2:  MOVF   00,W
05E4:  MOVFF  202,FEA
05E8:  MOVFF  201,FE9
05EC:  MOVFF  03,FEC
05F0:  MOVF   FED,F
05F2:  MOVWF  FEF
....................      if(IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] < IR_Calibrate[IR_AN_Table[ IR_Counter ]])  // Check if the value is greater than the calibrated value 
05F4:  CLRF   03
05F6:  MOVLB  0
05F8:  MOVF   xF1,W
05FA:  ADDLW  F3
05FC:  MOVWF  FE9
05FE:  MOVLW  00
0600:  ADDWFC 03,W
0602:  MOVWF  FEA
0604:  BCF    FD8.0
0606:  RLCF   FEF,W
0608:  CLRF   03
060A:  ADDLW  D9
060C:  MOVWF  FE9
060E:  MOVLW  00
0610:  ADDWFC 03,W
0612:  MOVWF  FEA
0614:  MOVFF  FEC,202
0618:  MOVF   FED,F
061A:  MOVFF  FEF,201
061E:  CLRF   03
0620:  MOVF   xF1,W
0622:  ADDLW  F3
0624:  MOVWF  FE9
0626:  MOVLW  00
0628:  ADDWFC 03,W
062A:  MOVWF  FEA
062C:  BCF    FD8.0
062E:  RLCF   FEF,W
0630:  CLRF   03
0632:  ADDLW  C1
0634:  MOVWF  FE9
0636:  MOVLW  00
0638:  ADDWFC 03,W
063A:  MOVWF  FEA
063C:  MOVFF  FEC,03
0640:  MOVF   FED,F
0642:  MOVFF  FEF,01
0646:  MOVLB  2
0648:  BTFSS  x02.7
064A:  BRA    0652
064C:  BTFSS  03.7
064E:  BRA    0664
0650:  BRA    0656
0652:  BTFSC  03.7
0654:  BRA    068E
0656:  MOVF   x02,W
0658:  SUBWF  03,W
065A:  BNC   068E
065C:  BNZ   0664
065E:  MOVF   01,W
0660:  SUBWF  x01,W
0662:  BC    068E
....................        IR_Proximity[IR_AN_Table[ IR_Counter ]] = 0; 
0664:  CLRF   03
0666:  MOVLB  0
0668:  MOVF   xF1,W
066A:  ADDLW  F3
066C:  MOVWF  FE9
066E:  MOVLW  00
0670:  ADDWFC 03,W
0672:  MOVWF  FEA
0674:  BCF    FD8.0
0676:  RLCF   FEF,W
0678:  CLRF   03
067A:  ADDLW  A9
067C:  MOVWF  FE9
067E:  MOVLW  00
0680:  ADDWFC 03,W
0682:  MOVWF  FEA
0684:  CLRF   FEC
0686:  MOVF   FED,F
0688:  CLRF   FEF
....................      else 
068A:  BRA    071E
068C:  MOVLB  2
....................        IR_Proximity[IR_AN_Table[ IR_Counter ]] = IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] - IR_Calibrate[IR_AN_Table[ IR_Counter ]]; 
068E:  CLRF   03
0690:  MOVLB  0
0692:  MOVF   xF1,W
0694:  ADDLW  F3
0696:  MOVWF  FE9
0698:  MOVLW  00
069A:  ADDWFC 03,W
069C:  MOVWF  FEA
069E:  BCF    FD8.0
06A0:  RLCF   FEF,W
06A2:  CLRF   03
06A4:  ADDLW  A9
06A6:  MOVWF  01
06A8:  MOVLW  00
06AA:  ADDWFC 03,F
06AC:  MOVLB  2
06AE:  MOVFF  03,202
06B2:  CLRF   03
06B4:  MOVLB  0
06B6:  MOVF   xF1,W
06B8:  ADDLW  F3
06BA:  MOVWF  FE9
06BC:  MOVLW  00
06BE:  ADDWFC 03,W
06C0:  MOVWF  FEA
06C2:  BCF    FD8.0
06C4:  RLCF   FEF,W
06C6:  CLRF   03
06C8:  ADDLW  D9
06CA:  MOVWF  FE9
06CC:  MOVLW  00
06CE:  ADDWFC 03,W
06D0:  MOVWF  FEA
06D2:  MOVFF  FEC,204
06D6:  MOVF   FED,F
06D8:  MOVFF  FEF,203
06DC:  CLRF   03
06DE:  MOVF   xF1,W
06E0:  ADDLW  F3
06E2:  MOVWF  FE9
06E4:  MOVLW  00
06E6:  ADDWFC 03,W
06E8:  MOVWF  FEA
06EA:  BCF    FD8.0
06EC:  RLCF   FEF,W
06EE:  CLRF   03
06F0:  ADDLW  C1
06F2:  MOVWF  FE9
06F4:  MOVLW  00
06F6:  ADDWFC 03,W
06F8:  MOVWF  FEA
06FA:  MOVFF  FEC,03
06FE:  MOVF   FED,F
0700:  MOVF   FEF,W
0702:  MOVLB  2
0704:  SUBWF  x03,W
0706:  MOVWF  00
0708:  MOVF   03,W
070A:  SUBWFB x04,W
070C:  MOVFF  202,FEA
0710:  MOVFF  01,FE9
0714:  MOVWF  FEC
0716:  MOVF   FED,F
0718:  MOVFF  00,FEF
071C:  MOVLB  0
....................       IR_Counter++; 
071E:  INCF   xF1,F
....................       set_adc_channel(IR_AN_Table[ IR_Counter ]);                                 // Set the analog input to next sensor 
0720:  CLRF   03
0722:  MOVF   xF1,W
0724:  ADDLW  F3
0726:  MOVWF  FE9
0728:  MOVLW  00
072A:  ADDWFC 03,W
072C:  MOVWF  FEA
072E:  MOVFF  FEF,201
0732:  MOVLB  2
0734:  RLCF   x01,W
0736:  MOVWF  00
0738:  RLCF   00,F
073A:  MOVLW  FC
073C:  ANDWF  00,F
073E:  MOVF   FC2,W
0740:  ANDLW  83
0742:  IORWF  00,W
0744:  MOVWF  FC2
0746:  MOVLW  00
0748:  MOVWF  01
074A:  MOVF   FC1,W
074C:  ANDLW  F8
074E:  IORWF  01,W
0750:  MOVWF  FC1
....................       delay_us(2); 
0752:  MOVLW  02
0754:  MOVWF  00
0756:  DECFSZ 00,F
0758:  BRA    0756
075A:  NOP   
....................       if(IR_Counter > 5) 
075C:  MOVLB  0
075E:  MOVF   xF1,W
0760:  SUBLW  05
0762:  BC    076A
....................       { 
....................         output_low(IR_GROUP2);                                                    // Turn off the IR emitter of the second Group 
0764:  BCF    F8C.2
....................         IR_ADC_flag++; 
0766:  INCF   xF2,F
....................       } 
....................       else 
0768:  BRA    076C
....................         read_adc(ADC_START_ONLY);                                                 // Start the new conversion 
076A:  BSF    FC2.1
....................    } 
....................    // Read distance value of the third group 
....................    else if(IR_ADC_flag == 7) 
076C:  BRA    09DE
076E:  MOVF   xF2,W
0770:  SUBLW  07
0772:  BTFSS  FD8.2
0774:  BRA    09DE
....................    { 
....................     IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] = read_adc(ADC_READ_ONLY);    // Read the Distance 
0776:  CLRF   03
0778:  MOVF   xF1,W
077A:  ADDLW  F3
077C:  MOVWF  FE9
077E:  MOVLW  00
0780:  ADDWFC 03,W
0782:  MOVWF  FEA
0784:  BCF    FD8.0
0786:  RLCF   FEF,W
0788:  CLRF   03
078A:  ADDLW  D9
078C:  MOVWF  FE9
078E:  MOVLW  00
0790:  ADDWFC 03,W
0792:  MOVWF  FEA
0794:  BTFSC  FC2.1
0796:  BRA    0794
0798:  MOVFF  FC3,FEF
079C:  MOVFF  FC4,FEC
....................      IR_Temp_Proximity[ IR_AN_Table[ IR_Counter ]] = abs(IR_light[IR_AN_Table[ IR_Counter ]] - IR_Temp_Proximity[ IR_AN_Table[ IR_Counter ] ]); // Substract the proximity to the ambiant value to obtain the correct distance value 
07A0:  CLRF   03
07A2:  MOVF   xF1,W
07A4:  ADDLW  F3
07A6:  MOVWF  FE9
07A8:  MOVLW  00
07AA:  ADDWFC 03,W
07AC:  MOVWF  FEA
07AE:  BCF    FD8.0
07B0:  RLCF   FEF,W
07B2:  CLRF   03
07B4:  ADDLW  D9
07B6:  MOVWF  01
07B8:  MOVLW  00
07BA:  ADDWFC 03,F
07BC:  MOVFF  01,201
07C0:  MOVLB  2
07C2:  MOVFF  03,202
07C6:  CLRF   03
07C8:  MOVLB  0
07CA:  MOVF   xF1,W
07CC:  ADDLW  F3
07CE:  MOVWF  FE9
07D0:  MOVLW  00
07D2:  ADDWFC 03,W
07D4:  MOVWF  FEA
07D6:  BCF    FD8.0
07D8:  RLCF   FEF,W
07DA:  CLRF   03
07DC:  ADDLW  91
07DE:  MOVWF  FE9
07E0:  MOVLW  00
07E2:  ADDWFC 03,W
07E4:  MOVWF  FEA
07E6:  MOVFF  FEC,204
07EA:  MOVF   FED,F
07EC:  MOVFF  FEF,203
07F0:  CLRF   03
07F2:  MOVF   xF1,W
07F4:  ADDLW  F3
07F6:  MOVWF  FE9
07F8:  MOVLW  00
07FA:  ADDWFC 03,W
07FC:  MOVWF  FEA
07FE:  BCF    FD8.0
0800:  RLCF   FEF,W
0802:  CLRF   03
0804:  ADDLW  D9
0806:  MOVWF  FE9
0808:  MOVLW  00
080A:  ADDWFC 03,W
080C:  MOVWF  FEA
080E:  MOVFF  FEC,03
0812:  MOVF   FED,F
0814:  MOVF   FEF,W
0816:  MOVLB  2
0818:  SUBWF  x03,F
081A:  MOVF   03,W
081C:  SUBWFB x04,F
081E:  MOVFF  204,03
0822:  MOVF   x03,W
0824:  BTFSS  x04.7
0826:  BRA    0838
0828:  MOVLW  00
082A:  BSF    FD8.0
082C:  SUBFWB x03,W
082E:  MOVWF  00
0830:  MOVLW  00
0832:  SUBFWB x04,W
0834:  MOVWF  03
0836:  MOVF   00,W
0838:  MOVFF  202,FEA
083C:  MOVFF  201,FE9
0840:  MOVFF  03,FEC
0844:  MOVF   FED,F
0846:  MOVWF  FEF
....................      if(IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] < IR_Calibrate[IR_AN_Table[ IR_Counter ]])  // Check if the value is greater than the calibrated value 
0848:  CLRF   03
084A:  MOVLB  0
084C:  MOVF   xF1,W
084E:  ADDLW  F3
0850:  MOVWF  FE9
0852:  MOVLW  00
0854:  ADDWFC 03,W
0856:  MOVWF  FEA
0858:  BCF    FD8.0
085A:  RLCF   FEF,W
085C:  CLRF   03
085E:  ADDLW  D9
0860:  MOVWF  FE9
0862:  MOVLW  00
0864:  ADDWFC 03,W
0866:  MOVWF  FEA
0868:  MOVFF  FEC,202
086C:  MOVF   FED,F
086E:  MOVFF  FEF,201
0872:  CLRF   03
0874:  MOVF   xF1,W
0876:  ADDLW  F3
0878:  MOVWF  FE9
087A:  MOVLW  00
087C:  ADDWFC 03,W
087E:  MOVWF  FEA
0880:  BCF    FD8.0
0882:  RLCF   FEF,W
0884:  CLRF   03
0886:  ADDLW  C1
0888:  MOVWF  FE9
088A:  MOVLW  00
088C:  ADDWFC 03,W
088E:  MOVWF  FEA
0890:  MOVFF  FEC,03
0894:  MOVF   FED,F
0896:  MOVFF  FEF,01
089A:  MOVLB  2
089C:  BTFSS  x02.7
089E:  BRA    08A6
08A0:  BTFSS  03.7
08A2:  BRA    08B8
08A4:  BRA    08AA
08A6:  BTFSC  03.7
08A8:  BRA    08E2
08AA:  MOVF   x02,W
08AC:  SUBWF  03,W
08AE:  BNC   08E2
08B0:  BNZ   08B8
08B2:  MOVF   01,W
08B4:  SUBWF  x01,W
08B6:  BC    08E2
....................        IR_Proximity[IR_AN_Table[ IR_Counter ]] = 0; 
08B8:  CLRF   03
08BA:  MOVLB  0
08BC:  MOVF   xF1,W
08BE:  ADDLW  F3
08C0:  MOVWF  FE9
08C2:  MOVLW  00
08C4:  ADDWFC 03,W
08C6:  MOVWF  FEA
08C8:  BCF    FD8.0
08CA:  RLCF   FEF,W
08CC:  CLRF   03
08CE:  ADDLW  A9
08D0:  MOVWF  FE9
08D2:  MOVLW  00
08D4:  ADDWFC 03,W
08D6:  MOVWF  FEA
08D8:  CLRF   FEC
08DA:  MOVF   FED,F
08DC:  CLRF   FEF
....................      else 
08DE:  BRA    0972
08E0:  MOVLB  2
....................        IR_Proximity[IR_AN_Table[ IR_Counter ]] = IR_Temp_Proximity[IR_AN_Table[ IR_Counter ]] - IR_Calibrate[IR_AN_Table[ IR_Counter ]]; 
08E2:  CLRF   03
08E4:  MOVLB  0
08E6:  MOVF   xF1,W
08E8:  ADDLW  F3
08EA:  MOVWF  FE9
08EC:  MOVLW  00
08EE:  ADDWFC 03,W
08F0:  MOVWF  FEA
08F2:  BCF    FD8.0
08F4:  RLCF   FEF,W
08F6:  CLRF   03
08F8:  ADDLW  A9
08FA:  MOVWF  01
08FC:  MOVLW  00
08FE:  ADDWFC 03,F
0900:  MOVLB  2
0902:  MOVFF  03,202
0906:  CLRF   03
0908:  MOVLB  0
090A:  MOVF   xF1,W
090C:  ADDLW  F3
090E:  MOVWF  FE9
0910:  MOVLW  00
0912:  ADDWFC 03,W
0914:  MOVWF  FEA
0916:  BCF    FD8.0
0918:  RLCF   FEF,W
091A:  CLRF   03
091C:  ADDLW  D9
091E:  MOVWF  FE9
0920:  MOVLW  00
0922:  ADDWFC 03,W
0924:  MOVWF  FEA
0926:  MOVFF  FEC,204
092A:  MOVF   FED,F
092C:  MOVFF  FEF,203
0930:  CLRF   03
0932:  MOVF   xF1,W
0934:  ADDLW  F3
0936:  MOVWF  FE9
0938:  MOVLW  00
093A:  ADDWFC 03,W
093C:  MOVWF  FEA
093E:  BCF    FD8.0
0940:  RLCF   FEF,W
0942:  CLRF   03
0944:  ADDLW  C1
0946:  MOVWF  FE9
0948:  MOVLW  00
094A:  ADDWFC 03,W
094C:  MOVWF  FEA
094E:  MOVFF  FEC,03
0952:  MOVF   FED,F
0954:  MOVF   FEF,W
0956:  MOVLB  2
0958:  SUBWF  x03,W
095A:  MOVWF  00
095C:  MOVF   03,W
095E:  SUBWFB x04,W
0960:  MOVFF  202,FEA
0964:  MOVFF  01,FE9
0968:  MOVWF  FEC
096A:  MOVF   FED,F
096C:  MOVFF  00,FEF
0970:  MOVLB  0
....................     IR_Counter++; 
0972:  INCF   xF1,F
....................     set_adc_channel(IR_AN_Table[ IR_Counter ]);                                 // Set the analog input to next sensor 
0974:  CLRF   03
0976:  MOVF   xF1,W
0978:  ADDLW  F3
097A:  MOVWF  FE9
097C:  MOVLW  00
097E:  ADDWFC 03,W
0980:  MOVWF  FEA
0982:  MOVFF  FEF,201
0986:  MOVLB  2
0988:  RLCF   x01,W
098A:  MOVWF  00
098C:  RLCF   00,F
098E:  MOVLW  FC
0990:  ANDWF  00,F
0992:  MOVF   FC2,W
0994:  ANDLW  83
0996:  IORWF  00,W
0998:  MOVWF  FC2
099A:  MOVLW  00
099C:  MOVWF  01
099E:  MOVF   FC1,W
09A0:  ANDLW  F8
09A2:  IORWF  01,W
09A4:  MOVWF  FC1
....................     delay_us(2); 
09A6:  MOVLW  02
09A8:  MOVWF  00
09AA:  DECFSZ 00,F
09AC:  BRA    09AA
09AE:  NOP   
....................     if(IR_Counter > 9) 
09B0:  MOVLB  0
09B2:  MOVF   xF1,W
09B4:  SUBLW  09
09B6:  BC    09DC
....................     { 
....................       output_low(IR_GROUP3);                                                    // Turn off the IR emitter of the third Group 
09B8:  BCF    F8C.3
....................       IR_Counter = 0; 
09BA:  CLRF   xF1
....................       Sensors_Refreshed_Flag = 1;                                               // Set the flag to indicate that all the sensor was refresh 
09BC:  BSF    22.5
....................       Manual_Refresh_sensors = 0;                                               // reset the manual refresh flag, to refresh only one time    
09BE:  BCF    x88.4
....................       IR_ADC_flag++; 
09C0:  INCF   xF2,F
....................       set_adc_channel(VBAT_AN);                                                 // Set the analog input to measure the battery voltage 
09C2:  MOVLW  18
09C4:  MOVWF  01
09C6:  MOVF   FC2,W
09C8:  ANDLW  83
09CA:  IORWF  01,W
09CC:  MOVWF  FC2
09CE:  MOVLW  00
09D0:  MOVWF  01
09D2:  MOVF   FC1,W
09D4:  ANDLW  F8
09D6:  IORWF  01,W
09D8:  MOVWF  FC1
....................     } 
....................     else 
09DA:  BRA    09DE
....................       read_adc(ADC_START_ONLY);                                                 // Start the new conversion 
09DC:  BSF    FC2.1
09DE:  MOVLB  2
....................    } 
....................  
.................... } 
....................  
....................  
.................... //-----------------------------------------------------------// 
.................... //                  Internal Interrupts                     -// 
....................  
....................  
09E0:  BCF    F9E.6
09E2:  MOVLB  0
09E4:  GOTO   00A8
.................... #INT_TIMER1 
.................... void Sheduler_Interrupt(void)                                                   // Internal Task Manager, Interrupt every 250 us 
.................... { 
....................     
....................    set_timer1(TIMER1_VALUE+get_timer1());                                       // set default value to get an interrupt each 250us 
*
0BAA:  MOVF   FCE,W
0BAC:  MOVFF  FCF,03
0BB0:  ADDLW  49
0BB2:  MOVLB  2
0BB4:  MOVWF  x01
0BB6:  MOVLW  FC
0BB8:  ADDWFC FCF,W
0BBA:  MOVWF  FCF
0BBC:  MOVFF  201,FCE
....................  
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Time Function                                                                -// 
.................... //--------------------------------------------------------------------------------//   
....................    if(++TimeTipDivider >= 4) 
0BC0:  MOVLB  0
0BC2:  INCF   x8E,F
0BC4:  MOVF   x8E,W
0BC6:  SUBLW  03
0BC8:  BC    0C30
....................    { 
....................       TimeTipDivider = 0; 
0BCA:  CLRF   x8E
....................       TimeTip++;                                                                // TimeTip incremented every 1 ms (counter up to 4294967296 ms = 1193 hours ...) 
0BCC:  MOVLW  01
0BCE:  ADDWF  x8A,F
0BD0:  BTFSC  FD8.0
0BD2:  INCF   x8B,F
0BD4:  BTFSC  FD8.2
0BD6:  INCF   x8C,F
0BD8:  BTFSC  FD8.2
0BDA:  INCF   x8D,F
....................       if(MotorTime > 0)                                                         // If the motor must be stopped after n ms 
0BDC:  MOVF   x8F,F
0BDE:  BZ    0BF4
....................       { 
....................         if(++MotorTimeDivider >= 100)                                           // each unit is 10ms 
0BE0:  INCF   x90,F
0BE2:  MOVF   x90,W
0BE4:  SUBLW  63
0BE6:  BC    0BF4
....................         { 
....................           MotorTimeDivider = 0; 
0BE8:  CLRF   x90
....................           if(--MotorTime == 0)                                                  // If the time reach its end 
0BEA:  DECFSZ x8F,F
0BEC:  BRA    0BF4
....................           { 
....................            PwmMotRight = 0;                                                     // Stop the motor 
0BEE:  CLRF   1B
....................            PwmMotLeft = 0; 
0BF0:  CLRF   1A
....................            Motor_Conversion();                                                   
0BF2:  RCALL  0B7E
....................           } 
....................          
....................         } 
....................        
....................       } 
....................       if(Acceleration_Timer != 0)                                               // If an acceleration is in progress 
0BF4:  MOVF   20,F
0BF6:  BZ    0C04
....................       { 
....................         if(--Acceleration_Timer == 0)                                           // Decrement the timer untill it reach 0 
0BF8:  DECFSZ 20,F
0BFA:  BRA    0C04
....................         { 
....................          set_pwm1_duty(TimerMotRight);                                          // Reset the desired value of the two motors 
0BFC:  MOVFF  1F,FBC
....................          set_pwm3_duty(TimerMotLeft);  
0C00:  MOVFF  1E,F4A
....................         } 
....................       } 
....................        
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Read the value of the mode switches all the ms                               -// 
.................... //--------------------------------------------------------------------------------// 
....................       Switchs  =   !input(MODE1);        // MODE1 
0C04:  MOVLB  1
0C06:  CLRF   x01
0C08:  BTFSS  F82.0
0C0A:  INCF   x01,F
....................       Switchs |= ((!input(MODE2))<<1);   // MODE2 
0C0C:  MOVLW  00
0C0E:  BTFSS  F82.1
0C10:  MOVLW  01
0C12:  MOVWF  00
0C14:  BCF    FD8.0
0C16:  RLCF   00,F
0C18:  MOVF   00,W
0C1A:  IORWF  x01,F
....................       Switchs |= ((!input(MODE3))<<2);   // MODE3 
0C1C:  MOVLW  00
0C1E:  BTFSS  F82.2
0C20:  MOVLW  01
0C22:  MOVWF  00
0C24:  RLCF   00,F
0C26:  RLCF   00,F
0C28:  MOVLW  FC
0C2A:  ANDWF  00,F
0C2C:  MOVF   00,W
0C2E:  IORWF  x01,F
....................    } 
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- manage the Auto mode of the LED, each LED is ON during 100ms                 -// 
.................... //--------------------------------------------------------------------------------// 
....................    if(LED_mode != 0)                                                            // If one of the LED is in auto mode 
0C30:  MOVLB  1
0C32:  MOVF   x02,F
0C34:  BTFSC  FD8.2
0C36:  BRA    0CF6
....................    { 
....................       switch(LED_Counter) 
....................       { 
0C38:  MOVF   x03,W
0C3A:  MOVWF  00
0C3C:  MOVF   x04,W
0C3E:  MOVWF  03
0C40:  MOVF   03,W
0C42:  BNZ   0C4C
0C44:  MOVF   00,F
0C46:  MOVLB  0
0C48:  BZ    0C8E
0C4A:  MOVLB  1
0C4C:  MOVLW  01
0C4E:  SUBWF  03,W
0C50:  BNZ   0C5C
0C52:  MOVLW  F4
0C54:  SUBWF  00,W
0C56:  MOVLB  0
0C58:  BZ    0C9E
0C5A:  MOVLB  1
0C5C:  MOVLW  03
0C5E:  SUBWF  03,W
0C60:  BNZ   0C6C
0C62:  MOVLW  E8
0C64:  SUBWF  00,W
0C66:  MOVLB  0
0C68:  BZ    0CAE
0C6A:  MOVLB  1
0C6C:  MOVLW  05
0C6E:  SUBWF  03,W
0C70:  BNZ   0C7C
0C72:  MOVLW  DC
0C74:  SUBWF  00,W
0C76:  MOVLB  0
0C78:  BZ    0CBE
0C7A:  MOVLB  1
0C7C:  MOVLW  07
0C7E:  SUBWF  03,W
0C80:  BNZ   0C8C
0C82:  MOVLW  D0
0C84:  SUBWF  00,W
0C86:  MOVLB  0
0C88:  BZ    0CCE
0C8A:  MOVLB  1
0C8C:  BRA    0CDC
....................          case 0: 
....................             if(LED_mode & 0x10)                                                 // Check if the LED4 is in auto mode 
0C8E:  MOVLB  1
0C90:  BTFSS  x02.4
0C92:  BRA    0C96
....................                output_low(LED4);                                                // Turn OFF the LED4          
0C94:  BCF    F8A.5
....................             if(LED_mode & 0x01)                                                 // Check if the LED0 is in auto mode 
0C96:  BTFSS  x02.0
0C98:  BRA    0C9C
....................                output_high(LED0);                                               // Turn ON the LED0 
0C9A:  BSF    F8A.1
....................             break; 
0C9C:  BRA    0CDC
....................          case 500: 
....................             if(LED_mode & 0x01)                                                 // Check if the LED0 is in auto mode 
0C9E:  MOVLB  1
0CA0:  BTFSS  x02.0
0CA2:  BRA    0CA6
....................                output_low(LED0);                                                // Turn OFF the LED0 
0CA4:  BCF    F8A.1
....................             if(LED_mode &0x02)                                                  // Check if the LED1 is in auto mode 
0CA6:  BTFSS  x02.1
0CA8:  BRA    0CAC
....................                output_high(LED1);                                               // then turn ON the LED1 
0CAA:  BSF    F8A.2
....................             break; 
0CAC:  BRA    0CDC
....................          case 1000: 
....................             if(LED_mode & 0x02)                                                 // Check if the LED1 is in auto mode 
0CAE:  MOVLB  1
0CB0:  BTFSS  x02.1
0CB2:  BRA    0CB6
....................                output_low(LED1);                                                // Turn OFF the LED1 
0CB4:  BCF    F8A.2
....................             if(LED_mode &0x04)                                                  // Check if the LED2 is in auto mode 
0CB6:  BTFSS  x02.2
0CB8:  BRA    0CBC
....................                output_high(LED2);                                               // then turn ON the LED2 
0CBA:  BSF    F8A.3
....................             break;          
0CBC:  BRA    0CDC
....................          case 1500: 
....................             if(LED_mode & 0x04)                                                 // Check if the LED2is in auto mode 
0CBE:  MOVLB  1
0CC0:  BTFSS  x02.2
0CC2:  BRA    0CC6
....................                output_low(LED2);                                                // Turn OFF the LED2 
0CC4:  BCF    F8A.3
....................             if(LED_mode &0x08)                                                  // Check if the LED3is in auto mode 
0CC6:  BTFSS  x02.3
0CC8:  BRA    0CCC
....................                output_high(LED3);                                               // then turn ON the LED3 
0CCA:  BSF    F8A.4
....................             break;     
0CCC:  BRA    0CDC
....................          case 2000: 
....................             if(LED_mode & 0x08)                                                 // Check if the LED2is in auto mode 
0CCE:  MOVLB  1
0CD0:  BTFSS  x02.3
0CD2:  BRA    0CD6
....................                output_low(LED3);                                                // Turn OFF the LED2 
0CD4:  BCF    F8A.4
....................             if(LED_mode &0x10)                                                  // Check if the LED3is in auto mode 
0CD6:  BTFSS  x02.4
0CD8:  BRA    0CDC
....................                output_high(LED4);                                               // then turn ON the LED3 
0CDA:  BSF    F8A.5
....................             break;              
....................       } 
....................       if(++LED_Counter >= 2499) 
0CDC:  INCF   x03,F
0CDE:  BTFSC  FD8.2
0CE0:  INCF   x04,F
0CE2:  MOVF   x04,W
0CE4:  SUBLW  08
0CE6:  BC    0CF6
0CE8:  XORLW  FF
0CEA:  BNZ   0CF2
0CEC:  MOVF   x03,W
0CEE:  SUBLW  C2
0CF0:  BC    0CF6
....................          LED_Counter = 0; 
0CF2:  CLRF   x04
0CF4:  CLRF   x03
....................     
....................    } 
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- IR Sensor Management  (10ms to refresh all the IR sensor)                    -// 
.................... //--------------------------------------------------------------------------------//      
....................   
....................  if( (Auto_Refresh_Sensors == 1) || (Manual_Refresh_sensors == 1) ) 
0CF6:  BTFSC  22.0
0CF8:  BRA    0D02
0CFA:  MOVLB  0
0CFC:  BTFSS  x88.4
0CFE:  BRA    0D60
0D00:  MOVLB  1
....................  { 
....................        // Read the battery voltage 
....................       if(IR_ADC_Flag == 0) 
0D02:  MOVLB  0
0D04:  MOVF   xF2,F
0D06:  BNZ   0D0C
....................       { 
....................          read_adc(ADC_START_ONLY);                                              // read the analog value of the proximity 
0D08:  BSF    FC2.1
....................       } 
....................       // Read ambiant value 
....................       else if(IR_ADC_Flag == 1) 
0D0A:  BRA    0D60
0D0C:  DECFSZ xF2,W
0D0E:  BRA    0D14
....................       { 
....................          read_adc(ADC_START_ONLY);                                              // Start the AD conversion to read the whole ambiant light value 
0D10:  BSF    FC2.1
....................       } 
....................       // Turn on the IR emitter 
....................       else if(IR_ADC_Flag == 2) 
0D12:  BRA    0D60
0D14:  MOVF   xF2,W
0D16:  SUBLW  02
0D18:  BNZ   0D20
....................       { 
....................          IR_ADC_Flag++;   
0D1A:  INCF   xF2,F
....................          output_high(IR_GROUP1);                                                // Turn on the IR emitter of Group1 
0D1C:  BSF    F8C.1
....................           
....................       }       
....................       // Read proximity value of the first group 
....................       else if(IR_ADC_Flag == 3) 
0D1E:  BRA    0D60
0D20:  MOVF   xF2,W
0D22:  SUBLW  03
0D24:  BNZ   0D2A
....................       { 
....................          read_adc(ADC_START_ONLY);                                              // read the analog value of the proximity 
0D26:  BSF    FC2.1
....................       } 
....................       // Turn on the IR emitter 
....................       else if(IR_ADC_Flag == 4) 
0D28:  BRA    0D60
0D2A:  MOVF   xF2,W
0D2C:  SUBLW  04
0D2E:  BNZ   0D36
....................       { 
....................          IR_ADC_Flag++;   
0D30:  INCF   xF2,F
....................          output_high(IR_GROUP2);                                                // Turn on the IR emitter of Group2 
0D32:  BSF    F8C.2
....................           
....................       }       
....................       // Read proximity value of the second group 
....................       else if(IR_ADC_Flag == 5) 
0D34:  BRA    0D60
0D36:  MOVF   xF2,W
0D38:  SUBLW  05
0D3A:  BNZ   0D40
....................       { 
....................          read_adc(ADC_START_ONLY);                                              // read the analog value of the proximity 
0D3C:  BSF    FC2.1
....................       } 
....................       // Turn on the IR emitter 
....................       else if(IR_ADC_Flag == 6) 
0D3E:  BRA    0D60
0D40:  MOVF   xF2,W
0D42:  SUBLW  06
0D44:  BNZ   0D4C
....................       { 
....................          IR_ADC_Flag++;   
0D46:  INCF   xF2,F
....................          output_high(IR_GROUP3);                                                // Turn on the IR emitter of Group3 
0D48:  BSF    F8C.3
....................           
....................       }       
....................       // Read proximity value of the third group 
....................       else if(IR_ADC_Flag == 7) 
0D4A:  BRA    0D60
0D4C:  MOVF   xF2,W
0D4E:  SUBLW  07
0D50:  BNZ   0D56
....................       { 
....................          read_adc(ADC_START_ONLY);                                              // read the analog value of the proximity 
0D52:  BSF    FC2.1
....................       } 
....................  
....................  
....................       else 
0D54:  BRA    0D60
....................       { 
....................          if(++IR_ADC_Flag > 40)                                                 // Restart the refresh of the IR sensor 
0D56:  INCF   xF2,F
0D58:  MOVF   xF2,W
0D5A:  SUBLW  28
0D5C:  BC    0D60
....................            IR_ADC_Flag = 0; 
0D5E:  CLRF   xF2
....................       } 
....................  
....................    } 
.................... } 
....................  
0D60:  BCF    F9E.0
0D62:  GOTO   00A8
.................... #INT_TIMER3 
.................... void Buzzer_Interrupt(void)                                                     // Buzzer interrupt 
.................... { 
....................   set_timer3(Buzzer_Timer+ get_timer3());                                       // Set the timer to match the frequency note 
0D66:  MOVF   FB2,W
0D68:  MOVFF  FB3,03
0D6C:  MOVLB  1
0D6E:  ADDWF  x06,W
0D70:  MOVLB  2
0D72:  MOVWF  x01
0D74:  MOVF   FB3,W
0D76:  MOVLB  1
0D78:  ADDWFC x07,W
0D7A:  MOVLB  2
0D7C:  MOVWF  FB3
0D7E:  MOVFF  201,FB2
....................   output_bit(BUZZER,!input(BUZZER));                                            // Toggle the buzzer output 
0D82:  BTFSS  F84.2
0D84:  BRA    0D8A
0D86:  BCF    F8D.2
0D88:  BRA    0D8C
0D8A:  BSF    F8D.2
.................... } 
....................  
0D8C:  BCF    FA1.1
0D8E:  MOVLB  0
0D90:  GOTO   00A8
.................... #INT_EXT 
.................... void TV_Remote_Interrupt(void) 
.................... { 
....................    if( Auto_Refresh_TV_Remote == 1 )                                            // Only if the Auto refresh TV flag is set 
0D94:  BTFSS  22.1
0D96:  BRA    0DC2
....................    { 
....................        TV_Counter=0;                                                            // Reset the TV Counter 
0D98:  CLRF   x85
....................        TV_table[TV_Counter] = !input(IR_IN);                                    // read the first start bit, invert it to match with the modulation of the receiver 
0D9A:  CLRF   03
0D9C:  MOVF   x85,W
0D9E:  ADDLW  75
0DA0:  MOVWF  FE9
0DA2:  MOVLW  00
0DA4:  ADDWFC 03,W
0DA6:  MOVWF  FEA
0DA8:  MOVLW  00
0DAA:  BTFSS  F81.0
0DAC:  MOVLW  01
0DAE:  MOVWF  FEF
....................        disable_interrupts(INT_EXT); 
0DB0:  BCF    FF2.4
....................        setup_timer_0(T0_DIV_1  | T0_INTERNAL );                                 // The first time is longer to read on the End of the coding 
0DB2:  MOVLW  88
0DB4:  MOVWF  FD5
....................        set_timer0(TIMER0_2100); 
0DB6:  MOVLW  DF
0DB8:  MOVWF  FD7
0DBA:  MOVLW  2F
0DBC:  MOVWF  FD6
....................        enable_interrupts(INT_TIMER0);   
0DBE:  BSF    FF2.5
....................        TV_Data_pending = 1;                                                     // Indicate that a reception of a TV Data is in progress 
0DC0:  BSF    x88.0
....................    } 
....................     
.................... } 
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Modulate at 36 kHz with 50 duty-cycle                                        -// 
.................... //--------------------------------------------------------------------------------// 
0DC2:  BCF    FF2.1
0DC4:  GOTO   00A8
.................... void KJunior_IR_Send32x(void) 
.................... { 
*
0E62:  MOVLB  2
0E64:  CLRF   x02
....................  unsigned int i = 0; 
....................   
....................  for (i=0;i<32;i++) 
0E66:  CLRF   x02
0E68:  MOVF   x02,W
0E6A:  SUBLW  1F
0E6C:  BNC   0E88
....................   { 
....................    output_bit(IR_OUT,1); 
0E6E:  BSF    F8C.4
....................    delay_us(13);                                                                 // This value was choose to match exactly with the rc5 timing 
0E70:  MOVLW  11
0E72:  MOVWF  00
0E74:  DECFSZ 00,F
0E76:  BRA    0E74
....................    output_bit(IR_OUT,0); 
0E78:  BCF    F8C.4
....................    delay_us(12);                                                                 // This value was choose to match exactly with the rc5 timing 
0E7A:  MOVLW  0F
0E7C:  MOVWF  00
0E7E:  DECFSZ 00,F
0E80:  BRA    0E7E
0E82:  BRA    0E84
....................   } 
0E84:  INCF   x02,F
0E86:  BRA    0E68
.................... } 
0E88:  MOVLB  0
0E8A:  RETURN 0
....................  
....................  
.................... #INT_TIMER0 
.................... void RC5_Decoding_Interrupt(void) 
.................... { 
0E8C:  MOVLB  2
0E8E:  BCF    x01.0
....................    int1 RC5_Bit = 0; 
....................    if(TV_Data_pending == 1)                                                     // Verify if a data is coming on the receiver, or ... 
0E90:  MOVLB  0
0E92:  BTFSS  x88.0
0E94:  BRA    0F80
....................    { 
....................       set_timer0(TIMER0_1780+get_timer0());                                     // Interrupt every 1.780 ms 
0E96:  MOVF   FD6,W
0E98:  MOVFF  FD7,03
0E9C:  ADDLW  2F
0E9E:  MOVLB  2
0EA0:  MOVWF  x02
0EA2:  MOVLW  E4
0EA4:  ADDWFC FD7,W
0EA6:  MOVWF  FD7
0EA8:  MOVFF  202,FD6
....................       if(++TV_Counter <= 13) 
0EAC:  MOVLB  0
0EAE:  INCF   x85,F
0EB0:  MOVF   x85,W
0EB2:  SUBLW  0D
0EB4:  BNC   0ECE
....................       { 
....................          TV_Table[TV_Counter] = !input(IR_IN);                                  // Read the bit of the manchester coding 
0EB6:  CLRF   03
0EB8:  MOVF   x85,W
0EBA:  ADDLW  75
0EBC:  MOVWF  FE9
0EBE:  MOVLW  00
0EC0:  ADDWFC 03,W
0EC2:  MOVWF  FEA
0EC4:  MOVLW  00
0EC6:  BTFSS  F81.0
0EC8:  MOVLW  01
0ECA:  MOVWF  FEF
....................       } 
....................       else 
0ECC:  BRA    0F7E
....................       { 
....................          if(TV_Table[StartBit1] == 1 && TV_Table[StartBit2] == 1)               // Verify that the two start bit are correct (value must be 1) 
0ECE:  DECFSZ x75,W
0ED0:  BRA    0F74
0ED2:  DECFSZ x76,W
0ED4:  BRA    0F74
....................          { 
....................             // If correct, save the data and address of the receiveing command 
....................             TV_RX_Toggle_Bit = TV_Table[ToggleBit]; 
0ED6:  MOVFF  77,89
....................             TV_ADDR = (TV_Table[AddrBit4] << 4) |(TV_Table[AddrBit3] << 3) | (TV_Table[AddrBit2] << 2) | (TV_Table[AddrBit1] << 1) | (TV_Table[AddrBit0]); 
0EDA:  SWAPF  x78,W
0EDC:  MOVLB  2
0EDE:  MOVWF  x02
0EE0:  MOVLW  F0
0EE2:  ANDWF  x02,F
0EE4:  MOVLB  0
0EE6:  RLCF   x79,W
0EE8:  MOVWF  00
0EEA:  RLCF   00,F
0EEC:  RLCF   00,F
0EEE:  MOVLW  F8
0EF0:  ANDWF  00,F
0EF2:  MOVF   00,W
0EF4:  MOVLB  2
0EF6:  IORWF  x02,F
0EF8:  MOVLB  0
0EFA:  RLCF   x7A,W
0EFC:  MOVWF  00
0EFE:  RLCF   00,F
0F00:  MOVLW  FC
0F02:  ANDWF  00,F
0F04:  MOVF   00,W
0F06:  MOVLB  2
0F08:  IORWF  x02,F
0F0A:  BCF    FD8.0
0F0C:  MOVLB  0
0F0E:  RLCF   x7B,W
0F10:  MOVLB  2
0F12:  IORWF  x02,W
0F14:  MOVLB  0
0F16:  IORWF  x7C,W
0F18:  MOVWF  x83
....................             TV_DATA = (TV_Table[DataBit5] << 5) | (TV_Table[DataBit4] << 4) | (TV_Table[DataBit3] << 3) | (TV_Table[DataBit2] << 2) | (TV_Table[DataBit1] << 1) | (TV_Table[DataBit0]); 
0F1A:  SWAPF  x7D,W
0F1C:  MOVLB  2
0F1E:  MOVWF  x02
0F20:  RLCF   x02,F
0F22:  MOVLW  E0
0F24:  ANDWF  x02,F
0F26:  MOVLB  0
0F28:  SWAPF  x7E,W
0F2A:  MOVWF  00
0F2C:  MOVLW  F0
0F2E:  ANDWF  00,F
0F30:  MOVF   00,W
0F32:  MOVLB  2
0F34:  IORWF  x02,F
0F36:  MOVLB  0
0F38:  RLCF   x7F,W
0F3A:  MOVWF  00
0F3C:  RLCF   00,F
0F3E:  RLCF   00,F
0F40:  MOVLW  F8
0F42:  ANDWF  00,F
0F44:  MOVF   00,W
0F46:  MOVLB  2
0F48:  IORWF  x02,F
0F4A:  MOVLB  0
0F4C:  RLCF   x80,W
0F4E:  MOVWF  00
0F50:  RLCF   00,F
0F52:  MOVLW  FC
0F54:  ANDWF  00,F
0F56:  MOVF   00,W
0F58:  MOVLB  2
0F5A:  IORWF  x02,F
0F5C:  BCF    FD8.0
0F5E:  MOVLB  0
0F60:  RLCF   x81,W
0F62:  MOVLB  2
0F64:  IORWF  x02,W
0F66:  MOVLB  0
0F68:  IORWF  x82,W
0F6A:  MOVWF  x84
....................             TV_DATA_Available = 1;                                              // Set the flag to know that a TV data is available 
0F6C:  BSF    22.7
....................             if(Enable_TV_Remote_Control == 1)                                   // If the control remote is activate 
0F6E:  BTFSS  22.3
0F70:  BRA    0F74
....................                TV_Remote_Control();                                             // Set the speed for each motor 
0F72:  BRA    0DC8
....................          } 
....................          enable_interrupts(INT_EXT);                                            // Enable the external interrupt after receiving a complete data 
0F74:  BSF    FF2.4
....................          disable_interrupts(INT_TIMER0);                                        // Disable the timer 0 interrupt 
0F76:  BCF    FF2.5
....................          setup_timer_0(RTCC_OFF);                                               // stop the timer0 
0F78:  CLRF   FD5
....................          bit_clear(INTCON,1);                                                   // Clear the INTF bit to avoid a interrupt on the RB port 
0F7A:  BCF    FF2.1
....................          TV_Data_pending = 0;                                                   // Clear the flag to indicate that the data is completely received 
0F7C:  BCF    x88.0
....................       } 
....................    } 
....................    else if(TV_Data_emitting == 1)                                               // .. if a data must be send on the emitter 
0F7E:  BRA    10A0
0F80:  BTFSS  x88.1
0F82:  BRA    1098
....................    { 
....................       set_timer0(TIMER0_886 + get_timer0());                                    // Interrupt every 886 us    
0F84:  MOVF   FD6,W
0F86:  MOVFF  FD7,03
0F8A:  ADDLW  27
0F8C:  MOVLB  2
0F8E:  MOVWF  x02
0F90:  MOVLW  F2
0F92:  ADDWFC FD7,W
0F94:  MOVWF  FD7
0F96:  MOVFF  202,FD6
....................       do 
....................       { 
....................          TV_Data_loop = 0;                                                      // reset the flag, the loop can be done only one times 
0F9A:  MOVLB  0
0F9C:  BCF    x88.2
....................          if(TV_Counter < 2)                                                     // the first 2 bits are always 1 (start bit) 
0F9E:  MOVF   x85,W
0FA0:  SUBLW  01
0FA2:  BNC   0FAC
....................             RC5_Bit = 1; 
0FA4:  MOVLB  2
0FA6:  BSF    x01.0
....................          else if(TV_Counter == 2)                                               // Toggle bit 
0FA8:  BRA    103E
0FAA:  MOVLB  0
0FAC:  MOVF   x85,W
0FAE:  SUBLW  02
0FB0:  BNZ   0FC4
....................             RC5_Bit = TV_TX_Toggle_Bit; 
0FB2:  MOVLB  2
0FB4:  BCF    x01.0
0FB6:  MOVLB  0
0FB8:  BTFSS  x88.3
0FBA:  BRA    0FC2
0FBC:  MOVLB  2
0FBE:  BSF    x01.0
0FC0:  MOVLB  0
....................          else if(TV_Counter > 13)                                               // if all the bits are send,  
0FC2:  BRA    1040
0FC4:  MOVF   x85,W
0FC6:  SUBLW  0D
0FC8:  BC    0FE2
....................          { 
....................             TV_Data_emitting = 0;                                               // Stop the emitting 
0FCA:  BCF    x88.1
....................             TV_TX_Toggle_Bit = !TV_TX_Toggle_Bit;                               // Change the toggle Bit for the next emitting 
0FCC:  BTG    x88.3
....................             enable_interrupts(INT_EXT);                                         // Enable the external interrupt after emitting a complete rc5 code 
0FCE:  BSF    FF2.4
....................             disable_interrupts(INT_TIMER0);                                     // Disable the timer 0 interrupt 
0FD0:  BCF    FF2.5
....................             setup_timer_0(RTCC_OFF);                                            // stop the timer0 
0FD2:  CLRF   FD5
....................             enable_interrupts(INT_TIMER1); 
0FD4:  BSF    F9D.0
....................             bit_clear(INTCON,1);                                                // Clear the INTF bit to avoid a interrupt on the RB port 
0FD6:  BCF    FF2.1
....................             TV_Counter_flag = 0;                                                // Set the flag and the rc5 bit to ensure the output will be down 
0FD8:  BCF    22.6
....................             RC5_Bit = 1;                                                           
0FDA:  MOVLB  2
0FDC:  BSF    x01.0
....................          } 
....................          else if((TV_Counter > 8) && (TV_Counter <= 13))                        // The last 6 bits are the Data 
0FDE:  BRA    103E
0FE0:  MOVLB  0
0FE2:  MOVF   x85,W
0FE4:  SUBLW  08
0FE6:  BC    1018
0FE8:  MOVF   x85,W
0FEA:  SUBLW  0D
0FEC:  BNC   1018
....................          { 
....................             if(TV_Data_send & (0x20 >> (TV_Counter - 8)))                       // Mask the Data to keep only the bit to send 
0FEE:  MOVLW  08
0FF0:  SUBWF  x85,W
0FF2:  MOVWF  01
0FF4:  MOVLW  20
0FF6:  MOVWF  00
0FF8:  MOVF   01,F
0FFA:  BZ    1004
0FFC:  BCF    FD8.0
0FFE:  RRCF   00,F
1000:  DECFSZ 01,F
1002:  BRA    0FFC
1004:  MOVF   00,W
1006:  ANDWF  x86,W
1008:  BZ    1010
....................                RC5_Bit = 1 ;                  
100A:  MOVLB  2
100C:  BSF    x01.0
....................             else  
100E:  BRA    1014
....................                RC5_Bit = 0;          
1010:  MOVLB  2
1012:  BCF    x01.0
....................          } 
....................          else                                                                   // Address Bits 
1014:  BRA    103E
1016:  MOVLB  0
....................          { 
....................             if(TV_Addr_send & (0x10 >> (TV_Counter - 3)))                       // Mask the Data to keep only the bit to send 
1018:  MOVLW  03
101A:  SUBWF  x85,W
101C:  MOVWF  01
101E:  MOVLW  10
1020:  MOVWF  00
1022:  MOVF   01,F
1024:  BZ    102E
1026:  BCF    FD8.0
1028:  RRCF   00,F
102A:  DECFSZ 01,F
102C:  BRA    1026
102E:  MOVF   00,W
1030:  ANDWF  x87,W
1032:  BZ    103A
....................                RC5_Bit = 1 ;                  
1034:  MOVLB  2
1036:  BSF    x01.0
....................             else  
1038:  BRA    103E
....................                RC5_Bit = 0;          
103A:  MOVLB  2
103C:  BCF    x01.0
103E:  MOVLB  0
....................          }       
....................          if((TV_Counter_flag == 0) && (RC5_bit == 0))                           // First phase of bit = 0 
1040:  BTFSC  22.6
1042:  BRA    1062
1044:  MOVLB  2
1046:  BTFSS  x01.0
1048:  BRA    104E
104A:  MOVLB  0
104C:  BRA    1062
....................          { 
....................             KJunior_IR_Send32x();                                               // Modulate the bit at 36kHz to send on the emitter 
104E:  MOVLB  0
1050:  RCALL  0E62
....................             TV_Counter_flag = 0;                                                // Clear the flag to go to the next bit,   
1052:  BCF    22.6
....................             TV_Counter++;                                                       // No need to make a second phase 
1054:  INCF   x85,F
....................             set_timer0(TIMER0_886);                                             // reset the timer0 to have a proper time 
1056:  MOVLW  F2
1058:  MOVWF  FD7
105A:  MOVLW  27
105C:  MOVWF  FD6
....................             bit_clear(PIR1,1);                                                  // clear the flag of the Timer2 interrupt 
105E:  BCF    F9E.1
....................          } 
....................          else if((TV_Counter_flag == 1) && (RC5_bit == 1))                      // Second phase when a bit is = 1 
1060:  BRA    1092
1062:  BTFSS  22.6
1064:  BRA    1086
1066:  MOVLB  2
1068:  BTFSC  x01.0
106A:  BRA    1070
106C:  MOVLB  0
106E:  BRA    1086
....................          { 
....................             KJunior_IR_Send32x();                                               // Modulate the bit at 36kHz to send on the emitter 
1070:  MOVLB  0
1072:  RCALL  0E62
....................             TV_Counter++;                                                       // Increment the Counter to send the next bit 
1074:  INCF   x85,F
....................             TV_Counter_flag = 0;  
1076:  BCF    22.6
....................             TV_Data_loop = 1; 
1078:  BSF    x88.2
....................             set_timer0(TIMER0_886);                                             // reset the timer0 to have a proper time 
107A:  MOVLW  F2
107C:  MOVWF  FD7
107E:  MOVLW  27
1080:  MOVWF  FD6
....................             bit_clear(PIR1,1);                                                  // clear the flag of the Timer2 interrupt          
1082:  BCF    F9E.1
....................          } 
....................          else 
1084:  BRA    1092
....................          { 
....................             TV_Counter += TV_Counter_Flag;                                      // If the flag is set (second phase) increment the counter 
1086:  MOVLW  00
1088:  BTFSC  22.6
108A:  MOVLW  01
108C:  ADDWF  x85,F
....................             TV_Counter_flag = !TV_Counter_flag;                                 // Change phase of bit 
108E:  BTG    22.6
....................             output_low(IR_OUT);                                                 // Clear the IR output 
1090:  BCF    F8C.4
....................           
....................          } 
....................        
....................       }while(TV_Data_loop == 1);                                                // loop to manage the case when a 1 is following by a zero (emitting two times with no interruption) 
1092:  BTFSC  x88.2
1094:  BRA    0F9C
....................    } 
....................    else                                                                         // Otherwise  
1096:  BRA    10A0
....................    { 
....................       enable_interrupts(INT_EXT);                                               // Enable the external interrupt  
1098:  BSF    FF2.4
....................       disable_interrupts(INT_TIMER0);                                           // Disable the timer 0 interrupt 
109A:  BCF    FF2.5
....................       setup_timer_0(RTCC_OFF);                                                  // stop the timer0 
109C:  CLRF   FD5
....................       bit_clear(INTCON,1);                                                      // Clear the INTF bit to avoid a interrupt on the RB port 
109E:  BCF    FF2.1
....................  
....................    } 
....................     
.................... } 
....................  
10A0:  BCF    FF2.2
10A2:  GOTO   00A8
.................... void __default() 
.................... { 
....................   if(SerialPort == SERIAL_USB) 
*
4712:  MOVF   x74,F
4714:  BNZ   4724
....................    fprintf(USB, "Unknown Command ?!\r\n" ); 
4716:  MOVLW  A6
4718:  MOVWF  FF6
471A:  MOVLW  10
471C:  MOVWF  FF7
471E:  CALL   141C
....................   else 
4722:  BRA    4730
....................    fprintf(BT, "Unknown Command ?!\r\n" ); 
4724:  MOVLW  BC
4726:  MOVWF  FF6
4728:  MOVLW  10
472A:  MOVWF  FF7
472C:  CALL   1552
.................... } 
4730:  GOTO   49D4 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Reset the KJunior uC                                                         -// 
.................... //--------------------------------------------------------------------------------//   
.................... void __Z() 
.................... { 
....................   if(SerialPort == SERIAL_USB) 
*
46D2:  MOVF   x74,F
46D4:  BNZ   46F0
....................    fprintf(USB,"z\r\n"); 
46D6:  MOVLW  7A
46D8:  BTFSS  F9E.4
46DA:  BRA    46D8
46DC:  MOVWF  FAD
46DE:  MOVLW  0D
46E0:  BTFSS  F9E.4
46E2:  BRA    46E0
46E4:  MOVWF  FAD
46E6:  MOVLW  0A
46E8:  BTFSS  F9E.4
46EA:  BRA    46E8
46EC:  MOVWF  FAD
....................   else 
46EE:  BRA    470C
....................    fprintf(BT,"z\r\n"); 
46F0:  MOVLW  7A
46F2:  BTFSS  FA4.4
46F4:  BRA    46F2
46F6:  MOVLB  F
46F8:  MOVWF  x1C
46FA:  MOVLW  0D
46FC:  BTFSS  FA4.4
46FE:  BRA    46FC
4700:  MOVWF  x1C
4702:  MOVLW  0A
4704:  BTFSS  FA4.4
4706:  BRA    4704
4708:  MOVWF  x1C
470A:  MOVLB  0
....................    
....................   reset_cpu(); 
470C:  RESET
.................... } 
470E:  GOTO   49D4 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Set the speed of the 2 motors during n second. Value are +/- 20 for the speed // 
.................... //  and 0-255 for the time (unit base is the ms)  
.................... //--------------------------------------------------------------------------------// 
.................... void __A(void) 
.................... { 
....................    unsigned char Arg[5]; 
....................    unsigned char i, j; 
....................    signed int8 MotG_temp; 
....................    i = 2;                                                                       // Begin with the 3 char (after the first ",") 
*
1D8E:  MOVLW  02
1D90:  MOVLB  1
1D92:  MOVWF  x99
....................    j = 0; 
1D94:  CLRF   x9A
....................    // While there no END of line "\n" or End of Char ",", place the value in a table to convert it  
....................    while((SerialBuffer[ i ] != ',') &&  (SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................    { 
1D96:  CLRF   03
1D98:  MOVF   x99,W
1D9A:  ADDLW  23
1D9C:  MOVWF  FE9
1D9E:  MOVLW  00
1DA0:  ADDWFC 03,W
1DA2:  MOVWF  FEA
1DA4:  MOVF   FEF,W
1DA6:  SUBLW  2C
1DA8:  BZ    1E06
1DAA:  CLRF   03
1DAC:  MOVF   x99,W
1DAE:  ADDLW  23
1DB0:  MOVWF  FE9
1DB2:  MOVLW  00
1DB4:  ADDWFC 03,W
1DB6:  MOVWF  FEA
1DB8:  MOVF   FEF,W
1DBA:  SUBLW  0A
1DBC:  BZ    1E06
1DBE:  CLRF   03
1DC0:  MOVF   x99,W
1DC2:  ADDLW  23
1DC4:  MOVWF  FE9
1DC6:  MOVLW  00
1DC8:  ADDWFC 03,W
1DCA:  MOVWF  FEA
1DCC:  MOVF   FEF,W
1DCE:  SUBLW  0D
1DD0:  BZ    1E06
....................       Arg[j] = SerialBuffer[ i ]; 
1DD2:  CLRF   03
1DD4:  MOVF   x9A,W
1DD6:  ADDLW  94
1DD8:  MOVWF  01
1DDA:  MOVLW  01
1DDC:  ADDWFC 03,F
1DDE:  MOVFF  03,19D
1DE2:  CLRF   03
1DE4:  MOVF   x99,W
1DE6:  ADDLW  23
1DE8:  MOVWF  FE9
1DEA:  MOVLW  00
1DEC:  ADDWFC 03,W
1DEE:  MOVWF  FEA
1DF0:  MOVFF  FEF,19E
1DF4:  MOVFF  19D,FEA
1DF8:  MOVFF  01,FE9
1DFC:  MOVFF  19E,FEF
....................       i++;      
1E00:  INCF   x99,F
....................       j++; 
1E02:  INCF   x9A,F
....................    } 
1E04:  BRA    1D96
....................    Arg[j] ='\0';                                                                // PLace a End of sentence at the end of the values 
1E06:  CLRF   03
1E08:  MOVF   x9A,W
1E0A:  ADDLW  94
1E0C:  MOVWF  FE9
1E0E:  MOVLW  01
1E10:  ADDWFC 03,W
1E12:  MOVWF  FEA
1E14:  CLRF   FEF
....................    MotG_Temp = atoi(Arg);                                                       // Convert the table of value into a signed int8 
1E16:  MOVLW  01
1E18:  MOVWF  x9D
1E1A:  MOVLW  94
1E1C:  MOVWF  x9C
1E1E:  MOVLB  0
1E20:  RCALL  1BDC
1E22:  MOVFF  01,19B
....................    if((SerialBuffer[ i ] == 10) || (SerialBuffer[ i ] == 13))                   // If the second argument is not set (i.e. "D,20\r\n") return a error 
1E26:  CLRF   03
1E28:  MOVLB  1
1E2A:  MOVF   x99,W
1E2C:  ADDLW  23
1E2E:  MOVWF  FE9
1E30:  MOVLW  00
1E32:  ADDWFC 03,W
1E34:  MOVWF  FEA
1E36:  MOVF   FEF,W
1E38:  SUBLW  0A
1E3A:  BZ    1E50
1E3C:  CLRF   03
1E3E:  MOVF   x99,W
1E40:  ADDLW  23
1E42:  MOVWF  FE9
1E44:  MOVLW  00
1E46:  ADDWFC 03,W
1E48:  MOVWF  FEA
1E4A:  MOVF   FEF,W
1E4C:  SUBLW  0D
1E4E:  BNZ   1E74
....................    { 
....................      if(SerialPort == SERIAL_USB) 
1E50:  MOVLB  0
1E52:  MOVF   x74,F
1E54:  BNZ   1E64
....................       fprintf(USB,"Unknown Command ?!\r\n" ); 
1E56:  MOVLW  D2
1E58:  MOVWF  FF6
1E5A:  MOVLW  10
1E5C:  MOVWF  FF7
1E5E:  CALL   141C
....................      else 
1E62:  BRA    1E70
....................       fprintf(BT,"Unknown Command ?!\r\n" ); 
1E64:  MOVLW  E8
1E66:  MOVWF  FF6
1E68:  MOVLW  10
1E6A:  MOVWF  FF7
1E6C:  CALL   1552
....................    } 
....................    else 
1E70:  BRA    205A
1E72:  MOVLB  1
....................    { 
....................       i++; 
1E74:  INCF   x99,F
....................       j = 0; 
1E76:  CLRF   x9A
....................       // While there no END of line "\n" place the value in a table to convert it  
....................       while((SerialBuffer[ i ] != ',') &&  (SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................       { 
1E78:  CLRF   03
1E7A:  MOVF   x99,W
1E7C:  ADDLW  23
1E7E:  MOVWF  FE9
1E80:  MOVLW  00
1E82:  ADDWFC 03,W
1E84:  MOVWF  FEA
1E86:  MOVF   FEF,W
1E88:  SUBLW  2C
1E8A:  BZ    1EE8
1E8C:  CLRF   03
1E8E:  MOVF   x99,W
1E90:  ADDLW  23
1E92:  MOVWF  FE9
1E94:  MOVLW  00
1E96:  ADDWFC 03,W
1E98:  MOVWF  FEA
1E9A:  MOVF   FEF,W
1E9C:  SUBLW  0A
1E9E:  BZ    1EE8
1EA0:  CLRF   03
1EA2:  MOVF   x99,W
1EA4:  ADDLW  23
1EA6:  MOVWF  FE9
1EA8:  MOVLW  00
1EAA:  ADDWFC 03,W
1EAC:  MOVWF  FEA
1EAE:  MOVF   FEF,W
1EB0:  SUBLW  0D
1EB2:  BZ    1EE8
....................          Arg[j] = SerialBuffer[ i ]; 
1EB4:  CLRF   03
1EB6:  MOVF   x9A,W
1EB8:  ADDLW  94
1EBA:  MOVWF  01
1EBC:  MOVLW  01
1EBE:  ADDWFC 03,F
1EC0:  MOVFF  03,19D
1EC4:  CLRF   03
1EC6:  MOVF   x99,W
1EC8:  ADDLW  23
1ECA:  MOVWF  FE9
1ECC:  MOVLW  00
1ECE:  ADDWFC 03,W
1ED0:  MOVWF  FEA
1ED2:  MOVFF  FEF,19E
1ED6:  MOVFF  19D,FEA
1EDA:  MOVFF  01,FE9
1EDE:  MOVFF  19E,FEF
....................          i++;      
1EE2:  INCF   x99,F
....................          j++; 
1EE4:  INCF   x9A,F
....................       } 
1EE6:  BRA    1E78
....................       Arg[j] ='\0';                                                             // PLace a End of sentence at the end of the values 
1EE8:  CLRF   03
1EEA:  MOVF   x9A,W
1EEC:  ADDLW  94
1EEE:  MOVWF  FE9
1EF0:  MOVLW  01
1EF2:  ADDWFC 03,W
1EF4:  MOVWF  FEA
1EF6:  CLRF   FEF
....................       if((SerialBuffer[ i ] == 10) || (SerialBuffer[ i ] == 13))                // If the second argument is not set (i.e. "D,20\r\n") return a error 
1EF8:  CLRF   03
1EFA:  MOVF   x99,W
1EFC:  ADDLW  23
1EFE:  MOVWF  FE9
1F00:  MOVLW  00
1F02:  ADDWFC 03,W
1F04:  MOVWF  FEA
1F06:  MOVF   FEF,W
1F08:  SUBLW  0A
1F0A:  BZ    1F20
1F0C:  CLRF   03
1F0E:  MOVF   x99,W
1F10:  ADDLW  23
1F12:  MOVWF  FE9
1F14:  MOVLW  00
1F16:  ADDWFC 03,W
1F18:  MOVWF  FEA
1F1A:  MOVF   FEF,W
1F1C:  SUBLW  0D
1F1E:  BNZ   1F44
....................       { 
....................         if(SerialPort == SERIAL_USB) 
1F20:  MOVLB  0
1F22:  MOVF   x74,F
1F24:  BNZ   1F34
....................           fprintf(USB,"Unknown Command ?!\r\n" ); 
1F26:  MOVLW  FE
1F28:  MOVWF  FF6
1F2A:  MOVLW  10
1F2C:  MOVWF  FF7
1F2E:  CALL   141C
....................         else 
1F32:  BRA    1F40
....................           fprintf(BT,"Unknown Command ?!\r\n" ); 
1F34:  MOVLW  14
1F36:  MOVWF  FF6
1F38:  MOVLW  11
1F3A:  MOVWF  FF7
1F3C:  CALL   1552
....................       } 
....................       else 
1F40:  BRA    205A
1F42:  MOVLB  1
....................       { 
....................         PwmMotLeft = MotG_Temp; 
1F44:  MOVFF  19B,1A
....................         PwmMotRight = atoi(Arg);   
1F48:  MOVLW  01
1F4A:  MOVWF  x9D
1F4C:  MOVLW  94
1F4E:  MOVWF  x9C
1F50:  MOVLB  0
1F52:  RCALL  1BDC
1F54:  MOVFF  01,1B
....................         i++; 
1F58:  MOVLB  1
1F5A:  INCF   x99,F
....................         j = 0; 
1F5C:  CLRF   x9A
....................         // While there no END of line "\n" place the value in a table to convert it  
....................         while((SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................         { 
1F5E:  CLRF   03
1F60:  MOVF   x99,W
1F62:  ADDLW  23
1F64:  MOVWF  FE9
1F66:  MOVLW  00
1F68:  ADDWFC 03,W
1F6A:  MOVWF  FEA
1F6C:  MOVF   FEF,W
1F6E:  SUBLW  0A
1F70:  BZ    1FBA
1F72:  CLRF   03
1F74:  MOVF   x99,W
1F76:  ADDLW  23
1F78:  MOVWF  FE9
1F7A:  MOVLW  00
1F7C:  ADDWFC 03,W
1F7E:  MOVWF  FEA
1F80:  MOVF   FEF,W
1F82:  SUBLW  0D
1F84:  BZ    1FBA
....................            Arg[j] = SerialBuffer[ i ]; 
1F86:  CLRF   03
1F88:  MOVF   x9A,W
1F8A:  ADDLW  94
1F8C:  MOVWF  01
1F8E:  MOVLW  01
1F90:  ADDWFC 03,F
1F92:  MOVFF  03,19D
1F96:  CLRF   03
1F98:  MOVF   x99,W
1F9A:  ADDLW  23
1F9C:  MOVWF  FE9
1F9E:  MOVLW  00
1FA0:  ADDWFC 03,W
1FA2:  MOVWF  FEA
1FA4:  MOVFF  FEF,19E
1FA8:  MOVFF  19D,FEA
1FAC:  MOVFF  01,FE9
1FB0:  MOVFF  19E,FEF
....................            i++;      
1FB4:  INCF   x99,F
....................            j++; 
1FB6:  INCF   x9A,F
....................         } 
1FB8:  BRA    1F5E
....................         Arg[j] ='\0';                                                           // PLace a End of sentence at the end of the values         
1FBA:  CLRF   03
1FBC:  MOVF   x9A,W
1FBE:  ADDLW  94
1FC0:  MOVWF  FE9
1FC2:  MOVLW  01
1FC4:  ADDWFC 03,W
1FC6:  MOVWF  FEA
1FC8:  CLRF   FEF
....................         if(PwmMotLeft >20)                                                      // Limit the minimum and maximum PWM value to -20 and 20 
1FCA:  BTFSC  1A.7
1FCC:  BRA    1FDA
1FCE:  MOVF   1A,W
1FD0:  SUBLW  14
1FD2:  BC    1FDA
....................            PwmMotLeft = 20; 
1FD4:  MOVLW  14
1FD6:  MOVWF  1A
....................         else if(PwmMotLeft < -20)  
1FD8:  BRA    1FE6
1FDA:  MOVF   1A,W
1FDC:  XORLW  80
1FDE:  SUBLW  6B
1FE0:  BNC   1FE6
....................            PwmMotLeft = -20; 
1FE2:  MOVLW  EC
1FE4:  MOVWF  1A
....................         if(PwmMotRight >20)                                                     // Limit the minimum and maximum PWM value to -20 and 20 
1FE6:  BTFSC  1B.7
1FE8:  BRA    1FF6
1FEA:  MOVF   1B,W
1FEC:  SUBLW  14
1FEE:  BC    1FF6
....................           PwmMotRight = 20; 
1FF0:  MOVLW  14
1FF2:  MOVWF  1B
....................         else if(PwmMotRight < -20)  
1FF4:  BRA    2002
1FF6:  MOVF   1B,W
1FF8:  XORLW  80
1FFA:  SUBLW  6B
1FFC:  BNC   2002
....................           PwmMotRight = -20;            
1FFE:  MOVLW  EC
2000:  MOVWF  1B
....................         MotorTime = atoi(Arg);                                                  // Convert the table of value into a unsigned char                
2002:  MOVLW  01
2004:  MOVWF  x9D
2006:  MOVLW  94
2008:  MOVWF  x9C
200A:  MOVLB  0
200C:  RCALL  1BDC
200E:  MOVFF  01,8F
2012:  CLRF   19
2014:  BTFSC  FF2.7
2016:  BSF    19.7
2018:  BCF    FF2.7
....................         Motor_Conversion();                                                     // Configure the PWM output 
201A:  CALL   0B7E
201E:  BTFSC  19.7
2020:  BSF    FF2.7
....................         if(SerialPort == SERIAL_USB) 
2022:  MOVF   x74,F
2024:  BNZ   2040
....................           fprintf(USB,"a\r\n");  
2026:  MOVLW  61
2028:  BTFSS  F9E.4
202A:  BRA    2028
202C:  MOVWF  FAD
202E:  MOVLW  0D
2030:  BTFSS  F9E.4
2032:  BRA    2030
2034:  MOVWF  FAD
2036:  MOVLW  0A
2038:  BTFSS  F9E.4
203A:  BRA    2038
203C:  MOVWF  FAD
....................         else 
203E:  BRA    205A
....................           fprintf(BT,"a\r\n");  
2040:  MOVLW  61
2042:  BTFSS  FA4.4
2044:  BRA    2042
2046:  MOVLB  F
2048:  MOVWF  x1C
204A:  MOVLW  0D
204C:  BTFSS  FA4.4
204E:  BRA    204C
2050:  MOVWF  x1C
2052:  MOVLW  0A
2054:  BTFSS  FA4.4
2056:  BRA    2054
2058:  MOVWF  x1C
205A:  MOVLB  0
....................       } 
....................        
....................    } 
.................... } 
205C:  GOTO   49D4 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Read the KJunior OS version and revision                                     -// 
.................... //--------------------------------------------------------------------------------//   
.................... void __B(void) 
.................... { 
....................   if(SerialPort == SERIAL_USB) 
2060:  MOVF   x74,F
2062:  BNZ   20A8
....................    fprintf(USB, "b,%s-%02d\r\n" , KJ_FW_VERSION,KJ_FW_REVISION ); 
2064:  MOVLW  62
2066:  BTFSS  F9E.4
2068:  BRA    2066
206A:  MOVWF  FAD
206C:  MOVLW  2C
206E:  BTFSS  F9E.4
2070:  BRA    206E
2072:  MOVWF  FAD
2074:  MOVLW  2A
2076:  MOVWF  FF6
2078:  MOVLW  11
207A:  MOVWF  FF7
207C:  CALL   141C
2080:  MOVLW  2D
2082:  BTFSS  F9E.4
2084:  BRA    2082
2086:  MOVWF  FAD
2088:  MOVLW  01
208A:  MOVLB  1
208C:  MOVWF  x95
208E:  MOVWF  x96
2090:  MOVLB  0
2092:  CALL   1494
2096:  MOVLW  0D
2098:  BTFSS  F9E.4
209A:  BRA    2098
209C:  MOVWF  FAD
209E:  MOVLW  0A
20A0:  BTFSS  F9E.4
20A2:  BRA    20A0
20A4:  MOVWF  FAD
....................   else 
20A6:  BRA    20F2
....................    fprintf(BT, "b,%s-%02d\r\n" , KJ_FW_VERSION,KJ_FW_REVISION ); 
20A8:  MOVLW  62
20AA:  BTFSS  FA4.4
20AC:  BRA    20AA
20AE:  MOVLB  F
20B0:  MOVWF  x1C
20B2:  MOVLW  2C
20B4:  BTFSS  FA4.4
20B6:  BRA    20B4
20B8:  MOVWF  x1C
20BA:  MOVLW  2C
20BC:  MOVWF  FF6
20BE:  MOVLW  11
20C0:  MOVWF  FF7
20C2:  MOVLB  0
20C4:  CALL   1552
20C8:  MOVLW  2D
20CA:  BTFSS  FA4.4
20CC:  BRA    20CA
20CE:  MOVLB  F
20D0:  MOVWF  x1C
20D2:  MOVLW  01
20D4:  MOVLB  1
20D6:  MOVWF  x95
20D8:  MOVWF  x96
20DA:  MOVLB  0
20DC:  CALL   15A4
20E0:  MOVLW  0D
20E2:  BTFSS  FA4.4
20E4:  BRA    20E2
20E6:  MOVLB  F
20E8:  MOVWF  x1C
20EA:  MOVLW  0A
20EC:  BTFSS  FA4.4
20EE:  BRA    20EC
20F0:  MOVWF  x1C
20F2:  MOVLB  0
.................... } 
20F4:  GOTO   49D4 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Set the speed of the 2 motors. Valure are +/- 20 for each one                -// 
.................... //--------------------------------------------------------------------------------// 
.................... void __D(void) 
.................... { 
....................    unsigned char Arg[5]; 
....................    unsigned char i, j; 
....................    signed int8 MotG_temp; 
....................    i = 2;                                                                       // Begin with the 3 char (after the first ",") 
*
2204:  MOVLW  02
2206:  MOVLB  1
2208:  MOVWF  x99
....................    j = 0; 
220A:  CLRF   x9A
....................    // While there no END of line "\n" or End of Char ",", place the value in a table to convert it  
....................    while((SerialBuffer[ i ] != ',') &&  (SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................    { 
220C:  CLRF   03
220E:  MOVF   x99,W
2210:  ADDLW  23
2212:  MOVWF  FE9
2214:  MOVLW  00
2216:  ADDWFC 03,W
2218:  MOVWF  FEA
221A:  MOVF   FEF,W
221C:  SUBLW  2C
221E:  BZ    227C
2220:  CLRF   03
2222:  MOVF   x99,W
2224:  ADDLW  23
2226:  MOVWF  FE9
2228:  MOVLW  00
222A:  ADDWFC 03,W
222C:  MOVWF  FEA
222E:  MOVF   FEF,W
2230:  SUBLW  0A
2232:  BZ    227C
2234:  CLRF   03
2236:  MOVF   x99,W
2238:  ADDLW  23
223A:  MOVWF  FE9
223C:  MOVLW  00
223E:  ADDWFC 03,W
2240:  MOVWF  FEA
2242:  MOVF   FEF,W
2244:  SUBLW  0D
2246:  BZ    227C
....................       Arg[j] = SerialBuffer[ i ]; 
2248:  CLRF   03
224A:  MOVF   x9A,W
224C:  ADDLW  94
224E:  MOVWF  01
2250:  MOVLW  01
2252:  ADDWFC 03,F
2254:  MOVFF  03,19D
2258:  CLRF   03
225A:  MOVF   x99,W
225C:  ADDLW  23
225E:  MOVWF  FE9
2260:  MOVLW  00
2262:  ADDWFC 03,W
2264:  MOVWF  FEA
2266:  MOVFF  FEF,19E
226A:  MOVFF  19D,FEA
226E:  MOVFF  01,FE9
2272:  MOVFF  19E,FEF
....................       i++;      
2276:  INCF   x99,F
....................       j++; 
2278:  INCF   x9A,F
....................    } 
227A:  BRA    220C
....................    Arg[j] ='\0';                                                                // PLace a End of sentence at the end of the values 
227C:  CLRF   03
227E:  MOVF   x9A,W
2280:  ADDLW  94
2282:  MOVWF  FE9
2284:  MOVLW  01
2286:  ADDWFC 03,W
2288:  MOVWF  FEA
228A:  CLRF   FEF
....................    MotG_Temp = atoi(Arg);                                                       // Convert the table of value into a signed int8 
228C:  MOVLW  01
228E:  MOVWF  x9D
2290:  MOVLW  94
2292:  MOVWF  x9C
2294:  MOVLB  0
2296:  RCALL  1BDC
2298:  MOVFF  01,19B
....................    if((SerialBuffer[ i ] == 10) || (SerialBuffer[ i ] == 13))                   // If the second argument is not set (i.e. "D,20\r\n") return a error 
229C:  CLRF   03
229E:  MOVLB  1
22A0:  MOVF   x99,W
22A2:  ADDLW  23
22A4:  MOVWF  FE9
22A6:  MOVLW  00
22A8:  ADDWFC 03,W
22AA:  MOVWF  FEA
22AC:  MOVF   FEF,W
22AE:  SUBLW  0A
22B0:  BZ    22C6
22B2:  CLRF   03
22B4:  MOVF   x99,W
22B6:  ADDLW  23
22B8:  MOVWF  FE9
22BA:  MOVLW  00
22BC:  ADDWFC 03,W
22BE:  MOVWF  FEA
22C0:  MOVF   FEF,W
22C2:  SUBLW  0D
22C4:  BNZ   22EA
....................    { 
....................     if(SerialPort == SERIAL_USB) 
22C6:  MOVLB  0
22C8:  MOVF   x74,F
22CA:  BNZ   22DA
....................       fprintf(USB,"Unknown Command ?!\r\n" ); 
22CC:  MOVLW  2E
22CE:  MOVWF  FF6
22D0:  MOVLW  11
22D2:  MOVWF  FF7
22D4:  CALL   141C
....................     else 
22D8:  BRA    22E6
....................       fprintf(BT,"Unknown Command ?!\r\n" ); 
22DA:  MOVLW  44
22DC:  MOVWF  FF6
22DE:  MOVLW  11
22E0:  MOVWF  FF7
22E2:  CALL   1552
....................    } 
....................    else 
22E6:  BRA    23EE
22E8:  MOVLB  1
....................    { 
....................       i++; 
22EA:  INCF   x99,F
....................       j = 0; 
22EC:  CLRF   x9A
....................       // While there no END of line "\n" place the value in a table to convert it  
....................       while((SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................       { 
22EE:  CLRF   03
22F0:  MOVF   x99,W
22F2:  ADDLW  23
22F4:  MOVWF  FE9
22F6:  MOVLW  00
22F8:  ADDWFC 03,W
22FA:  MOVWF  FEA
22FC:  MOVF   FEF,W
22FE:  SUBLW  0A
2300:  BZ    234A
2302:  CLRF   03
2304:  MOVF   x99,W
2306:  ADDLW  23
2308:  MOVWF  FE9
230A:  MOVLW  00
230C:  ADDWFC 03,W
230E:  MOVWF  FEA
2310:  MOVF   FEF,W
2312:  SUBLW  0D
2314:  BZ    234A
....................          Arg[j] = SerialBuffer[ i ]; 
2316:  CLRF   03
2318:  MOVF   x9A,W
231A:  ADDLW  94
231C:  MOVWF  01
231E:  MOVLW  01
2320:  ADDWFC 03,F
2322:  MOVFF  03,19D
2326:  CLRF   03
2328:  MOVF   x99,W
232A:  ADDLW  23
232C:  MOVWF  FE9
232E:  MOVLW  00
2330:  ADDWFC 03,W
2332:  MOVWF  FEA
2334:  MOVFF  FEF,19E
2338:  MOVFF  19D,FEA
233C:  MOVFF  01,FE9
2340:  MOVFF  19E,FEF
....................          i++;      
2344:  INCF   x99,F
....................          j++; 
2346:  INCF   x9A,F
....................       } 
2348:  BRA    22EE
....................       Arg[j] ='\0';                                                             // PLace a End of sentence at the end of the values 
234A:  CLRF   03
234C:  MOVF   x9A,W
234E:  ADDLW  94
2350:  MOVWF  FE9
2352:  MOVLW  01
2354:  ADDWFC 03,W
2356:  MOVWF  FEA
2358:  CLRF   FEF
....................       PwmMotLeft = MotG_Temp; 
235A:  MOVFF  19B,1A
....................       if(PwmMotLeft >20)                                                        // Limit the minimum and maximum PWM value to -20 and 20 
235E:  BTFSC  1A.7
2360:  BRA    236E
2362:  MOVF   1A,W
2364:  SUBLW  14
2366:  BC    236E
....................          PwmMotLeft = 20; 
2368:  MOVLW  14
236A:  MOVWF  1A
....................       else if(PwmMotLeft < -20)  
236C:  BRA    237A
236E:  MOVF   1A,W
2370:  XORLW  80
2372:  SUBLW  6B
2374:  BNC   237A
....................          PwmMotLeft = -20; 
2376:  MOVLW  EC
2378:  MOVWF  1A
....................       PwmMotRight = atoi(Arg);                                                  // Convert the table of value into a signed int8                
237A:  MOVLW  01
237C:  MOVWF  x9D
237E:  MOVLW  94
2380:  MOVWF  x9C
2382:  MOVLB  0
2384:  RCALL  1BDC
2386:  MOVFF  01,1B
....................       if(PwmMotRight >20)                                                       // Limit the minimum and maximum PWM value to -20 and 20 
238A:  BTFSC  1B.7
238C:  BRA    239A
238E:  MOVF   1B,W
2390:  SUBLW  14
2392:  BC    239A
....................          PwmMotRight = 20; 
2394:  MOVLW  14
2396:  MOVWF  1B
....................       else if(PwmMotRight < -20)  
2398:  BRA    23A6
239A:  MOVF   1B,W
239C:  XORLW  80
239E:  SUBLW  6B
23A0:  BNC   23A6
....................          PwmMotRight = -20; 
23A2:  MOVLW  EC
23A4:  MOVWF  1B
23A6:  CLRF   19
23A8:  BTFSC  FF2.7
23AA:  BSF    19.7
23AC:  BCF    FF2.7
....................       Motor_Conversion(); 
23AE:  CALL   0B7E
23B2:  BTFSC  19.7
23B4:  BSF    FF2.7
....................       if(SerialPort == SERIAL_USB) 
23B6:  MOVF   x74,F
23B8:  BNZ   23D4
....................         fprintf(USB,"d\r\n");      
23BA:  MOVLW  64
23BC:  BTFSS  F9E.4
23BE:  BRA    23BC
23C0:  MOVWF  FAD
23C2:  MOVLW  0D
23C4:  BTFSS  F9E.4
23C6:  BRA    23C4
23C8:  MOVWF  FAD
23CA:  MOVLW  0A
23CC:  BTFSS  F9E.4
23CE:  BRA    23CC
23D0:  MOVWF  FAD
....................       else 
23D2:  BRA    23EE
....................         fprintf(BT,"d\r\n");      
23D4:  MOVLW  64
23D6:  BTFSS  FA4.4
23D8:  BRA    23D6
23DA:  MOVLB  F
23DC:  MOVWF  x1C
23DE:  MOVLW  0D
23E0:  BTFSS  FA4.4
23E2:  BRA    23E0
23E4:  MOVWF  x1C
23E6:  MOVLW  0A
23E8:  BTFSS  FA4.4
23EA:  BRA    23E8
23EC:  MOVWF  x1C
23EE:  MOVLB  0
....................        
....................    } 
.................... } 
23F0:  GOTO   49D4 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- Read the Speed of the two motors (-20 to +20)                                -// 
.................... //--------------------------------------------------------------------------------//        
.................... void __E() 
.................... { 
....................   if(SerialPort == SERIAL_USB) 
*
2586:  MOVF   x74,F
2588:  BNZ   25D0
....................    fprintf(USB,"e,%d,%d\r\n",PwmMotLeft,PwmMotRight); 
258A:  MOVLW  65
258C:  BTFSS  F9E.4
258E:  BRA    258C
2590:  MOVWF  FAD
2592:  MOVLW  2C
2594:  BTFSS  F9E.4
2596:  BRA    2594
2598:  MOVWF  FAD
259A:  MOVFF  1A,1A4
259E:  MOVLW  18
25A0:  MOVLB  1
25A2:  MOVWF  xA5
25A4:  MOVLB  0
25A6:  RCALL  23F4
25A8:  MOVLW  2C
25AA:  BTFSS  F9E.4
25AC:  BRA    25AA
25AE:  MOVWF  FAD
25B0:  MOVFF  1B,1A4
25B4:  MOVLW  18
25B6:  MOVLB  1
25B8:  MOVWF  xA5
25BA:  MOVLB  0
25BC:  RCALL  23F4
25BE:  MOVLW  0D
25C0:  BTFSS  F9E.4
25C2:  BRA    25C0
25C4:  MOVWF  FAD
25C6:  MOVLW  0A
25C8:  BTFSS  F9E.4
25CA:  BRA    25C8
25CC:  MOVWF  FAD
....................   else 
25CE:  BRA    261A
....................    fprintf(BT,"e,%d,%d\r\n",PwmMotLeft,PwmMotRight); 
25D0:  MOVLW  65
25D2:  BTFSS  FA4.4
25D4:  BRA    25D2
25D6:  MOVLB  F
25D8:  MOVWF  x1C
25DA:  MOVLW  2C
25DC:  BTFSS  FA4.4
25DE:  BRA    25DC
25E0:  MOVWF  x1C
25E2:  MOVFF  1A,194
25E6:  MOVLW  18
25E8:  MOVLB  1
25EA:  MOVWF  x95
25EC:  MOVLB  0
25EE:  RCALL  24B6
25F0:  MOVLW  2C
25F2:  BTFSS  FA4.4
25F4:  BRA    25F2
25F6:  MOVLB  F
25F8:  MOVWF  x1C
25FA:  MOVFF  1B,194
25FE:  MOVLW  18
2600:  MOVLB  1
2602:  MOVWF  x95
2604:  MOVLB  0
2606:  RCALL  24B6
2608:  MOVLW  0D
260A:  BTFSS  FA4.4
260C:  BRA    260A
260E:  MOVLB  F
2610:  MOVWF  x1C
2612:  MOVLW  0A
2614:  BTFSS  FA4.4
2616:  BRA    2614
2618:  MOVWF  x1C
261A:  MOVLB  0
.................... } 
261C:  GOTO   49D4 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- Set the frequency of the buzzer, 0 = Off , 1 = 500Hz, 100 = 5kHz             -// 
.................... //--------------------------------------------------------------------------------//               
.................... void __H(void) 
.................... { 
....................    unsigned char Arg[5]; 
....................    unsigned char i, j; 
....................    i = 2;                                                                       // Begin with the 3 char (after the first ",") 
*
29B8:  MOVLW  02
29BA:  MOVLB  1
29BC:  MOVWF  x99
....................    j = 0; 
29BE:  CLRF   x9A
....................    // While there no END of line "\n" or End of Char ",", place the value in a table to convert it  
....................    while((SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................    { 
29C0:  CLRF   03
29C2:  MOVF   x99,W
29C4:  ADDLW  23
29C6:  MOVWF  FE9
29C8:  MOVLW  00
29CA:  ADDWFC 03,W
29CC:  MOVWF  FEA
29CE:  MOVF   FEF,W
29D0:  SUBLW  0A
29D2:  BZ    2A1C
29D4:  CLRF   03
29D6:  MOVF   x99,W
29D8:  ADDLW  23
29DA:  MOVWF  FE9
29DC:  MOVLW  00
29DE:  ADDWFC 03,W
29E0:  MOVWF  FEA
29E2:  MOVF   FEF,W
29E4:  SUBLW  0D
29E6:  BZ    2A1C
....................       Arg[j] = SerialBuffer[ i ]; 
29E8:  CLRF   03
29EA:  MOVF   x9A,W
29EC:  ADDLW  94
29EE:  MOVWF  01
29F0:  MOVLW  01
29F2:  ADDWFC 03,F
29F4:  MOVFF  03,19C
29F8:  CLRF   03
29FA:  MOVF   x99,W
29FC:  ADDLW  23
29FE:  MOVWF  FE9
2A00:  MOVLW  00
2A02:  ADDWFC 03,W
2A04:  MOVWF  FEA
2A06:  MOVFF  FEF,19D
2A0A:  MOVFF  19C,FEA
2A0E:  MOVFF  01,FE9
2A12:  MOVFF  19D,FEF
....................       i++;      
2A16:  INCF   x99,F
....................       j++; 
2A18:  INCF   x9A,F
....................    } 
2A1A:  BRA    29C0
....................    Arg[j] ='\0';                                                                // PLace a End of sentence at the end of the values 
2A1C:  CLRF   03
2A1E:  MOVF   x9A,W
2A20:  ADDLW  94
2A22:  MOVWF  FE9
2A24:  MOVLW  01
2A26:  ADDWFC 03,W
2A28:  MOVWF  FEA
2A2A:  CLRF   FEF
....................    buzzValue = atoi(Arg);                                                       // Convert the table of value into a unsigned int8 
2A2C:  MOVLW  01
2A2E:  MOVWF  x9D
2A30:  MOVLW  94
2A32:  MOVWF  x9C
2A34:  MOVLB  0
2A36:  CALL   1BDC
2A3A:  MOVFF  01,105
....................    if(buzzvalue > BUZ_NUMBER)                                                   // Limit the value to 100 
2A3E:  MOVLB  1
2A40:  MOVF   x05,W
2A42:  SUBLW  30
2A44:  BC    2A4A
....................       buzzValue = BUZ_NUMBER; 
2A46:  MOVLW  30
2A48:  MOVWF  x05
....................    Set_Freq_note();                                                             // Convert the value to the corresponding note 
2A4A:  MOVLB  0
2A4C:  RCALL  28E0
....................    if(SerialPort == SERIAL_USB) 
2A4E:  MOVF   x74,F
2A50:  BNZ   2A6C
....................      fprintf(USB,"h\r\n");                                                      // Send the response 
2A52:  MOVLW  68
2A54:  BTFSS  F9E.4
2A56:  BRA    2A54
2A58:  MOVWF  FAD
2A5A:  MOVLW  0D
2A5C:  BTFSS  F9E.4
2A5E:  BRA    2A5C
2A60:  MOVWF  FAD
2A62:  MOVLW  0A
2A64:  BTFSS  F9E.4
2A66:  BRA    2A64
2A68:  MOVWF  FAD
....................    else 
2A6A:  BRA    2A86
....................      fprintf(BT,"h\r\n");                                                       // Send the response 
2A6C:  MOVLW  68
2A6E:  BTFSS  FA4.4
2A70:  BRA    2A6E
2A72:  MOVLB  F
2A74:  MOVWF  x1C
2A76:  MOVLW  0D
2A78:  BTFSS  FA4.4
2A7A:  BRA    2A78
2A7C:  MOVWF  x1C
2A7E:  MOVLW  0A
2A80:  BTFSS  FA4.4
2A82:  BRA    2A80
2A84:  MOVWF  x1C
2A86:  MOVLB  0
....................  
.................... } 
2A88:  GOTO   49D4 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Calibrate the IR Sensor                                                      -// 
.................... //--------------------------------------------------------------------------------//   
.................... void __K() 
.................... { 
....................    unsigned char i,j,Eeprom_temp; 
....................    signed int16 IR_Temp_Calibrate[12]; 
....................    if(SerialPort == SERIAL_USB)                                                 // If a serial cable is plugged, do not calibrate the IR (as it can disturb the measure) 
*
2B1E:  MOVF   x74,F
2B20:  BNZ   2B30
....................      fprintf(USB,"Couldn't calibrate with the USB cable plugged\r\n");          // Send the response 
2B22:  MOVLW  5A
2B24:  MOVWF  FF6
2B26:  MOVLW  11
2B28:  MOVWF  FF7
2B2A:  CALL   141C
....................    else 
2B2E:  BRA    2DE8
....................    { 
....................      fprintf(BT,"Place the K-Junior on a surface without obstacle near from it.\n\r"); // Send the response 
2B30:  MOVLW  8A
2B32:  MOVWF  FF6
2B34:  MOVLW  11
2B36:  MOVWF  FF7
2B38:  CALL   1552
....................      fprintf(BT,"Press ENTER to proceed\n\r"); 
2B3C:  MOVLW  CC
2B3E:  MOVWF  FF6
2B40:  MOVLW  11
2B42:  MOVWF  FF7
2B44:  CALL   1552
....................      SerialCommandOK = 0; 
2B48:  BCF    22.4
....................      for(i=0;i<=GROUNDRIGHT;i++) 
2B4A:  MOVLB  1
2B4C:  CLRF   x94
2B4E:  MOVF   x94,W
2B50:  SUBLW  0A
2B52:  BNC   2B84
....................      { 
....................        IR_Calibrate[i]  = 0;                                                     // Reset the calibrated value     
2B54:  BCF    FD8.0
2B56:  RLCF   x94,W
2B58:  CLRF   03
2B5A:  ADDLW  C1
2B5C:  MOVWF  FE9
2B5E:  MOVLW  00
2B60:  ADDWFC 03,W
2B62:  MOVWF  FEA
2B64:  CLRF   FEC
2B66:  MOVF   FED,F
2B68:  CLRF   FEF
....................        IR_Temp_Calibrate[i] = 0; 
2B6A:  BCF    FD8.0
2B6C:  RLCF   x94,W
2B6E:  CLRF   03
2B70:  ADDLW  97
2B72:  MOVWF  FE9
2B74:  MOVLW  01
2B76:  ADDWFC 03,W
2B78:  MOVWF  FEA
2B7A:  CLRF   FEC
2B7C:  MOVF   FED,F
2B7E:  CLRF   FEF
....................      } 
2B80:  INCF   x94,F
2B82:  BRA    2B4E
....................      while(SerialCommandOK == 0);                                               // Wait the ENTER press 
2B84:  BTFSS  22.4
2B86:  BRA    2B84
....................      Auto_Refresh_Sensors = 0; 
2B88:  BCF    22.0
....................      for(j = 0; j < 8; j++) 
2B8A:  CLRF   x95
2B8C:  MOVF   x95,W
2B8E:  SUBLW  07
2B90:  BNC   2C08
....................      { 
....................        Sensors_Refreshed_Flag = 0;                                                // Start a new measure of the IR sensor 
2B92:  BCF    22.5
....................        Manual_Refresh_sensors = 1; 
2B94:  MOVLB  0
2B96:  BSF    x88.4
....................        while(Sensors_Refreshed_Flag == 0);                                        // Wait until the sensor are refreshed 
2B98:  BTFSS  22.5
2B9A:  BRA    2B98
....................        for(i=0;i<=REAR;i++) 
2B9C:  MOVLB  1
2B9E:  CLRF   x94
2BA0:  MOVF   x94,W
2BA2:  SUBLW  05
2BA4:  BNC   2C04
....................        { 
....................          IR_Temp_Calibrate[i] += IR_Proximity[i];                                 // Save the value of the proximity when no obstacle are present 
2BA6:  BCF    FD8.0
2BA8:  RLCF   x94,W
2BAA:  CLRF   03
2BAC:  ADDLW  97
2BAE:  MOVWF  01
2BB0:  MOVLW  01
2BB2:  ADDWFC 03,F
2BB4:  MOVFF  01,1AF
2BB8:  MOVFF  03,1B0
2BBC:  MOVFF  03,FEA
2BC0:  MOVFF  01,FE9
2BC4:  MOVFF  FEC,1B2
2BC8:  MOVF   FED,F
2BCA:  MOVFF  FEF,1B1
2BCE:  BCF    FD8.0
2BD0:  RLCF   x94,W
2BD2:  CLRF   03
2BD4:  ADDLW  A9
2BD6:  MOVWF  FE9
2BD8:  MOVLW  00
2BDA:  ADDWFC 03,W
2BDC:  MOVWF  FEA
2BDE:  MOVFF  FEC,03
2BE2:  MOVF   FED,F
2BE4:  MOVF   FEF,W
2BE6:  ADDWF  xB1,W
2BE8:  MOVWF  01
2BEA:  MOVF   xB2,W
2BEC:  ADDWFC 03,F
2BEE:  MOVFF  1B0,FEA
2BF2:  MOVFF  1AF,FE9
2BF6:  MOVFF  03,FEC
2BFA:  MOVF   FED,F
2BFC:  MOVFF  01,FEF
....................        } 
2C00:  INCF   x94,F
2C02:  BRA    2BA0
....................      } 
2C04:  INCF   x95,F
2C06:  BRA    2B8C
....................      fprintf(BT,"Now return the K-Junior. The ground sensor must be free of obstacle.\n\r"); // Send the response 
2C08:  MOVLW  E6
2C0A:  MOVWF  FF6
2C0C:  MOVLW  11
2C0E:  MOVWF  FF7
2C10:  MOVLB  0
2C12:  CALL   1552
....................      fprintf(BT,"Press ENTER to proceed\n\r"); 
2C16:  MOVLW  2E
2C18:  MOVWF  FF6
2C1A:  MOVLW  12
2C1C:  MOVWF  FF7
2C1E:  CALL   1552
....................      SerialCommandOK = 0; 
2C22:  BCF    22.4
....................      while(SerialCommandOK == 0);                                               // Wait the ENTER press 
2C24:  BTFSS  22.4
2C26:  BRA    2C24
....................      for(j = 0; j < 8; j++) 
2C28:  MOVLB  1
2C2A:  CLRF   x95
2C2C:  MOVF   x95,W
2C2E:  SUBLW  07
2C30:  BNC   2CAA
....................      { 
....................        Sensors_Refreshed_Flag = 0;                                                // Start a new measure of the IR sensor 
2C32:  BCF    22.5
....................        Manual_Refresh_sensors = 1; 
2C34:  MOVLB  0
2C36:  BSF    x88.4
....................        while(Sensors_Refreshed_Flag == 0);                                        // Wait until the sensor are refreshed 
2C38:  BTFSS  22.5
2C3A:  BRA    2C38
....................        for(i=GROUNDFRONTLEFT ;i<=GROUNDRIGHT;i++) 
2C3C:  MOVLW  07
2C3E:  MOVLB  1
2C40:  MOVWF  x94
2C42:  MOVF   x94,W
2C44:  SUBLW  0A
2C46:  BNC   2CA6
....................          IR_Temp_Calibrate[i] += IR_Proximity[i];                                        // Save the value of the proximity when no obstacle are present 
2C48:  BCF    FD8.0
2C4A:  RLCF   x94,W
2C4C:  CLRF   03
2C4E:  ADDLW  97
2C50:  MOVWF  01
2C52:  MOVLW  01
2C54:  ADDWFC 03,F
2C56:  MOVFF  01,1AF
2C5A:  MOVFF  03,1B0
2C5E:  MOVFF  03,FEA
2C62:  MOVFF  01,FE9
2C66:  MOVFF  FEC,1B2
2C6A:  MOVF   FED,F
2C6C:  MOVFF  FEF,1B1
2C70:  BCF    FD8.0
2C72:  RLCF   x94,W
2C74:  CLRF   03
2C76:  ADDLW  A9
2C78:  MOVWF  FE9
2C7A:  MOVLW  00
2C7C:  ADDWFC 03,W
2C7E:  MOVWF  FEA
2C80:  MOVFF  FEC,03
2C84:  MOVF   FED,F
2C86:  MOVF   FEF,W
2C88:  ADDWF  xB1,W
2C8A:  MOVWF  01
2C8C:  MOVF   xB2,W
2C8E:  ADDWFC 03,F
2C90:  MOVFF  1B0,FEA
2C94:  MOVFF  1AF,FE9
2C98:  MOVFF  03,FEC
2C9C:  MOVF   FED,F
2C9E:  MOVFF  01,FEF
2CA2:  INCF   x94,F
2CA4:  BRA    2C42
....................      } 
2CA6:  INCF   x95,F
2CA8:  BRA    2C2C
....................      for(i = 0; i<=GROUNDRIGHT; i++) 
2CAA:  CLRF   x94
2CAC:  MOVF   x94,W
2CAE:  SUBLW  0A
2CB0:  BTFSS  FD8.0
2CB2:  BRA    2DD8
....................      { 
....................        IR_Calibrate[i] = IR_Temp_Calibrate[i] >> 3;                             // Divide all the Calibrated value and store them in the final table 
2CB4:  BCF    FD8.0
2CB6:  RLCF   x94,W
2CB8:  CLRF   03
2CBA:  ADDLW  C1
2CBC:  MOVWF  01
2CBE:  MOVLW  00
2CC0:  ADDWFC 03,F
2CC2:  MOVFF  03,1B0
2CC6:  BCF    FD8.0
2CC8:  RLCF   x94,W
2CCA:  CLRF   03
2CCC:  ADDLW  97
2CCE:  MOVWF  FE9
2CD0:  MOVLW  01
2CD2:  ADDWFC 03,W
2CD4:  MOVWF  FEA
2CD6:  MOVFF  FEC,1B2
2CDA:  MOVF   FED,F
2CDC:  MOVFF  FEF,1B1
2CE0:  RRCF   xB2,W
2CE2:  MOVWF  03
2CE4:  RRCF   xB1,W
2CE6:  MOVWF  02
2CE8:  RRCF   03,F
2CEA:  RRCF   02,F
2CEC:  RRCF   03,F
2CEE:  RRCF   02,F
2CF0:  MOVLW  1F
2CF2:  ANDWF  03,F
2CF4:  MOVFF  1B0,FEA
2CF8:  MOVFF  01,FE9
2CFC:  MOVFF  03,FEC
2D00:  MOVF   FED,F
2D02:  MOVFF  02,FEF
....................        IR_Calibrate[i] += IR_CALIB_TH; 
2D06:  BCF    FD8.0
2D08:  RLCF   x94,W
2D0A:  CLRF   03
2D0C:  ADDLW  C1
2D0E:  MOVWF  FE9
2D10:  MOVLW  00
2D12:  ADDWFC 03,W
2D14:  MOVWF  FEA
2D16:  MOVLW  14
2D18:  ADDWF  FEF,W
2D1A:  MOVWF  01
2D1C:  MOVLW  00
2D1E:  ADDWFC FEC,W
2D20:  MOVF   FED,F
2D22:  MOVFF  01,FEF
2D26:  MOVWF  FEC
....................        Eeprom_temp = IR_Calibrate[i] & 0x00FF;                                  // Save the calibrate data in the EEPROM 
2D28:  BCF    FD8.0
2D2A:  RLCF   x94,W
2D2C:  CLRF   03
2D2E:  ADDLW  C1
2D30:  MOVWF  FE9
2D32:  MOVLW  00
2D34:  ADDWFC 03,W
2D36:  MOVWF  FEA
2D38:  MOVFF  FEC,1B0
2D3C:  MOVF   FED,F
2D3E:  MOVFF  FEF,1AF
2D42:  MOVFF  1AF,196
....................        write_eeprom(EEPROM_ADD*2*i,Eeprom_temp); 
2D46:  MOVF   x94,W
2D48:  MULLW  14
2D4A:  MOVF   FF3,W
2D4C:  MOVWF  xAF
2D4E:  MOVF   FF2,W
2D50:  MOVWF  00
2D52:  BCF    FF2.7
2D54:  CLRF   F63
2D56:  MOVFF  1AF,F62
2D5A:  MOVFF  196,F61
2D5E:  BCF    F7F.6
2D60:  BCF    F7F.7
2D62:  BSF    F7F.2
2D64:  MOVLB  F
2D66:  MOVLW  55
2D68:  MOVWF  F7E
2D6A:  MOVLW  AA
2D6C:  MOVWF  F7E
2D6E:  BSF    F7F.1
2D70:  BTFSC  F7F.1
2D72:  BRA    2D70
2D74:  BCF    F7F.2
2D76:  MOVF   00,W
2D78:  IORWF  FF2,F
....................        Eeprom_temp = (IR_Calibrate[i] & 0xFF00) >> 8; 
2D7A:  BCF    FD8.0
2D7C:  MOVLB  1
2D7E:  RLCF   x94,W
2D80:  CLRF   03
2D82:  ADDLW  C1
2D84:  MOVWF  FE9
2D86:  MOVLW  00
2D88:  ADDWFC 03,W
2D8A:  MOVWF  FEA
2D8C:  MOVFF  FEC,1B0
2D90:  MOVF   FED,F
2D92:  MOVFF  FEF,1AF
2D96:  CLRF   xAF
2D98:  MOVFF  1B0,196
....................        write_eeprom((EEPROM_ADD*2*i)+1,Eeprom_temp); 
2D9C:  MOVF   x94,W
2D9E:  MULLW  14
2DA0:  MOVF   FF3,W
2DA2:  ADDLW  01
2DA4:  MOVWF  xAF
2DA6:  MOVF   FF2,W
2DA8:  MOVWF  00
2DAA:  BCF    FF2.7
2DAC:  CLRF   F63
2DAE:  MOVFF  1AF,F62
2DB2:  MOVFF  196,F61
2DB6:  BCF    F7F.6
2DB8:  BCF    F7F.7
2DBA:  BSF    F7F.2
2DBC:  MOVLB  F
2DBE:  MOVLW  55
2DC0:  MOVWF  F7E
2DC2:  MOVLW  AA
2DC4:  MOVWF  F7E
2DC6:  BSF    F7F.1
2DC8:  BTFSC  F7F.1
2DCA:  BRA    2DC8
2DCC:  BCF    F7F.2
2DCE:  MOVF   00,W
2DD0:  IORWF  FF2,F
....................         
....................      } 
2DD2:  MOVLB  1
2DD4:  INCF   x94,F
2DD6:  BRA    2CAC
....................      Auto_Refresh_Sensors = 1; 
2DD8:  BSF    22.0
....................      fprintf(BT,"Calibration done\n\r");                                        // Send the response 
2DDA:  MOVLW  48
2DDC:  MOVWF  FF6
2DDE:  MOVLW  12
2DE0:  MOVWF  FF7
2DE2:  MOVLB  0
2DE4:  CALL   1552
....................       
....................  
....................    } 
.................... } 
2DE8:  GOTO   49D4 (RETURN)
....................  
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Scan the I2C Bus                                                             -// 
.................... //--------------------------------------------------------------------------------//   
.................... void __J() 
.................... { 
....................    unsigned char i; 
....................    unsigned char TempVal; 
....................    printf("j"); 
*
2E24:  MOVLW  6A
2E26:  BTFSS  FA4.4
2E28:  BRA    2E26
2E2A:  MOVLB  F
2E2C:  MOVWF  x1C
....................    for(i=3;i<254;i=i+2)                                                         // Try all the available I2C address (0x00 to 0xFF) 
2E2E:  MOVLW  03
2E30:  MOVLB  1
2E32:  MOVWF  x94
2E34:  MOVF   x94,W
2E36:  SUBLW  FD
2E38:  BNC   2EC4
....................    { 
....................       i2c_start(); 
2E3A:  BSF    FC5.0
2E3C:  BTFSC  FC5.0
2E3E:  BRA    2E3C
....................       if(i2c_write(i-1)==0)                                                     // If a device is detected 
2E40:  MOVLW  01
2E42:  SUBWF  x94,W
2E44:  MOVWF  x96
2E46:  MOVWF  xCB
2E48:  MOVLB  0
2E4A:  RCALL  2DEC
2E4C:  MOVF   01,F
2E4E:  BNZ   2EB6
....................       { 
....................          i2c_write(0x00);                                                       // Version Register 
2E50:  MOVLB  1
2E52:  CLRF   xCB
2E54:  MOVLB  0
2E56:  RCALL  2DEC
....................          i2c_start(); 
2E58:  BSF    FC5.1
2E5A:  BTFSC  FC5.1
2E5C:  BRA    2E5A
....................          i2c_write(i); 
2E5E:  MOVFF  194,1CB
2E62:  RCALL  2DEC
....................          TempVal=i2c_read(0);                                                   // Read the Version register to validate the communication 
2E64:  CLRF   00
2E66:  RCALL  2E08
2E68:  MOVFF  01,195
....................          i2c_stop(); 
2E6C:  BSF    FC5.2
2E6E:  BTFSC  FC5.2
2E70:  BRA    2E6E
....................          if(SerialPort == SERIAL_USB) 
2E72:  MOVF   x74,F
2E74:  BNZ   2E94
....................            fprintf(USB,",%2x",i-1); 
2E76:  MOVLW  01
2E78:  MOVLB  1
2E7A:  SUBWF  x94,W
2E7C:  MOVWF  x96
2E7E:  MOVLW  2C
2E80:  BTFSS  F9E.4
2E82:  BRA    2E80
2E84:  MOVWF  FAD
2E86:  MOVFF  196,197
2E8A:  MOVLW  57
2E8C:  MOVWF  x98
2E8E:  MOVLB  0
2E90:  RCALL  2A8C
....................          else 
2E92:  BRA    2EB4
....................            fprintf(BT,",%2x",i-1);  
2E94:  MOVLW  01
2E96:  MOVLB  1
2E98:  SUBWF  x94,W
2E9A:  MOVWF  x96
2E9C:  MOVLW  2C
2E9E:  BTFSS  FA4.4
2EA0:  BRA    2E9E
2EA2:  MOVLB  F
2EA4:  MOVWF  x1C
2EA6:  MOVFF  196,197
2EAA:  MOVLW  57
2EAC:  MOVLB  1
2EAE:  MOVWF  x98
2EB0:  MOVLB  0
2EB2:  RCALL  2AD2
....................       } 
....................       else 
2EB4:  BRA    2EBC
....................       { 
....................          i2c_stop();                                                            // Stop the I2C communication 
2EB6:  BSF    FC5.2
2EB8:  BTFSC  FC5.2
2EBA:  BRA    2EB8
....................       } 
....................    } 
2EBC:  MOVLW  02
2EBE:  MOVLB  1
2EC0:  ADDWF  x94,F
2EC2:  BRA    2E34
....................    if(SerialPort == SERIAL_USB) 
2EC4:  MOVLB  0
2EC6:  MOVF   x74,F
2EC8:  BNZ   2EDC
....................      fprintf(USB,"\r\n"); 
2ECA:  MOVLW  0D
2ECC:  BTFSS  F9E.4
2ECE:  BRA    2ECC
2ED0:  MOVWF  FAD
2ED2:  MOVLW  0A
2ED4:  BTFSS  F9E.4
2ED6:  BRA    2ED4
2ED8:  MOVWF  FAD
....................    else 
2EDA:  BRA    2EEE
....................      fprintf(BT,"\r\n"); 
2EDC:  MOVLW  0D
2EDE:  BTFSS  FA4.4
2EE0:  BRA    2EDE
2EE2:  MOVLB  F
2EE4:  MOVWF  x1C
2EE6:  MOVLW  0A
2EE8:  BTFSS  FA4.4
2EEA:  BRA    2EE8
2EEC:  MOVWF  x1C
2EEE:  MOVLB  0
.................... } 
2EF0:  GOTO   49D4 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- Set the LED value                                                            -// 
.................... //--------------------------------------------------------------------------------//   
.................... //#separate 
.................... void __L(void) 
.................... { 
....................    unsigned char LED_temp; 
....................  
....................   switch(SerialBuffer[2]) 
....................    { 
*
2F6A:  MOVF   25,W
2F6C:  XORLW  30
2F6E:  BZ    2F82
2F70:  XORLW  01
2F72:  BZ    2F8A
2F74:  XORLW  03
2F76:  BZ    2F92
2F78:  XORLW  01
2F7A:  BZ    2F9A
2F7C:  XORLW  07
2F7E:  BZ    2FA2
2F80:  BRA    2FAC
....................       case '0': 
....................          LED_temp = LED0; 
2F82:  MOVLW  09
2F84:  MOVLB  1
2F86:  MOVWF  x94
....................          break; 
2F88:  BRA    2FCC
....................       case '1': 
....................          LED_temp = LED1; 
2F8A:  MOVLW  0A
2F8C:  MOVLB  1
2F8E:  MOVWF  x94
....................          break; 
2F90:  BRA    2FCC
....................       case '2': 
....................          LED_temp = LED2; 
2F92:  MOVLW  0B
2F94:  MOVLB  1
2F96:  MOVWF  x94
....................          break; 
2F98:  BRA    2FCC
....................       case '3': 
....................          LED_temp = LED3; 
2F9A:  MOVLW  0C
2F9C:  MOVLB  1
2F9E:  MOVWF  x94
....................          break; 
2FA0:  BRA    2FCC
....................       case '4': 
....................          LED_temp = LED4; 
2FA2:  MOVLW  0D
2FA4:  MOVLB  1
2FA6:  MOVWF  x94
....................          break; 
2FA8:  BRA    2FCC
2FAA:  MOVLB  0
....................       default: 
....................          if(SerialPort == SERIAL_USB) 
2FAC:  MOVF   x74,F
2FAE:  BNZ   2FBE
....................            fprintf(USB,"Unknown Command ?!\r\n" ); 
2FB0:  MOVLW  5C
2FB2:  MOVWF  FF6
2FB4:  MOVLW  12
2FB6:  MOVWF  FF7
2FB8:  CALL   141C
....................          else 
2FBC:  BRA    2FCA
....................            fprintf(BT,"Unknown Command ?!\r\n" ); 
2FBE:  MOVLW  72
2FC0:  MOVWF  FF6
2FC2:  MOVLW  12
2FC4:  MOVWF  FF7
2FC6:  CALL   1552
....................          break; 
2FCA:  MOVLB  1
....................    } 
....................    if(SerialBuffer[4] == '3')                                                   // Activate the auto mode of the LED 
2FCC:  MOVF   27,W
2FCE:  SUBLW  33
2FD0:  BNZ   2FEE
....................       LED_Mode |= (0x01 << (SerialBuffer[2] - '0')); 
2FD2:  MOVLW  30
2FD4:  SUBWF  25,W
2FD6:  MOVWF  01
2FD8:  MOVLW  01
2FDA:  MOVWF  00
2FDC:  MOVF   01,F
2FDE:  BZ    2FE8
2FE0:  BCF    FD8.0
2FE2:  RLCF   00,F
2FE4:  DECFSZ 01,F
2FE6:  BRA    2FE0
2FE8:  MOVF   00,W
2FEA:  IORWF  x02,F
....................    else 
2FEC:  BRA    3086
....................    { 
....................       if(SerialBuffer[4] == '2')                                                // Toggle the Selected LED 
2FEE:  MOVF   27,W
2FF0:  SUBLW  32
2FF2:  BNZ   3038
....................       { 
....................          if(input(LED_temp)) 
2FF4:  MOVFF  194,195
2FF8:  MOVLW  0F
2FFA:  MOVWF  x97
2FFC:  MOVLW  80
2FFE:  MOVWF  x96
3000:  MOVLB  0
3002:  BRA    2EF4
3004:  BTFSS  01.0
3006:  BRA    301E
....................             output_low(LED_TEMP); 
3008:  MOVFF  194,195
300C:  MOVLB  1
300E:  CLRF   x96
3010:  MOVLW  0F
3012:  MOVWF  x98
3014:  MOVLW  89
3016:  MOVWF  x97
3018:  MOVLB  0
301A:  RCALL  2F28
....................          else 
301C:  BRA    3034
....................             output_high(LED_TEMP); 
301E:  MOVFF  194,195
3022:  MOVLW  01
3024:  MOVLB  1
3026:  MOVWF  x96
3028:  MOVLW  0F
302A:  MOVWF  x98
302C:  MOVLW  89
302E:  MOVWF  x97
3030:  MOVLB  0
3032:  RCALL  2F28
....................       } 
....................       else if(SerialBuffer[4] == '0') 
3034:  BRA    3068
3036:  MOVLB  1
3038:  MOVF   27,W
303A:  SUBLW  30
303C:  BNZ   3054
....................           output_low(LED_temp);                                                 // Turn OFF the selected LED 
303E:  MOVFF  194,195
3042:  CLRF   x96
3044:  MOVLW  0F
3046:  MOVWF  x98
3048:  MOVLW  89
304A:  MOVWF  x97
304C:  MOVLB  0
304E:  RCALL  2F28
....................       else                                                   
3050:  BRA    3068
3052:  MOVLB  1
....................          output_high(LED_temp);                                                 // Turn ON the selected LED 
3054:  MOVFF  194,195
3058:  MOVLW  01
305A:  MOVWF  x96
305C:  MOVLW  0F
305E:  MOVWF  x98
3060:  MOVLW  89
3062:  MOVWF  x97
3064:  MOVLB  0
3066:  RCALL  2F28
....................       LED_Mode &= 0xff - (0x01 << (SerialBuffer[2] - '0'));                     // Reset the flag of the auto mode 
3068:  MOVLW  30
306A:  SUBWF  25,W
306C:  MOVWF  01
306E:  MOVLW  01
3070:  MOVWF  00
3072:  MOVF   01,F
3074:  BZ    307E
3076:  BCF    FD8.0
3078:  RLCF   00,F
307A:  DECFSZ 01,F
307C:  BRA    3076
307E:  MOVF   00,W
3080:  SUBLW  FF
3082:  MOVLB  1
3084:  ANDWF  x02,F
....................    }                
....................    if(SerialPort == SERIAL_USB) 
3086:  MOVLB  0
3088:  MOVF   x74,F
308A:  BNZ   30A6
....................      fprintf(USB,"l\r\n"); 
308C:  MOVLW  6C
308E:  BTFSS  F9E.4
3090:  BRA    308E
3092:  MOVWF  FAD
3094:  MOVLW  0D
3096:  BTFSS  F9E.4
3098:  BRA    3096
309A:  MOVWF  FAD
309C:  MOVLW  0A
309E:  BTFSS  F9E.4
30A0:  BRA    309E
30A2:  MOVWF  FAD
....................    else 
30A4:  BRA    30C0
....................      fprintf(BT,"l\r\n"); 
30A6:  MOVLW  6C
30A8:  BTFSS  FA4.4
30AA:  BRA    30A8
30AC:  MOVLB  F
30AE:  MOVWF  x1C
30B0:  MOVLW  0D
30B2:  BTFSS  FA4.4
30B4:  BRA    30B2
30B6:  MOVWF  x1C
30B8:  MOVLW  0A
30BA:  BTFSS  FA4.4
30BC:  BRA    30BA
30BE:  MOVWF  x1C
30C0:  MOVLB  0
.................... } 
30C2:  GOTO   49D4 (RETURN)
....................  
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Return the values of the IR Proximity sensor                                 -// 
.................... //--------------------------------------------------------------------------------//    
.................... //#separate 
.................... void __N(void) 
.................... { 
....................   if(SerialPort == SERIAL_USB) 
*
328E:  MOVF   x74,F
3290:  BTFSS  FD8.2
3292:  BRA    338A
....................    fprintf(USB, "n,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld\r\n" , IR_Proximity[ LEFT ] , IR_Proximity[ FrontLEFT ] , 
....................          IR_Proximity[ FRONT ] , IR_Proximity[ FRONTRIGHT] , IR_Proximity[ RIGHT] , IR_Proximity[ REAR ] , 
....................          IR_Proximity[ GROUNDLEFT ] , IR_Proximity[ GROUNDFRONTLEFT ], IR_Proximity[ GROUNDFRONTRIGHT ] , IR_Proximity[ GROUNDRIGHT ]  ); 
3294:  MOVLW  6E
3296:  BTFSS  F9E.4
3298:  BRA    3296
329A:  MOVWF  FAD
329C:  MOVLW  2C
329E:  BTFSS  F9E.4
32A0:  BRA    329E
32A2:  MOVWF  FAD
32A4:  MOVLW  0A
32A6:  MOVWF  FE9
32A8:  MOVFF  AA,195
32AC:  MOVFF  A9,194
32B0:  RCALL  30C6
32B2:  MOVLW  2C
32B4:  BTFSS  F9E.4
32B6:  BRA    32B4
32B8:  MOVWF  FAD
32BA:  MOVLW  0A
32BC:  MOVWF  FE9
32BE:  MOVFF  AC,195
32C2:  MOVFF  AB,194
32C6:  RCALL  30C6
32C8:  MOVLW  2C
32CA:  BTFSS  F9E.4
32CC:  BRA    32CA
32CE:  MOVWF  FAD
32D0:  MOVLW  0A
32D2:  MOVWF  FE9
32D4:  MOVFF  AE,195
32D8:  MOVFF  AD,194
32DC:  RCALL  30C6
32DE:  MOVLW  2C
32E0:  BTFSS  F9E.4
32E2:  BRA    32E0
32E4:  MOVWF  FAD
32E6:  MOVLW  0A
32E8:  MOVWF  FE9
32EA:  MOVFF  B0,195
32EE:  MOVFF  AF,194
32F2:  RCALL  30C6
32F4:  MOVLW  2C
32F6:  BTFSS  F9E.4
32F8:  BRA    32F6
32FA:  MOVWF  FAD
32FC:  MOVLW  0A
32FE:  MOVWF  FE9
3300:  MOVFF  B2,195
3304:  MOVFF  B1,194
3308:  RCALL  30C6
330A:  MOVLW  2C
330C:  BTFSS  F9E.4
330E:  BRA    330C
3310:  MOVWF  FAD
3312:  MOVLW  0A
3314:  MOVWF  FE9
3316:  MOVFF  B4,195
331A:  MOVFF  B3,194
331E:  RCALL  30C6
3320:  MOVLW  2C
3322:  BTFSS  F9E.4
3324:  BRA    3322
3326:  MOVWF  FAD
3328:  MOVLW  0A
332A:  MOVWF  FE9
332C:  MOVFF  BC,195
3330:  MOVFF  BB,194
3334:  RCALL  30C6
3336:  MOVLW  2C
3338:  BTFSS  F9E.4
333A:  BRA    3338
333C:  MOVWF  FAD
333E:  MOVLW  0A
3340:  MOVWF  FE9
3342:  MOVFF  B8,195
3346:  MOVFF  B7,194
334A:  RCALL  30C6
334C:  MOVLW  2C
334E:  BTFSS  F9E.4
3350:  BRA    334E
3352:  MOVWF  FAD
3354:  MOVLW  0A
3356:  MOVWF  FE9
3358:  MOVFF  BA,195
335C:  MOVFF  B9,194
3360:  RCALL  30C6
3362:  MOVLW  2C
3364:  BTFSS  F9E.4
3366:  BRA    3364
3368:  MOVWF  FAD
336A:  MOVLW  0A
336C:  MOVWF  FE9
336E:  MOVFF  BE,195
3372:  MOVFF  BD,194
3376:  RCALL  30C6
3378:  MOVLW  0D
337A:  BTFSS  F9E.4
337C:  BRA    337A
337E:  MOVWF  FAD
3380:  MOVLW  0A
3382:  BTFSS  F9E.4
3384:  BRA    3382
3386:  MOVWF  FAD
....................   else 
3388:  BRA    34A8
....................    fprintf(BT, "n,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld\r\n" , IR_Proximity[ LEFT ] , IR_Proximity[ FrontLEFT ] , 
....................          IR_Proximity[ FRONT ] , IR_Proximity[ FRONTRIGHT] , IR_Proximity[ RIGHT] , IR_Proximity[ REAR ] , 
....................          IR_Proximity[ GROUNDLEFT ] , IR_Proximity[ GROUNDFRONTLEFT ], IR_Proximity[ GROUNDFRONTRIGHT ] , IR_Proximity[ GROUNDRIGHT ]  ); 
338A:  MOVLW  6E
338C:  BTFSS  FA4.4
338E:  BRA    338C
3390:  MOVLB  F
3392:  MOVWF  x1C
3394:  MOVLW  2C
3396:  BTFSS  FA4.4
3398:  BRA    3396
339A:  MOVWF  x1C
339C:  MOVLW  0A
339E:  MOVWF  FE9
33A0:  MOVFF  AA,195
33A4:  MOVFF  A9,194
33A8:  MOVLB  0
33AA:  RCALL  31A8
33AC:  MOVLW  2C
33AE:  BTFSS  FA4.4
33B0:  BRA    33AE
33B2:  MOVLB  F
33B4:  MOVWF  x1C
33B6:  MOVLW  0A
33B8:  MOVWF  FE9
33BA:  MOVFF  AC,195
33BE:  MOVFF  AB,194
33C2:  MOVLB  0
33C4:  RCALL  31A8
33C6:  MOVLW  2C
33C8:  BTFSS  FA4.4
33CA:  BRA    33C8
33CC:  MOVLB  F
33CE:  MOVWF  x1C
33D0:  MOVLW  0A
33D2:  MOVWF  FE9
33D4:  MOVFF  AE,195
33D8:  MOVFF  AD,194
33DC:  MOVLB  0
33DE:  RCALL  31A8
33E0:  MOVLW  2C
33E2:  BTFSS  FA4.4
33E4:  BRA    33E2
33E6:  MOVLB  F
33E8:  MOVWF  x1C
33EA:  MOVLW  0A
33EC:  MOVWF  FE9
33EE:  MOVFF  B0,195
33F2:  MOVFF  AF,194
33F6:  MOVLB  0
33F8:  RCALL  31A8
33FA:  MOVLW  2C
33FC:  BTFSS  FA4.4
33FE:  BRA    33FC
3400:  MOVLB  F
3402:  MOVWF  x1C
3404:  MOVLW  0A
3406:  MOVWF  FE9
3408:  MOVFF  B2,195
340C:  MOVFF  B1,194
3410:  MOVLB  0
3412:  RCALL  31A8
3414:  MOVLW  2C
3416:  BTFSS  FA4.4
3418:  BRA    3416
341A:  MOVLB  F
341C:  MOVWF  x1C
341E:  MOVLW  0A
3420:  MOVWF  FE9
3422:  MOVFF  B4,195
3426:  MOVFF  B3,194
342A:  MOVLB  0
342C:  RCALL  31A8
342E:  MOVLW  2C
3430:  BTFSS  FA4.4
3432:  BRA    3430
3434:  MOVLB  F
3436:  MOVWF  x1C
3438:  MOVLW  0A
343A:  MOVWF  FE9
343C:  MOVFF  BC,195
3440:  MOVFF  BB,194
3444:  MOVLB  0
3446:  RCALL  31A8
3448:  MOVLW  2C
344A:  BTFSS  FA4.4
344C:  BRA    344A
344E:  MOVLB  F
3450:  MOVWF  x1C
3452:  MOVLW  0A
3454:  MOVWF  FE9
3456:  MOVFF  B8,195
345A:  MOVFF  B7,194
345E:  MOVLB  0
3460:  RCALL  31A8
3462:  MOVLW  2C
3464:  BTFSS  FA4.4
3466:  BRA    3464
3468:  MOVLB  F
346A:  MOVWF  x1C
346C:  MOVLW  0A
346E:  MOVWF  FE9
3470:  MOVFF  BA,195
3474:  MOVFF  B9,194
3478:  MOVLB  0
347A:  RCALL  31A8
347C:  MOVLW  2C
347E:  BTFSS  FA4.4
3480:  BRA    347E
3482:  MOVLB  F
3484:  MOVWF  x1C
3486:  MOVLW  0A
3488:  MOVWF  FE9
348A:  MOVFF  BE,195
348E:  MOVFF  BD,194
3492:  MOVLB  0
3494:  RCALL  31A8
3496:  MOVLW  0D
3498:  BTFSS  FA4.4
349A:  BRA    3498
349C:  MOVLB  F
349E:  MOVWF  x1C
34A0:  MOVLW  0A
34A2:  BTFSS  FA4.4
34A4:  BRA    34A2
34A6:  MOVWF  x1C
34A8:  MOVLB  0
....................    
.................... } 
34AA:  GOTO   49D4 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- Return the values of the IR Ambient light sensor                             -// 
.................... //--------------------------------------------------------------------------------//                   
.................... //#separate 
.................... void __O(void) 
.................... { 
....................   if(SerialPort == SERIAL_USB) 
34AE:  MOVF   x74,F
34B0:  BTFSS  FD8.2
34B2:  BRA    35AA
....................    fprintf(USB, "o,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld\r\n" , IR_Light[ LEFT ] , IR_Light[ FrontLEFT ] , 
....................          IR_Light[ FRONT ] , IR_Light[ FRONTRIGHT] , IR_Light[ RIGHT] , IR_Light[ REAR ] , 
....................          IR_Light[ GROUNDLEFT ] , IR_Light[ GROUNDFRONTLEFT ], IR_Light[ GROUNDFRONTRIGHT ] , IR_Light[ GROUNDRIGHT ]  ); 
34B4:  MOVLW  6F
34B6:  BTFSS  F9E.4
34B8:  BRA    34B6
34BA:  MOVWF  FAD
34BC:  MOVLW  2C
34BE:  BTFSS  F9E.4
34C0:  BRA    34BE
34C2:  MOVWF  FAD
34C4:  MOVLW  0A
34C6:  MOVWF  FE9
34C8:  MOVFF  92,195
34CC:  MOVFF  91,194
34D0:  RCALL  30C6
34D2:  MOVLW  2C
34D4:  BTFSS  F9E.4
34D6:  BRA    34D4
34D8:  MOVWF  FAD
34DA:  MOVLW  0A
34DC:  MOVWF  FE9
34DE:  MOVFF  94,195
34E2:  MOVFF  93,194
34E6:  RCALL  30C6
34E8:  MOVLW  2C
34EA:  BTFSS  F9E.4
34EC:  BRA    34EA
34EE:  MOVWF  FAD
34F0:  MOVLW  0A
34F2:  MOVWF  FE9
34F4:  MOVFF  96,195
34F8:  MOVFF  95,194
34FC:  RCALL  30C6
34FE:  MOVLW  2C
3500:  BTFSS  F9E.4
3502:  BRA    3500
3504:  MOVWF  FAD
3506:  MOVLW  0A
3508:  MOVWF  FE9
350A:  MOVFF  98,195
350E:  MOVFF  97,194
3512:  RCALL  30C6
3514:  MOVLW  2C
3516:  BTFSS  F9E.4
3518:  BRA    3516
351A:  MOVWF  FAD
351C:  MOVLW  0A
351E:  MOVWF  FE9
3520:  MOVFF  9A,195
3524:  MOVFF  99,194
3528:  RCALL  30C6
352A:  MOVLW  2C
352C:  BTFSS  F9E.4
352E:  BRA    352C
3530:  MOVWF  FAD
3532:  MOVLW  0A
3534:  MOVWF  FE9
3536:  MOVFF  9C,195
353A:  MOVFF  9B,194
353E:  RCALL  30C6
3540:  MOVLW  2C
3542:  BTFSS  F9E.4
3544:  BRA    3542
3546:  MOVWF  FAD
3548:  MOVLW  0A
354A:  MOVWF  FE9
354C:  MOVFF  A4,195
3550:  MOVFF  A3,194
3554:  RCALL  30C6
3556:  MOVLW  2C
3558:  BTFSS  F9E.4
355A:  BRA    3558
355C:  MOVWF  FAD
355E:  MOVLW  0A
3560:  MOVWF  FE9
3562:  MOVFF  A0,195
3566:  MOVFF  9F,194
356A:  RCALL  30C6
356C:  MOVLW  2C
356E:  BTFSS  F9E.4
3570:  BRA    356E
3572:  MOVWF  FAD
3574:  MOVLW  0A
3576:  MOVWF  FE9
3578:  MOVFF  A2,195
357C:  MOVFF  A1,194
3580:  RCALL  30C6
3582:  MOVLW  2C
3584:  BTFSS  F9E.4
3586:  BRA    3584
3588:  MOVWF  FAD
358A:  MOVLW  0A
358C:  MOVWF  FE9
358E:  MOVFF  A6,195
3592:  MOVFF  A5,194
3596:  RCALL  30C6
3598:  MOVLW  0D
359A:  BTFSS  F9E.4
359C:  BRA    359A
359E:  MOVWF  FAD
35A0:  MOVLW  0A
35A2:  BTFSS  F9E.4
35A4:  BRA    35A2
35A6:  MOVWF  FAD
....................   else 
35A8:  BRA    36C8
....................    fprintf(BT, "o,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld,%04ld\r\n" , IR_Light[ LEFT ] , IR_Light[ FrontLEFT ] , 
....................          IR_Light[ FRONT ] , IR_Light[ FRONTRIGHT] , IR_Light[ RIGHT] , IR_Light[ REAR ] , 
....................          IR_Light[ GROUNDLEFT ] , IR_Light[ GROUNDFRONTLEFT ], IR_Light[ GROUNDFRONTRIGHT ] , IR_Light[ GROUNDRIGHT ]  ); 
35AA:  MOVLW  6F
35AC:  BTFSS  FA4.4
35AE:  BRA    35AC
35B0:  MOVLB  F
35B2:  MOVWF  x1C
35B4:  MOVLW  2C
35B6:  BTFSS  FA4.4
35B8:  BRA    35B6
35BA:  MOVWF  x1C
35BC:  MOVLW  0A
35BE:  MOVWF  FE9
35C0:  MOVFF  92,195
35C4:  MOVFF  91,194
35C8:  MOVLB  0
35CA:  RCALL  31A8
35CC:  MOVLW  2C
35CE:  BTFSS  FA4.4
35D0:  BRA    35CE
35D2:  MOVLB  F
35D4:  MOVWF  x1C
35D6:  MOVLW  0A
35D8:  MOVWF  FE9
35DA:  MOVFF  94,195
35DE:  MOVFF  93,194
35E2:  MOVLB  0
35E4:  RCALL  31A8
35E6:  MOVLW  2C
35E8:  BTFSS  FA4.4
35EA:  BRA    35E8
35EC:  MOVLB  F
35EE:  MOVWF  x1C
35F0:  MOVLW  0A
35F2:  MOVWF  FE9
35F4:  MOVFF  96,195
35F8:  MOVFF  95,194
35FC:  MOVLB  0
35FE:  RCALL  31A8
3600:  MOVLW  2C
3602:  BTFSS  FA4.4
3604:  BRA    3602
3606:  MOVLB  F
3608:  MOVWF  x1C
360A:  MOVLW  0A
360C:  MOVWF  FE9
360E:  MOVFF  98,195
3612:  MOVFF  97,194
3616:  MOVLB  0
3618:  RCALL  31A8
361A:  MOVLW  2C
361C:  BTFSS  FA4.4
361E:  BRA    361C
3620:  MOVLB  F
3622:  MOVWF  x1C
3624:  MOVLW  0A
3626:  MOVWF  FE9
3628:  MOVFF  9A,195
362C:  MOVFF  99,194
3630:  MOVLB  0
3632:  RCALL  31A8
3634:  MOVLW  2C
3636:  BTFSS  FA4.4
3638:  BRA    3636
363A:  MOVLB  F
363C:  MOVWF  x1C
363E:  MOVLW  0A
3640:  MOVWF  FE9
3642:  MOVFF  9C,195
3646:  MOVFF  9B,194
364A:  MOVLB  0
364C:  RCALL  31A8
364E:  MOVLW  2C
3650:  BTFSS  FA4.4
3652:  BRA    3650
3654:  MOVLB  F
3656:  MOVWF  x1C
3658:  MOVLW  0A
365A:  MOVWF  FE9
365C:  MOVFF  A4,195
3660:  MOVFF  A3,194
3664:  MOVLB  0
3666:  RCALL  31A8
3668:  MOVLW  2C
366A:  BTFSS  FA4.4
366C:  BRA    366A
366E:  MOVLB  F
3670:  MOVWF  x1C
3672:  MOVLW  0A
3674:  MOVWF  FE9
3676:  MOVFF  A0,195
367A:  MOVFF  9F,194
367E:  MOVLB  0
3680:  RCALL  31A8
3682:  MOVLW  2C
3684:  BTFSS  FA4.4
3686:  BRA    3684
3688:  MOVLB  F
368A:  MOVWF  x1C
368C:  MOVLW  0A
368E:  MOVWF  FE9
3690:  MOVFF  A2,195
3694:  MOVFF  A1,194
3698:  MOVLB  0
369A:  RCALL  31A8
369C:  MOVLW  2C
369E:  BTFSS  FA4.4
36A0:  BRA    369E
36A2:  MOVLB  F
36A4:  MOVWF  x1C
36A6:  MOVLW  0A
36A8:  MOVWF  FE9
36AA:  MOVFF  A6,195
36AE:  MOVFF  A5,194
36B2:  MOVLB  0
36B4:  RCALL  31A8
36B6:  MOVLW  0D
36B8:  BTFSS  FA4.4
36BA:  BRA    36B8
36BC:  MOVLB  F
36BE:  MOVWF  x1C
36C0:  MOVLW  0A
36C2:  BTFSS  FA4.4
36C4:  BRA    36C2
36C6:  MOVWF  x1C
36C8:  MOVLB  0
....................  
.................... } 
36CA:  GOTO   49D4 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Read on the I2C Bus                                                          -// 
.................... //--------------------------------------------------------------------------------//  
.................... //#separate 
.................... void __R(void) 
.................... { 
*
37FA:  MOVLB  1
37FC:  CLRF   x94
37FE:  CLRF   x95
3800:  CLRF   x96
....................    unsigned char memaddress = 0; 
....................    unsigned char rcvalue = 0; 
....................    unsigned char nb_bytes = 0; 
....................    unsigned char TempVal; 
....................    memaddress = chartohex(SerialBuffer[2]); 
3802:  MOVFF  25,1CE
3806:  MOVLB  0
3808:  RCALL  36CE
380A:  MOVFF  01,194
....................    memaddress = (memaddress<<4) + chartohex(SerialBuffer[3]); 
380E:  MOVLB  1
3810:  SWAPF  x94,W
3812:  MOVWF  x98
3814:  MOVLW  F0
3816:  ANDWF  x98,F
3818:  MOVFF  26,1CE
381C:  MOVLB  0
381E:  RCALL  36CE
3820:  MOVF   01,W
3822:  MOVLB  1
3824:  ADDWF  x98,W
3826:  MOVWF  x94
....................    rcvalue = chartohex(SerialBuffer[5]); 
3828:  MOVFF  28,1CE
382C:  MOVLB  0
382E:  RCALL  36CE
3830:  MOVFF  01,195
....................    rcvalue = (rcvalue<<4) + chartohex(SerialBuffer[6]); 
3834:  MOVLB  1
3836:  SWAPF  x95,W
3838:  MOVWF  x98
383A:  MOVLW  F0
383C:  ANDWF  x98,F
383E:  MOVFF  29,1CE
3842:  MOVLB  0
3844:  RCALL  36CE
3846:  MOVF   01,W
3848:  MOVLB  1
384A:  ADDWF  x98,W
384C:  MOVWF  x95
....................    nb_bytes = chartohex(SerialBuffer[8]); 
384E:  MOVFF  2B,1CE
3852:  MOVLB  0
3854:  RCALL  36CE
3856:  MOVFF  01,196
....................    nb_bytes = (nb_bytes<<4) + chartohex(SerialBuffer[9]); 
385A:  MOVLB  1
385C:  SWAPF  x96,W
385E:  MOVWF  x98
3860:  MOVLW  F0
3862:  ANDWF  x98,F
3864:  MOVFF  2C,1CE
3868:  MOVLB  0
386A:  RCALL  36CE
386C:  MOVF   01,W
386E:  MOVLB  1
3870:  ADDWF  x98,W
3872:  MOVWF  x96
....................    i2c_start(); 
3874:  BSF    FC5.0
3876:  BTFSC  FC5.0
3878:  BRA    3876
....................    i2c_write( memaddress );                                      // Writing Address of the module 
387A:  MOVFF  194,1CB
387E:  MOVLB  0
3880:  CALL   2DEC
....................    i2c_write( rcvalue );                                         // Writing Address of the register 
3884:  MOVFF  195,1CB
3888:  CALL   2DEC
....................    i2c_start(); 
388C:  BSF    FC5.1
388E:  BTFSC  FC5.1
3890:  BRA    388E
....................    i2c_write( memaddress + 1 );                                  // Writing Address of the module in Read Mode 
3892:  MOVLW  01
3894:  MOVLB  1
3896:  ADDWF  x94,W
3898:  MOVWF  x98
389A:  MOVWF  xCB
389C:  MOVLB  0
389E:  CALL   2DEC
....................    if(SerialPort == SERIAL_USB) 
38A2:  MOVF   x74,F
38A4:  BNZ   38B0
....................      fprintf(USB,"r"); 
38A6:  MOVLW  72
38A8:  BTFSS  F9E.4
38AA:  BRA    38A8
38AC:  MOVWF  FAD
....................    else 
38AE:  BRA    38BC
....................      fprintf(BT,"r"); 
38B0:  MOVLW  72
38B2:  BTFSS  FA4.4
38B4:  BRA    38B2
38B6:  MOVLB  F
38B8:  MOVWF  x1C
38BA:  MOVLB  0
....................    while(nb_bytes> 1) 
....................    { 
38BC:  MOVLB  1
38BE:  MOVF   x96,W
38C0:  SUBLW  01
38C2:  BC    390C
....................      TempVal = i2c_read(); 
38C4:  MOVLW  01
38C6:  MOVWF  00
38C8:  MOVLB  0
38CA:  CALL   2E08
38CE:  MOVFF  01,197
....................      if(SerialPort == SERIAL_USB) 
38D2:  MOVF   x74,F
38D4:  BNZ   38EE
....................        fprintf(USB,",%03u",TempVal); 
38D6:  MOVLW  2C
38D8:  BTFSS  F9E.4
38DA:  BRA    38D8
38DC:  MOVWF  FAD
38DE:  MOVFF  197,198
38E2:  MOVLW  03
38E4:  MOVLB  1
38E6:  MOVWF  x99
38E8:  MOVLB  0
38EA:  RCALL  36EE
....................      else 
38EC:  BRA    3906
....................        fprintf(BT,",%03u",TempVal); 
38EE:  MOVLW  2C
38F0:  BTFSS  FA4.4
38F2:  BRA    38F0
38F4:  MOVLB  F
38F6:  MOVWF  x1C
38F8:  MOVFF  197,199
38FC:  MOVLW  03
38FE:  MOVLB  1
3900:  MOVWF  x9A
3902:  MOVLB  0
3904:  RCALL  3770
....................      nb_bytes--; 
3906:  MOVLB  1
3908:  DECF   x96,F
....................    } 
390A:  BRA    38BE
....................    TempVal = i2c_read(0); 
390C:  CLRF   00
390E:  MOVLB  0
3910:  CALL   2E08
3914:  MOVFF  01,197
....................    if(SerialPort == SERIAL_USB) 
3918:  MOVF   x74,F
391A:  BNZ   3944
....................      fprintf(USB,",%03u\r\n",TempVal); 
391C:  MOVLW  2C
391E:  BTFSS  F9E.4
3920:  BRA    391E
3922:  MOVWF  FAD
3924:  MOVFF  197,198
3928:  MOVLW  03
392A:  MOVLB  1
392C:  MOVWF  x99
392E:  MOVLB  0
3930:  RCALL  36EE
3932:  MOVLW  0D
3934:  BTFSS  F9E.4
3936:  BRA    3934
3938:  MOVWF  FAD
393A:  MOVLW  0A
393C:  BTFSS  F9E.4
393E:  BRA    393C
3940:  MOVWF  FAD
....................    else 
3942:  BRA    3970
....................      fprintf(BT,",%03u\r\n",TempVal); 
3944:  MOVLW  2C
3946:  BTFSS  FA4.4
3948:  BRA    3946
394A:  MOVLB  F
394C:  MOVWF  x1C
394E:  MOVFF  197,199
3952:  MOVLW  03
3954:  MOVLB  1
3956:  MOVWF  x9A
3958:  MOVLB  0
395A:  RCALL  3770
395C:  MOVLW  0D
395E:  BTFSS  FA4.4
3960:  BRA    395E
3962:  MOVLB  F
3964:  MOVWF  x1C
3966:  MOVLW  0A
3968:  BTFSS  FA4.4
396A:  BRA    3968
396C:  MOVWF  x1C
396E:  MOVLB  0
....................    i2c_stop(); 
3970:  BSF    FC5.2
3972:  BTFSC  FC5.2
3974:  BRA    3972
.................... } 
3976:  GOTO   49D4 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- Return the receiving TV data                                                 -// 
.................... //--------------------------------------------------------------------------------//  
.................... //#separate 
.................... void __T() 
.................... { 
....................  if(SerialPort == SERIAL_USB) 
*
3AD6:  MOVF   x74,F
3AD8:  BNZ   3B20
....................    fprintf(USB, "t,%03u,%03u\r\n" , TV_ADDR,TV_DATA ); 
3ADA:  MOVLW  74
3ADC:  BTFSS  F9E.4
3ADE:  BRA    3ADC
3AE0:  MOVWF  FAD
3AE2:  MOVLW  2C
3AE4:  BTFSS  F9E.4
3AE6:  BRA    3AE4
3AE8:  MOVWF  FAD
3AEA:  MOVFF  83,198
3AEE:  MOVLW  03
3AF0:  MOVLB  1
3AF2:  MOVWF  x99
3AF4:  MOVLB  0
3AF6:  RCALL  36EE
3AF8:  MOVLW  2C
3AFA:  BTFSS  F9E.4
3AFC:  BRA    3AFA
3AFE:  MOVWF  FAD
3B00:  MOVFF  84,198
3B04:  MOVLW  03
3B06:  MOVLB  1
3B08:  MOVWF  x99
3B0A:  MOVLB  0
3B0C:  RCALL  36EE
3B0E:  MOVLW  0D
3B10:  BTFSS  F9E.4
3B12:  BRA    3B10
3B14:  MOVWF  FAD
3B16:  MOVLW  0A
3B18:  BTFSS  F9E.4
3B1A:  BRA    3B18
3B1C:  MOVWF  FAD
....................  else 
3B1E:  BRA    3B6A
....................    fprintf(BT, "t,%03u,%03u\r\n" , TV_ADDR,TV_DATA ); 
3B20:  MOVLW  74
3B22:  BTFSS  FA4.4
3B24:  BRA    3B22
3B26:  MOVLB  F
3B28:  MOVWF  x1C
3B2A:  MOVLW  2C
3B2C:  BTFSS  FA4.4
3B2E:  BRA    3B2C
3B30:  MOVWF  x1C
3B32:  MOVFF  83,199
3B36:  MOVLW  03
3B38:  MOVLB  1
3B3A:  MOVWF  x9A
3B3C:  MOVLB  0
3B3E:  RCALL  3770
3B40:  MOVLW  2C
3B42:  BTFSS  FA4.4
3B44:  BRA    3B42
3B46:  MOVLB  F
3B48:  MOVWF  x1C
3B4A:  MOVFF  84,199
3B4E:  MOVLW  03
3B50:  MOVLB  1
3B52:  MOVWF  x9A
3B54:  MOVLB  0
3B56:  RCALL  3770
3B58:  MOVLW  0D
3B5A:  BTFSS  FA4.4
3B5C:  BRA    3B5A
3B5E:  MOVLB  F
3B60:  MOVWF  x1C
3B62:  MOVLW  0A
3B64:  BTFSS  FA4.4
3B66:  BRA    3B64
3B68:  MOVWF  x1C
3B6A:  MOVLB  0
.................... } 
3B6C:  GOTO   49D4 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- Send a RC5 data on the IR emitter                                            -// 
.................... //--------------------------------------------------------------------------------//  
.................... //#separate 
.................... void __V() 
.................... { 
....................    unsigned char Arg[5]; 
....................    unsigned char i, j; 
....................    i = 2;                                                                       // Begin with the 3 char (after the first ",") 
3B70:  MOVLW  02
3B72:  MOVLB  1
3B74:  MOVWF  x99
....................    j = 0; 
3B76:  CLRF   x9A
....................    // While there no END of line "\n" or End of Char ",", place the value in a table to convert it  
....................    while((SerialBuffer[ i ] != ',') &&  (SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................    { 
3B78:  CLRF   03
3B7A:  MOVF   x99,W
3B7C:  ADDLW  23
3B7E:  MOVWF  FE9
3B80:  MOVLW  00
3B82:  ADDWFC 03,W
3B84:  MOVWF  FEA
3B86:  MOVF   FEF,W
3B88:  SUBLW  2C
3B8A:  BZ    3BE8
3B8C:  CLRF   03
3B8E:  MOVF   x99,W
3B90:  ADDLW  23
3B92:  MOVWF  FE9
3B94:  MOVLW  00
3B96:  ADDWFC 03,W
3B98:  MOVWF  FEA
3B9A:  MOVF   FEF,W
3B9C:  SUBLW  0A
3B9E:  BZ    3BE8
3BA0:  CLRF   03
3BA2:  MOVF   x99,W
3BA4:  ADDLW  23
3BA6:  MOVWF  FE9
3BA8:  MOVLW  00
3BAA:  ADDWFC 03,W
3BAC:  MOVWF  FEA
3BAE:  MOVF   FEF,W
3BB0:  SUBLW  0D
3BB2:  BZ    3BE8
....................       Arg[j] = SerialBuffer[ i ]; 
3BB4:  CLRF   03
3BB6:  MOVF   x9A,W
3BB8:  ADDLW  94
3BBA:  MOVWF  01
3BBC:  MOVLW  01
3BBE:  ADDWFC 03,F
3BC0:  MOVFF  03,19C
3BC4:  CLRF   03
3BC6:  MOVF   x99,W
3BC8:  ADDLW  23
3BCA:  MOVWF  FE9
3BCC:  MOVLW  00
3BCE:  ADDWFC 03,W
3BD0:  MOVWF  FEA
3BD2:  MOVFF  FEF,19D
3BD6:  MOVFF  19C,FEA
3BDA:  MOVFF  01,FE9
3BDE:  MOVFF  19D,FEF
....................       i++;      
3BE2:  INCF   x99,F
....................       j++; 
3BE4:  INCF   x9A,F
....................    } 
3BE6:  BRA    3B78
....................    Arg[j] ='\0';                                                                // PLace a End of sentence at the end of the values 
3BE8:  CLRF   03
3BEA:  MOVF   x9A,W
3BEC:  ADDLW  94
3BEE:  MOVWF  FE9
3BF0:  MOVLW  01
3BF2:  ADDWFC 03,W
3BF4:  MOVWF  FEA
3BF6:  CLRF   FEF
....................    TV_Addr_send = atoi(Arg);                                                    // Convert the table of value into a unsigned int8 
3BF8:  MOVLW  01
3BFA:  MOVWF  x9D
3BFC:  MOVLW  94
3BFE:  MOVWF  x9C
3C00:  MOVLB  0
3C02:  CALL   1BDC
3C06:  MOVFF  01,87
....................    if((SerialBuffer[ i ] == 10) || (SerialBuffer[ i ] == 13))                   // If the second argument is not set (i.e. "D,20\r\n") return a error 
3C0A:  CLRF   03
3C0C:  MOVLB  1
3C0E:  MOVF   x99,W
3C10:  ADDLW  23
3C12:  MOVWF  FE9
3C14:  MOVLW  00
3C16:  ADDWFC 03,W
3C18:  MOVWF  FEA
3C1A:  MOVF   FEF,W
3C1C:  SUBLW  0A
3C1E:  BZ    3C34
3C20:  CLRF   03
3C22:  MOVF   x99,W
3C24:  ADDLW  23
3C26:  MOVWF  FE9
3C28:  MOVLW  00
3C2A:  ADDWFC 03,W
3C2C:  MOVWF  FEA
3C2E:  MOVF   FEF,W
3C30:  SUBLW  0D
3C32:  BNZ   3C58
....................    { 
....................      if(SerialPort == SERIAL_USB) 
3C34:  MOVLB  0
3C36:  MOVF   x74,F
3C38:  BNZ   3C48
....................       fprintf(USB,"Unknown Command ?!\r\n" ); 
3C3A:  MOVLW  88
3C3C:  MOVWF  FF6
3C3E:  MOVLW  12
3C40:  MOVWF  FF7
3C42:  CALL   141C
....................      else 
3C46:  BRA    3C54
....................       fprintf(BT,"Unknown Command ?!\r\n" ); 
3C48:  MOVLW  9E
3C4A:  MOVWF  FF6
3C4C:  MOVLW  12
3C4E:  MOVWF  FF7
3C50:  CALL   1552
....................    } 
....................    else 
3C54:  BRA    3D30
3C56:  MOVLB  1
....................    { 
....................       i++; 
3C58:  INCF   x99,F
....................       j = 0; 
3C5A:  CLRF   x9A
....................       // While there no END of line "\n" place the value in a table to convert it  
....................       while((SerialBuffer[ i ] != 10) && (SerialBuffer[ i ] != 13)) 
....................       { 
3C5C:  CLRF   03
3C5E:  MOVF   x99,W
3C60:  ADDLW  23
3C62:  MOVWF  FE9
3C64:  MOVLW  00
3C66:  ADDWFC 03,W
3C68:  MOVWF  FEA
3C6A:  MOVF   FEF,W
3C6C:  SUBLW  0A
3C6E:  BZ    3CB8
3C70:  CLRF   03
3C72:  MOVF   x99,W
3C74:  ADDLW  23
3C76:  MOVWF  FE9
3C78:  MOVLW  00
3C7A:  ADDWFC 03,W
3C7C:  MOVWF  FEA
3C7E:  MOVF   FEF,W
3C80:  SUBLW  0D
3C82:  BZ    3CB8
....................          Arg[j] = SerialBuffer[ i ]; 
3C84:  CLRF   03
3C86:  MOVF   x9A,W
3C88:  ADDLW  94
3C8A:  MOVWF  01
3C8C:  MOVLW  01
3C8E:  ADDWFC 03,F
3C90:  MOVFF  03,19C
3C94:  CLRF   03
3C96:  MOVF   x99,W
3C98:  ADDLW  23
3C9A:  MOVWF  FE9
3C9C:  MOVLW  00
3C9E:  ADDWFC 03,W
3CA0:  MOVWF  FEA
3CA2:  MOVFF  FEF,19D
3CA6:  MOVFF  19C,FEA
3CAA:  MOVFF  01,FE9
3CAE:  MOVFF  19D,FEF
....................          i++;      
3CB2:  INCF   x99,F
....................          j++; 
3CB4:  INCF   x9A,F
....................       } 
3CB6:  BRA    3C5C
....................       Arg[j] ='\0';                                                             // PLace a End of sentence at the end of the values 
3CB8:  CLRF   03
3CBA:  MOVF   x9A,W
3CBC:  ADDLW  94
3CBE:  MOVWF  FE9
3CC0:  MOVLW  01
3CC2:  ADDWFC 03,W
3CC4:  MOVWF  FEA
3CC6:  CLRF   FEF
....................       TV_Data_send = atoi(Arg);                                                 // Convert the table of value into a unsigned int8 
3CC8:  MOVLW  01
3CCA:  MOVWF  x9D
3CCC:  MOVLW  94
3CCE:  MOVWF  x9C
3CD0:  MOVLB  0
3CD2:  CALL   1BDC
3CD6:  MOVFF  01,86
....................       TV_Data_emitting = 1;                                                     // Set the flag to indicate that a mesasge must be send 
3CDA:  BSF    x88.1
....................       if(SerialPort == SERIAL_USB) 
3CDC:  MOVF   x74,F
3CDE:  BNZ   3CFA
....................         fprintf(USB,"v\r\n"); 
3CE0:  MOVLW  76
3CE2:  BTFSS  F9E.4
3CE4:  BRA    3CE2
3CE6:  MOVWF  FAD
3CE8:  MOVLW  0D
3CEA:  BTFSS  F9E.4
3CEC:  BRA    3CEA
3CEE:  MOVWF  FAD
3CF0:  MOVLW  0A
3CF2:  BTFSS  F9E.4
3CF4:  BRA    3CF2
3CF6:  MOVWF  FAD
....................       else 
3CF8:  BRA    3D16
....................         fprintf(BT,"v\r\n"); 
3CFA:  MOVLW  76
3CFC:  BTFSS  FA4.4
3CFE:  BRA    3CFC
3D00:  MOVLB  F
3D02:  MOVWF  x1C
3D04:  MOVLW  0D
3D06:  BTFSS  FA4.4
3D08:  BRA    3D06
3D0A:  MOVWF  x1C
3D0C:  MOVLW  0A
3D0E:  BTFSS  FA4.4
3D10:  BRA    3D0E
3D12:  MOVWF  x1C
3D14:  MOVLB  0
....................       while(TV_Data_pending == 1);                                              // If a IR data is receiving, wait until it's done 
3D16:  BTFSC  x88.0
3D18:  BRA    3D16
....................       set_timer0(TIMER0_886); 
3D1A:  MOVLW  F2
3D1C:  MOVWF  FD7
3D1E:  MOVLW  27
3D20:  MOVWF  FD6
....................       setup_timer_0(T0_INTERNAL | T0_DIV_1);                                    // Interrupt every 886 us 
3D22:  MOVLW  88
3D24:  MOVWF  FD5
....................       TV_Counter = 0;                                                           // reset TV_Counter  
3D26:  CLRF   x85
....................       TV_Counter_flag = 0;                                                      // reset the sending phase flag 
3D28:  BCF    22.6
....................       disable_interrupts(INT_EXT);                                              // Disable interrupt of the receiving IR, to avoid receiving its own data 
3D2A:  BCF    FF2.4
....................       disable_interrupts(INT_TIMER1);                                           // disable the timer1 interrupt to avoid perturbation 
3D2C:  BCF    F9D.0
....................       enable_interrupts(INT_TIMER0);                                            // enable the timer0 interrupt to start the emitting 
3D2E:  BSF    FF2.5
....................    }       
....................        
.................... } 
3D30:  GOTO   49D4 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Write a data on the I2C Bus                                                  -// 
.................... //--------------------------------------------------------------------------------//  
.................... //#separate 
.................... void __W(void) 
.................... { 
3D34:  MOVLB  1
3D36:  CLRF   x94
....................    unsigned char rcvalue = 0; 
....................    rcvalue = chartohex(SerialBuffer[2]); 
3D38:  MOVFF  25,1CE
3D3C:  MOVLB  0
3D3E:  RCALL  36CE
3D40:  MOVFF  01,194
....................    rcvalue = (rcvalue<<4) + chartohex(SerialBuffer[3]); 
3D44:  MOVLB  1
3D46:  SWAPF  x94,W
3D48:  MOVWF  x95
3D4A:  MOVLW  F0
3D4C:  ANDWF  x95,F
3D4E:  MOVFF  26,1CE
3D52:  MOVLB  0
3D54:  RCALL  36CE
3D56:  MOVF   01,W
3D58:  MOVLB  1
3D5A:  ADDWF  x95,W
3D5C:  MOVWF  x94
....................    i2c_start(); 
3D5E:  BSF    FC5.0
3D60:  BTFSC  FC5.0
3D62:  BRA    3D60
....................    i2c_write( rcvalue );                                         // Writing Address of the module 
3D64:  MOVFF  194,1CB
3D68:  MOVLB  0
3D6A:  CALL   2DEC
....................    rcvalue = chartohex(SerialBuffer[5]); 
3D6E:  MOVFF  28,1CE
3D72:  RCALL  36CE
3D74:  MOVFF  01,194
....................    rcvalue = (rcvalue<<4) + chartohex(SerialBuffer[6]); 
3D78:  MOVLB  1
3D7A:  SWAPF  x94,W
3D7C:  MOVWF  x95
3D7E:  MOVLW  F0
3D80:  ANDWF  x95,F
3D82:  MOVFF  29,1CE
3D86:  MOVLB  0
3D88:  RCALL  36CE
3D8A:  MOVF   01,W
3D8C:  MOVLB  1
3D8E:  ADDWF  x95,W
3D90:  MOVWF  x94
....................    i2c_write( rcvalue );                                         // Writing Address of the register 
3D92:  MOVFF  194,1CB
3D96:  MOVLB  0
3D98:  CALL   2DEC
....................    rcvalue = chartohex(SerialBuffer[8]); 
3D9C:  MOVFF  2B,1CE
3DA0:  RCALL  36CE
3DA2:  MOVFF  01,194
....................    rcvalue = (rcvalue<<4) + chartohex(SerialBuffer[9]); 
3DA6:  MOVLB  1
3DA8:  SWAPF  x94,W
3DAA:  MOVWF  x95
3DAC:  MOVLW  F0
3DAE:  ANDWF  x95,F
3DB0:  MOVFF  2C,1CE
3DB4:  MOVLB  0
3DB6:  RCALL  36CE
3DB8:  MOVF   01,W
3DBA:  MOVLB  1
3DBC:  ADDWF  x95,W
3DBE:  MOVWF  x94
....................    i2c_write( rcvalue );                                         // Writing Data in the register 
3DC0:  MOVFF  194,1CB
3DC4:  MOVLB  0
3DC6:  CALL   2DEC
....................    i2c_stop(); 
3DCA:  BSF    FC5.2
3DCC:  BTFSC  FC5.2
3DCE:  BRA    3DCC
....................    if(SerialPort == SERIAL_USB) 
3DD0:  MOVF   x74,F
3DD2:  BNZ   3DEE
....................      fprintf(USB,"w\r\n"); 
3DD4:  MOVLW  77
3DD6:  BTFSS  F9E.4
3DD8:  BRA    3DD6
3DDA:  MOVWF  FAD
3DDC:  MOVLW  0D
3DDE:  BTFSS  F9E.4
3DE0:  BRA    3DDE
3DE2:  MOVWF  FAD
3DE4:  MOVLW  0A
3DE6:  BTFSS  F9E.4
3DE8:  BRA    3DE6
3DEA:  MOVWF  FAD
....................    else 
3DEC:  BRA    3E08
....................      fprintf(BT,"w\r\n"); 
3DEE:  MOVLW  77
3DF0:  BTFSS  FA4.4
3DF2:  BRA    3DF0
3DF4:  MOVLB  F
3DF6:  MOVWF  x1C
3DF8:  MOVLW  0D
3DFA:  BTFSS  FA4.4
3DFC:  BRA    3DFA
3DFE:  MOVWF  x1C
3E00:  MOVLW  0A
3E02:  BTFSS  FA4.4
3E04:  BRA    3E02
3E06:  MOVWF  x1C
3E08:  MOVLB  0
....................  
.................... } 
3E0A:  GOTO   49D4 (RETURN)
....................  
.................... void __X(void) 
.................... { 
....................  if(SerialPort == SERIAL_USB) 
3E0E:  MOVF   x74,F
3E10:  BTFSS  FD8.2
3E12:  BRA    413E
....................  { 
....................     fprintf(USB,"x%c%c%c%c",IR_Proximity[ LEFT ] & 0x00FF, (IR_Proximity[ LEFT ]>>8) & 0x00FF  , IR_Proximity[ FrontLEFT ]  & 0xFF , (IR_Proximity[ FrontLEFT ] >> 8)  & 0xFF); 
3E14:  MOVFF  A9,194
3E18:  MOVLB  1
3E1A:  CLRF   x95
3E1C:  MOVFF  AA,196
3E20:  CLRF   x97
3E22:  CLRF   x97
3E24:  MOVFF  AB,198
3E28:  MOVLB  1
3E2A:  CLRF   x99
3E2C:  MOVFF  AC,19A
3E30:  CLRF   x9B
3E32:  CLRF   x9B
3E34:  MOVLW  78
3E36:  BTFSS  F9E.4
3E38:  BRA    3E36
3E3A:  MOVWF  FAD
3E3C:  MOVF   x94,W
3E3E:  BTFSS  F9E.4
3E40:  BRA    3E3E
3E42:  MOVWF  FAD
3E44:  MOVF   x96,W
3E46:  BTFSS  F9E.4
3E48:  BRA    3E46
3E4A:  MOVWF  FAD
3E4C:  MOVF   x98,W
3E4E:  BTFSS  F9E.4
3E50:  BRA    3E4E
3E52:  MOVWF  FAD
3E54:  MOVF   x9A,W
3E56:  BTFSS  F9E.4
3E58:  BRA    3E56
3E5A:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Proximity[ FRONT ]  & 0xFF, (IR_Proximity[ FRONT ] >> 8) & 0xFF , IR_Proximity[ FRONTRIGHT] & 0xFF, (IR_Proximity[ FRONTRIGHT] >> 8) & 0xFF ); 
3E5C:  MOVFF  AD,194
3E60:  MOVLB  1
3E62:  CLRF   x95
3E64:  MOVFF  AE,196
3E68:  CLRF   x97
3E6A:  CLRF   x97
3E6C:  MOVFF  AF,198
3E70:  MOVLB  1
3E72:  CLRF   x99
3E74:  MOVFF  B0,19A
3E78:  CLRF   x9B
3E7A:  CLRF   x9B
3E7C:  MOVF   x94,W
3E7E:  BTFSS  F9E.4
3E80:  BRA    3E7E
3E82:  MOVWF  FAD
3E84:  MOVF   x96,W
3E86:  BTFSS  F9E.4
3E88:  BRA    3E86
3E8A:  MOVWF  FAD
3E8C:  MOVF   x98,W
3E8E:  BTFSS  F9E.4
3E90:  BRA    3E8E
3E92:  MOVWF  FAD
3E94:  MOVF   x9A,W
3E96:  BTFSS  F9E.4
3E98:  BRA    3E96
3E9A:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Proximity[ RIGHT] & 0xFF, (IR_Proximity[ RIGHT] >> 8) & 0xFF , IR_Proximity[ REAR ] & 0xFF ,(IR_Proximity[ REAR ] >> 8) & 0xFF);  
3E9C:  MOVFF  B1,194
3EA0:  MOVLB  1
3EA2:  CLRF   x95
3EA4:  MOVFF  B2,196
3EA8:  CLRF   x97
3EAA:  CLRF   x97
3EAC:  MOVFF  B3,198
3EB0:  MOVLB  1
3EB2:  CLRF   x99
3EB4:  MOVFF  B4,19A
3EB8:  CLRF   x9B
3EBA:  CLRF   x9B
3EBC:  MOVF   x94,W
3EBE:  BTFSS  F9E.4
3EC0:  BRA    3EBE
3EC2:  MOVWF  FAD
3EC4:  MOVF   x96,W
3EC6:  BTFSS  F9E.4
3EC8:  BRA    3EC6
3ECA:  MOVWF  FAD
3ECC:  MOVF   x98,W
3ECE:  BTFSS  F9E.4
3ED0:  BRA    3ECE
3ED2:  MOVWF  FAD
3ED4:  MOVF   x9A,W
3ED6:  BTFSS  F9E.4
3ED8:  BRA    3ED6
3EDA:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Proximity[ GROUNDLEFT ] & 0xFF, (IR_Proximity[ GROUNDLEFT ] >> 8) & 0xFF , IR_Proximity[ GROUNDFRONTLEFT ] & 0xFF, (IR_Proximity[ GROUNDFRONTLEFT ] >> 8) & 0xFF); 
3EDC:  MOVFF  BB,194
3EE0:  MOVLB  1
3EE2:  CLRF   x95
3EE4:  MOVFF  BC,196
3EE8:  CLRF   x97
3EEA:  CLRF   x97
3EEC:  MOVFF  B7,198
3EF0:  MOVLB  1
3EF2:  CLRF   x99
3EF4:  MOVFF  B8,19A
3EF8:  CLRF   x9B
3EFA:  CLRF   x9B
3EFC:  MOVF   x94,W
3EFE:  BTFSS  F9E.4
3F00:  BRA    3EFE
3F02:  MOVWF  FAD
3F04:  MOVF   x96,W
3F06:  BTFSS  F9E.4
3F08:  BRA    3F06
3F0A:  MOVWF  FAD
3F0C:  MOVF   x98,W
3F0E:  BTFSS  F9E.4
3F10:  BRA    3F0E
3F12:  MOVWF  FAD
3F14:  MOVF   x9A,W
3F16:  BTFSS  F9E.4
3F18:  BRA    3F16
3F1A:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Proximity[ GROUNDFRONTRIGHT ] & 0xFF, (IR_Proximity[ GROUNDFRONTRIGHT]>>8) & 0xFF  , IR_Proximity[ GROUNDRIGHT ] & 0xFF, (IR_Proximity[ GROUNDRIGHT ] >> 8) & 0xFF ); 
3F1C:  MOVFF  B9,194
3F20:  MOVLB  1
3F22:  CLRF   x95
3F24:  MOVFF  BA,196
3F28:  CLRF   x97
3F2A:  CLRF   x97
3F2C:  MOVFF  BD,198
3F30:  MOVLB  1
3F32:  CLRF   x99
3F34:  MOVFF  BE,19A
3F38:  CLRF   x9B
3F3A:  CLRF   x9B
3F3C:  MOVF   x94,W
3F3E:  BTFSS  F9E.4
3F40:  BRA    3F3E
3F42:  MOVWF  FAD
3F44:  MOVF   x96,W
3F46:  BTFSS  F9E.4
3F48:  BRA    3F46
3F4A:  MOVWF  FAD
3F4C:  MOVF   x98,W
3F4E:  BTFSS  F9E.4
3F50:  BRA    3F4E
3F52:  MOVWF  FAD
3F54:  MOVF   x9A,W
3F56:  BTFSS  F9E.4
3F58:  BRA    3F56
3F5A:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Light[ LEFT ] & 0x00FF, (IR_Light[ LEFT ]>>8) & 0x00FF  , IR_Light[ FrontLEFT ]  & 0xFF , (IR_Light[ FrontLEFT ] >> 8)  & 0xFF); 
3F5C:  MOVFF  91,194
3F60:  MOVLB  1
3F62:  CLRF   x95
3F64:  MOVFF  92,196
3F68:  CLRF   x97
3F6A:  CLRF   x97
3F6C:  MOVFF  93,198
3F70:  MOVLB  1
3F72:  CLRF   x99
3F74:  MOVFF  94,19A
3F78:  CLRF   x9B
3F7A:  CLRF   x9B
3F7C:  MOVF   x94,W
3F7E:  BTFSS  F9E.4
3F80:  BRA    3F7E
3F82:  MOVWF  FAD
3F84:  MOVF   x96,W
3F86:  BTFSS  F9E.4
3F88:  BRA    3F86
3F8A:  MOVWF  FAD
3F8C:  MOVF   x98,W
3F8E:  BTFSS  F9E.4
3F90:  BRA    3F8E
3F92:  MOVWF  FAD
3F94:  MOVF   x9A,W
3F96:  BTFSS  F9E.4
3F98:  BRA    3F96
3F9A:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Light[ FRONT ]  & 0xFF, (IR_Light[ FRONT ] >> 8) & 0xFF , IR_Light[ FRONTRIGHT] & 0xFF, (IR_Light[ FRONTRIGHT] >> 8) & 0xFF ); 
3F9C:  MOVFF  95,194
3FA0:  MOVLB  1
3FA2:  CLRF   x95
3FA4:  MOVFF  96,196
3FA8:  CLRF   x97
3FAA:  CLRF   x97
3FAC:  MOVFF  97,198
3FB0:  MOVLB  1
3FB2:  CLRF   x99
3FB4:  MOVFF  98,19A
3FB8:  CLRF   x9B
3FBA:  CLRF   x9B
3FBC:  MOVF   x94,W
3FBE:  BTFSS  F9E.4
3FC0:  BRA    3FBE
3FC2:  MOVWF  FAD
3FC4:  MOVF   x96,W
3FC6:  BTFSS  F9E.4
3FC8:  BRA    3FC6
3FCA:  MOVWF  FAD
3FCC:  MOVF   x98,W
3FCE:  BTFSS  F9E.4
3FD0:  BRA    3FCE
3FD2:  MOVWF  FAD
3FD4:  MOVF   x9A,W
3FD6:  BTFSS  F9E.4
3FD8:  BRA    3FD6
3FDA:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Light[ RIGHT] & 0xFF, (IR_Light[ RIGHT] >> 8) & 0xFF , IR_Light[ REAR ] & 0xFF ,(IR_Light[ REAR ] >> 8) & 0xFF);  
3FDC:  MOVFF  99,194
3FE0:  MOVLB  1
3FE2:  CLRF   x95
3FE4:  MOVFF  9A,196
3FE8:  CLRF   x97
3FEA:  CLRF   x97
3FEC:  MOVFF  9B,198
3FF0:  MOVLB  1
3FF2:  CLRF   x99
3FF4:  MOVFF  9C,19A
3FF8:  CLRF   x9B
3FFA:  CLRF   x9B
3FFC:  MOVF   x94,W
3FFE:  BTFSS  F9E.4
4000:  BRA    3FFE
4002:  MOVWF  FAD
4004:  MOVF   x96,W
4006:  BTFSS  F9E.4
4008:  BRA    4006
400A:  MOVWF  FAD
400C:  MOVF   x98,W
400E:  BTFSS  F9E.4
4010:  BRA    400E
4012:  MOVWF  FAD
4014:  MOVF   x9A,W
4016:  BTFSS  F9E.4
4018:  BRA    4016
401A:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Light[ GROUNDLEFT ] & 0xFF, (IR_Light[ GROUNDLEFT ] >> 8) & 0xFF , IR_Light[ GROUNDFRONTLEFT ] & 0xFF, (IR_Light[ GROUNDFRONTLEFT ] >> 8) & 0xFF); 
401C:  MOVFF  A3,194
4020:  MOVLB  1
4022:  CLRF   x95
4024:  MOVFF  A4,196
4028:  CLRF   x97
402A:  CLRF   x97
402C:  MOVFF  9F,198
4030:  MOVLB  1
4032:  CLRF   x99
4034:  MOVFF  A0,19A
4038:  CLRF   x9B
403A:  CLRF   x9B
403C:  MOVF   x94,W
403E:  BTFSS  F9E.4
4040:  BRA    403E
4042:  MOVWF  FAD
4044:  MOVF   x96,W
4046:  BTFSS  F9E.4
4048:  BRA    4046
404A:  MOVWF  FAD
404C:  MOVF   x98,W
404E:  BTFSS  F9E.4
4050:  BRA    404E
4052:  MOVWF  FAD
4054:  MOVF   x9A,W
4056:  BTFSS  F9E.4
4058:  BRA    4056
405A:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c",IR_Light[ GROUNDFRONTRIGHT ] & 0xFF, (IR_Light[ GROUNDFRONTRIGHT]>>8) & 0xFF  , IR_Light[ GROUNDRIGHT ] & 0xFF, (IR_Light[ GROUNDRIGHT ] >> 8) & 0xFF ); 
405C:  MOVFF  A1,194
4060:  MOVLB  1
4062:  CLRF   x95
4064:  MOVFF  A2,196
4068:  CLRF   x97
406A:  CLRF   x97
406C:  MOVFF  A5,198
4070:  MOVLB  1
4072:  CLRF   x99
4074:  MOVFF  A6,19A
4078:  CLRF   x9B
407A:  CLRF   x9B
407C:  MOVF   x94,W
407E:  BTFSS  F9E.4
4080:  BRA    407E
4082:  MOVWF  FAD
4084:  MOVF   x96,W
4086:  BTFSS  F9E.4
4088:  BRA    4086
408A:  MOVWF  FAD
408C:  MOVF   x98,W
408E:  BTFSS  F9E.4
4090:  BRA    408E
4092:  MOVWF  FAD
4094:  MOVF   x9A,W
4096:  BTFSS  F9E.4
4098:  BRA    4096
409A:  MOVWF  FAD
....................     fprintf(USB,"%c%c%c%c%c%c%c%c%c\r\n",PwmMotLeft, PwmMotRight, Switchs, TV_ADDR, TV_DATA, TimeTip & 0xFF, (TimeTip >> 8) &0xFF, (TimeTip >> 16) & 0xFF, (TimeTip >> 24) &0xFF ); 
409C:  MOVFF  8A,194
40A0:  MOVLB  1
40A2:  CLRF   x95
40A4:  CLRF   x96
40A6:  CLRF   x97
40A8:  MOVFF  8B,199
40AC:  MOVFF  8C,19A
40B0:  MOVFF  8D,19B
40B4:  CLRF   x9C
40B6:  CLRF   x9A
40B8:  CLRF   x9B
40BA:  CLRF   x9C
40BC:  MOVFF  8C,19E
40C0:  MOVFF  8D,19F
40C4:  CLRF   xA0
40C6:  CLRF   xA1
40C8:  CLRF   x9F
40CA:  CLRF   xA0
40CC:  CLRF   xA1
40CE:  MOVFF  8D,1A3
40D2:  CLRF   xA4
40D4:  CLRF   xA5
40D6:  CLRF   xA6
40D8:  CLRF   xA4
40DA:  CLRF   xA5
40DC:  CLRF   xA6
40DE:  MOVF   1A,W
40E0:  BTFSS  F9E.4
40E2:  BRA    40E0
40E4:  MOVWF  FAD
40E6:  MOVF   1B,W
40E8:  BTFSS  F9E.4
40EA:  BRA    40E8
40EC:  MOVWF  FAD
40EE:  MOVF   x01,W
40F0:  BTFSS  F9E.4
40F2:  BRA    40F0
40F4:  MOVWF  FAD
40F6:  MOVLB  0
40F8:  MOVF   x83,W
40FA:  BTFSS  F9E.4
40FC:  BRA    40FA
40FE:  MOVWF  FAD
4100:  MOVF   x84,W
4102:  BTFSS  F9E.4
4104:  BRA    4102
4106:  MOVWF  FAD
4108:  MOVLB  1
410A:  MOVF   x94,W
410C:  BTFSS  F9E.4
410E:  BRA    410C
4110:  MOVWF  FAD
4112:  MOVF   x99,W
4114:  BTFSS  F9E.4
4116:  BRA    4114
4118:  MOVWF  FAD
411A:  MOVF   x9E,W
411C:  BTFSS  F9E.4
411E:  BRA    411C
4120:  MOVWF  FAD
4122:  MOVF   xA3,W
4124:  BTFSS  F9E.4
4126:  BRA    4124
4128:  MOVWF  FAD
412A:  MOVLW  0D
412C:  BTFSS  F9E.4
412E:  BRA    412C
4130:  MOVWF  FAD
4132:  MOVLW  0A
4134:  BTFSS  F9E.4
4136:  BRA    4134
4138:  MOVWF  FAD
.................... } 
....................  else 
413A:  BRA    4510
413C:  MOVLB  0
....................  { 
....................     fprintf(BT,"x%c%c%c%c",IR_Proximity[ LEFT ] & 0x00FF, (IR_Proximity[ LEFT ]>>8) & 0x00FF  , IR_Proximity[ FrontLEFT ]  & 0xFF , (IR_Proximity[ FrontLEFT ] >> 8)  & 0xFF); 
413E:  MOVFF  A9,194
4142:  MOVLB  1
4144:  CLRF   x95
4146:  MOVFF  AA,196
414A:  CLRF   x97
414C:  CLRF   x97
414E:  MOVFF  AB,198
4152:  MOVLB  1
4154:  CLRF   x99
4156:  MOVFF  AC,19A
415A:  CLRF   x9B
415C:  CLRF   x9B
415E:  MOVLW  78
4160:  BTFSS  FA4.4
4162:  BRA    4160
4164:  MOVLB  F
4166:  MOVWF  x1C
4168:  MOVLB  1
416A:  MOVF   x94,W
416C:  BTFSS  FA4.4
416E:  BRA    416C
4170:  MOVLB  F
4172:  MOVWF  x1C
4174:  MOVLB  1
4176:  MOVF   x96,W
4178:  BTFSS  FA4.4
417A:  BRA    4178
417C:  MOVLB  F
417E:  MOVWF  x1C
4180:  MOVLB  1
4182:  MOVF   x98,W
4184:  BTFSS  FA4.4
4186:  BRA    4184
4188:  MOVLB  F
418A:  MOVWF  x1C
418C:  MOVLB  1
418E:  MOVF   x9A,W
4190:  BTFSS  FA4.4
4192:  BRA    4190
4194:  MOVLB  F
4196:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Proximity[ FRONT ]  & 0xFF, (IR_Proximity[ FRONT ] >> 8) & 0xFF , IR_Proximity[ FRONTRIGHT] & 0xFF, (IR_Proximity[ FRONTRIGHT] >> 8) & 0xFF ); 
4198:  MOVFF  AD,194
419C:  MOVLB  1
419E:  CLRF   x95
41A0:  MOVFF  AE,196
41A4:  CLRF   x97
41A6:  CLRF   x97
41A8:  MOVFF  AF,198
41AC:  MOVLB  1
41AE:  CLRF   x99
41B0:  MOVFF  B0,19A
41B4:  CLRF   x9B
41B6:  CLRF   x9B
41B8:  MOVF   x94,W
41BA:  BTFSS  FA4.4
41BC:  BRA    41BA
41BE:  MOVLB  F
41C0:  MOVWF  x1C
41C2:  MOVLB  1
41C4:  MOVF   x96,W
41C6:  BTFSS  FA4.4
41C8:  BRA    41C6
41CA:  MOVLB  F
41CC:  MOVWF  x1C
41CE:  MOVLB  1
41D0:  MOVF   x98,W
41D2:  BTFSS  FA4.4
41D4:  BRA    41D2
41D6:  MOVLB  F
41D8:  MOVWF  x1C
41DA:  MOVLB  1
41DC:  MOVF   x9A,W
41DE:  BTFSS  FA4.4
41E0:  BRA    41DE
41E2:  MOVLB  F
41E4:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Proximity[ RIGHT] & 0xFF, (IR_Proximity[ RIGHT] >> 8) & 0xFF , IR_Proximity[ REAR ] & 0xFF ,(IR_Proximity[ REAR ] >> 8) & 0xFF);  
41E6:  MOVFF  B1,194
41EA:  MOVLB  1
41EC:  CLRF   x95
41EE:  MOVFF  B2,196
41F2:  CLRF   x97
41F4:  CLRF   x97
41F6:  MOVFF  B3,198
41FA:  MOVLB  1
41FC:  CLRF   x99
41FE:  MOVFF  B4,19A
4202:  CLRF   x9B
4204:  CLRF   x9B
4206:  MOVF   x94,W
4208:  BTFSS  FA4.4
420A:  BRA    4208
420C:  MOVLB  F
420E:  MOVWF  x1C
4210:  MOVLB  1
4212:  MOVF   x96,W
4214:  BTFSS  FA4.4
4216:  BRA    4214
4218:  MOVLB  F
421A:  MOVWF  x1C
421C:  MOVLB  1
421E:  MOVF   x98,W
4220:  BTFSS  FA4.4
4222:  BRA    4220
4224:  MOVLB  F
4226:  MOVWF  x1C
4228:  MOVLB  1
422A:  MOVF   x9A,W
422C:  BTFSS  FA4.4
422E:  BRA    422C
4230:  MOVLB  F
4232:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Proximity[ GROUNDLEFT ] & 0xFF, (IR_Proximity[ GROUNDLEFT ] >> 8) & 0xFF , IR_Proximity[ GROUNDFRONTLEFT ] & 0xFF, (IR_Proximity[ GROUNDFRONTLEFT ] >> 8) & 0xFF); 
4234:  MOVFF  BB,194
4238:  MOVLB  1
423A:  CLRF   x95
423C:  MOVFF  BC,196
4240:  CLRF   x97
4242:  CLRF   x97
4244:  MOVFF  B7,198
4248:  MOVLB  1
424A:  CLRF   x99
424C:  MOVFF  B8,19A
4250:  CLRF   x9B
4252:  CLRF   x9B
4254:  MOVF   x94,W
4256:  BTFSS  FA4.4
4258:  BRA    4256
425A:  MOVLB  F
425C:  MOVWF  x1C
425E:  MOVLB  1
4260:  MOVF   x96,W
4262:  BTFSS  FA4.4
4264:  BRA    4262
4266:  MOVLB  F
4268:  MOVWF  x1C
426A:  MOVLB  1
426C:  MOVF   x98,W
426E:  BTFSS  FA4.4
4270:  BRA    426E
4272:  MOVLB  F
4274:  MOVWF  x1C
4276:  MOVLB  1
4278:  MOVF   x9A,W
427A:  BTFSS  FA4.4
427C:  BRA    427A
427E:  MOVLB  F
4280:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Proximity[ GROUNDFRONTRIGHT ] & 0xFF, (IR_Proximity[ GROUNDFRONTRIGHT]>>8) & 0xFF  , IR_Proximity[ GROUNDRIGHT ] & 0xFF, (IR_Proximity[ GROUNDRIGHT ] >> 8) & 0xFF ); 
4282:  MOVFF  B9,194
4286:  MOVLB  1
4288:  CLRF   x95
428A:  MOVFF  BA,196
428E:  CLRF   x97
4290:  CLRF   x97
4292:  MOVFF  BD,198
4296:  MOVLB  1
4298:  CLRF   x99
429A:  MOVFF  BE,19A
429E:  CLRF   x9B
42A0:  CLRF   x9B
42A2:  MOVF   x94,W
42A4:  BTFSS  FA4.4
42A6:  BRA    42A4
42A8:  MOVLB  F
42AA:  MOVWF  x1C
42AC:  MOVLB  1
42AE:  MOVF   x96,W
42B0:  BTFSS  FA4.4
42B2:  BRA    42B0
42B4:  MOVLB  F
42B6:  MOVWF  x1C
42B8:  MOVLB  1
42BA:  MOVF   x98,W
42BC:  BTFSS  FA4.4
42BE:  BRA    42BC
42C0:  MOVLB  F
42C2:  MOVWF  x1C
42C4:  MOVLB  1
42C6:  MOVF   x9A,W
42C8:  BTFSS  FA4.4
42CA:  BRA    42C8
42CC:  MOVLB  F
42CE:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Light[ LEFT ] & 0x00FF, (IR_Light[ LEFT ]>>8) & 0x00FF  , IR_Light[ FrontLEFT ]  & 0xFF , (IR_Light[ FrontLEFT ] >> 8)  & 0xFF); 
42D0:  MOVFF  91,194
42D4:  MOVLB  1
42D6:  CLRF   x95
42D8:  MOVFF  92,196
42DC:  CLRF   x97
42DE:  CLRF   x97
42E0:  MOVFF  93,198
42E4:  MOVLB  1
42E6:  CLRF   x99
42E8:  MOVFF  94,19A
42EC:  CLRF   x9B
42EE:  CLRF   x9B
42F0:  MOVF   x94,W
42F2:  BTFSS  FA4.4
42F4:  BRA    42F2
42F6:  MOVLB  F
42F8:  MOVWF  x1C
42FA:  MOVLB  1
42FC:  MOVF   x96,W
42FE:  BTFSS  FA4.4
4300:  BRA    42FE
4302:  MOVLB  F
4304:  MOVWF  x1C
4306:  MOVLB  1
4308:  MOVF   x98,W
430A:  BTFSS  FA4.4
430C:  BRA    430A
430E:  MOVLB  F
4310:  MOVWF  x1C
4312:  MOVLB  1
4314:  MOVF   x9A,W
4316:  BTFSS  FA4.4
4318:  BRA    4316
431A:  MOVLB  F
431C:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Light[ FRONT ]  & 0xFF, (IR_Light[ FRONT ] >> 8) & 0xFF , IR_Light[ FRONTRIGHT] & 0xFF, (IR_Light[ FRONTRIGHT] >> 8) & 0xFF ); 
431E:  MOVFF  95,194
4322:  MOVLB  1
4324:  CLRF   x95
4326:  MOVFF  96,196
432A:  CLRF   x97
432C:  CLRF   x97
432E:  MOVFF  97,198
4332:  MOVLB  1
4334:  CLRF   x99
4336:  MOVFF  98,19A
433A:  CLRF   x9B
433C:  CLRF   x9B
433E:  MOVF   x94,W
4340:  BTFSS  FA4.4
4342:  BRA    4340
4344:  MOVLB  F
4346:  MOVWF  x1C
4348:  MOVLB  1
434A:  MOVF   x96,W
434C:  BTFSS  FA4.4
434E:  BRA    434C
4350:  MOVLB  F
4352:  MOVWF  x1C
4354:  MOVLB  1
4356:  MOVF   x98,W
4358:  BTFSS  FA4.4
435A:  BRA    4358
435C:  MOVLB  F
435E:  MOVWF  x1C
4360:  MOVLB  1
4362:  MOVF   x9A,W
4364:  BTFSS  FA4.4
4366:  BRA    4364
4368:  MOVLB  F
436A:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Light[ RIGHT] & 0xFF, (IR_Light[ RIGHT] >> 8) & 0xFF , IR_Light[ REAR ] & 0xFF ,(IR_Light[ REAR ] >> 8) & 0xFF);  
436C:  MOVFF  99,194
4370:  MOVLB  1
4372:  CLRF   x95
4374:  MOVFF  9A,196
4378:  CLRF   x97
437A:  CLRF   x97
437C:  MOVFF  9B,198
4380:  MOVLB  1
4382:  CLRF   x99
4384:  MOVFF  9C,19A
4388:  CLRF   x9B
438A:  CLRF   x9B
438C:  MOVF   x94,W
438E:  BTFSS  FA4.4
4390:  BRA    438E
4392:  MOVLB  F
4394:  MOVWF  x1C
4396:  MOVLB  1
4398:  MOVF   x96,W
439A:  BTFSS  FA4.4
439C:  BRA    439A
439E:  MOVLB  F
43A0:  MOVWF  x1C
43A2:  MOVLB  1
43A4:  MOVF   x98,W
43A6:  BTFSS  FA4.4
43A8:  BRA    43A6
43AA:  MOVLB  F
43AC:  MOVWF  x1C
43AE:  MOVLB  1
43B0:  MOVF   x9A,W
43B2:  BTFSS  FA4.4
43B4:  BRA    43B2
43B6:  MOVLB  F
43B8:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Light[ GROUNDLEFT ] & 0xFF, (IR_Light[ GROUNDLEFT ] >> 8) & 0xFF , IR_Light[ GROUNDFRONTLEFT ] & 0xFF, (IR_Light[ GROUNDFRONTLEFT ] >> 8) & 0xFF); 
43BA:  MOVFF  A3,194
43BE:  MOVLB  1
43C0:  CLRF   x95
43C2:  MOVFF  A4,196
43C6:  CLRF   x97
43C8:  CLRF   x97
43CA:  MOVFF  9F,198
43CE:  MOVLB  1
43D0:  CLRF   x99
43D2:  MOVFF  A0,19A
43D6:  CLRF   x9B
43D8:  CLRF   x9B
43DA:  MOVF   x94,W
43DC:  BTFSS  FA4.4
43DE:  BRA    43DC
43E0:  MOVLB  F
43E2:  MOVWF  x1C
43E4:  MOVLB  1
43E6:  MOVF   x96,W
43E8:  BTFSS  FA4.4
43EA:  BRA    43E8
43EC:  MOVLB  F
43EE:  MOVWF  x1C
43F0:  MOVLB  1
43F2:  MOVF   x98,W
43F4:  BTFSS  FA4.4
43F6:  BRA    43F4
43F8:  MOVLB  F
43FA:  MOVWF  x1C
43FC:  MOVLB  1
43FE:  MOVF   x9A,W
4400:  BTFSS  FA4.4
4402:  BRA    4400
4404:  MOVLB  F
4406:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c",IR_Light[ GROUNDFRONTRIGHT ] & 0xFF, (IR_Light[ GROUNDFRONTRIGHT]>>8) & 0xFF  , IR_Light[ GROUNDRIGHT ] & 0xFF, (IR_Light[ GROUNDRIGHT ] >> 8) & 0xFF ); 
4408:  MOVFF  A1,194
440C:  MOVLB  1
440E:  CLRF   x95
4410:  MOVFF  A2,196
4414:  CLRF   x97
4416:  CLRF   x97
4418:  MOVFF  A5,198
441C:  MOVLB  1
441E:  CLRF   x99
4420:  MOVFF  A6,19A
4424:  CLRF   x9B
4426:  CLRF   x9B
4428:  MOVF   x94,W
442A:  BTFSS  FA4.4
442C:  BRA    442A
442E:  MOVLB  F
4430:  MOVWF  x1C
4432:  MOVLB  1
4434:  MOVF   x96,W
4436:  BTFSS  FA4.4
4438:  BRA    4436
443A:  MOVLB  F
443C:  MOVWF  x1C
443E:  MOVLB  1
4440:  MOVF   x98,W
4442:  BTFSS  FA4.4
4444:  BRA    4442
4446:  MOVLB  F
4448:  MOVWF  x1C
444A:  MOVLB  1
444C:  MOVF   x9A,W
444E:  BTFSS  FA4.4
4450:  BRA    444E
4452:  MOVLB  F
4454:  MOVWF  x1C
....................     fprintf(BT,"%c%c%c%c%c%c%c%c%c\r\n",PwmMotLeft, PwmMotRight, Switchs, TV_ADDR, TV_DATA, TimeTip & 0xFF, (TimeTip >> 8) &0xFF, (TimeTip >> 16) & 0xFF, (TimeTip >> 24) &0xFF ); 
4456:  MOVFF  8A,194
445A:  MOVLB  1
445C:  CLRF   x95
445E:  CLRF   x96
4460:  CLRF   x97
4462:  MOVFF  8B,199
4466:  MOVFF  8C,19A
446A:  MOVFF  8D,19B
446E:  CLRF   x9C
4470:  CLRF   x9A
4472:  CLRF   x9B
4474:  CLRF   x9C
4476:  MOVFF  8C,19E
447A:  MOVFF  8D,19F
447E:  CLRF   xA0
4480:  CLRF   xA1
4482:  CLRF   x9F
4484:  CLRF   xA0
4486:  CLRF   xA1
4488:  MOVFF  8D,1A3
448C:  CLRF   xA4
448E:  CLRF   xA5
4490:  CLRF   xA6
4492:  CLRF   xA4
4494:  CLRF   xA5
4496:  CLRF   xA6
4498:  MOVF   1A,W
449A:  BTFSS  FA4.4
449C:  BRA    449A
449E:  MOVLB  F
44A0:  MOVWF  x1C
44A2:  MOVF   1B,W
44A4:  BTFSS  FA4.4
44A6:  BRA    44A4
44A8:  MOVWF  x1C
44AA:  MOVLB  1
44AC:  MOVF   x01,W
44AE:  BTFSS  FA4.4
44B0:  BRA    44AE
44B2:  MOVLB  F
44B4:  MOVWF  x1C
44B6:  MOVLB  0
44B8:  MOVF   x83,W
44BA:  BTFSS  FA4.4
44BC:  BRA    44BA
44BE:  MOVLB  F
44C0:  MOVWF  x1C
44C2:  MOVLB  0
44C4:  MOVF   x84,W
44C6:  BTFSS  FA4.4
44C8:  BRA    44C6
44CA:  MOVLB  F
44CC:  MOVWF  x1C
44CE:  MOVLB  1
44D0:  MOVF   x94,W
44D2:  BTFSS  FA4.4
44D4:  BRA    44D2
44D6:  MOVLB  F
44D8:  MOVWF  x1C
44DA:  MOVLB  1
44DC:  MOVF   x99,W
44DE:  BTFSS  FA4.4
44E0:  BRA    44DE
44E2:  MOVLB  F
44E4:  MOVWF  x1C
44E6:  MOVLB  1
44E8:  MOVF   x9E,W
44EA:  BTFSS  FA4.4
44EC:  BRA    44EA
44EE:  MOVLB  F
44F0:  MOVWF  x1C
44F2:  MOVLB  1
44F4:  MOVF   xA3,W
44F6:  BTFSS  FA4.4
44F8:  BRA    44F6
44FA:  MOVLB  F
44FC:  MOVWF  x1C
44FE:  MOVLW  0D
4500:  BTFSS  FA4.4
4502:  BRA    4500
4504:  MOVWF  x1C
4506:  MOVLW  0A
4508:  BTFSS  FA4.4
450A:  BRA    4508
450C:  MOVWF  x1C
450E:  MOVLB  1
....................   
....................  } 
....................  
.................... } 
4510:  MOVLB  0
4512:  GOTO   49D4 (RETURN)
....................  
.................... void __C(void) 
.................... { 
....................   unsigned char BT_name; 
....................  
....................   SerialCounter = 0;   
*
20F8:  CLRF   x73
....................   SerialCommandOK = 0; 
20FA:  BCF    22.4
....................   BT_config = 1;                                                                // Set the flag to receive more than one line 
20FC:  MOVLW  01
20FE:  MOVLB  1
2100:  MOVWF  x22
....................   delay_ms(500); 
2102:  MOVLW  02
2104:  MOVWF  x95
2106:  MOVLW  FA
2108:  MOVWF  x96
210A:  MOVLB  0
210C:  CALL   13F2
2110:  MOVLB  1
2112:  DECFSZ x95,F
2114:  BRA    2106
....................   fprintf(BT,"+++");                                                                // Deconnect the Bluetooth communication 
2116:  MOVLW  2B
2118:  BTFSS  FA4.4
211A:  BRA    2118
211C:  MOVLB  F
211E:  MOVWF  x1C
2120:  MOVLW  2B
2122:  BTFSS  FA4.4
2124:  BRA    2122
2126:  MOVWF  x1C
2128:  MOVLW  2B
212A:  BTFSS  FA4.4
212C:  BRA    212A
212E:  MOVWF  x1C
....................   delay_ms(800); 
2130:  MOVLW  04
2132:  MOVLB  1
2134:  MOVWF  x95
2136:  MOVLW  C8
2138:  MOVWF  x96
213A:  MOVLB  0
213C:  CALL   13F2
2140:  MOVLB  1
2142:  DECFSZ x95,F
2144:  BRA    2136
....................   SerialCounter = 0;   
2146:  MOVLB  0
2148:  CLRF   x73
....................   SerialCommandOK = 0; 
214A:  BCF    22.4
....................   fprintf(BT,"SET\n");                                                              // Ask for the different info of the Bluetooth module 
214C:  MOVLW  B4
214E:  MOVWF  FF6
2150:  MOVLW  12
2152:  MOVWF  FF7
2154:  CALL   1552
....................   delay_ms(1500); 
2158:  MOVLW  06
215A:  MOVLB  1
215C:  MOVWF  x95
215E:  MOVLW  FA
2160:  MOVWF  x96
2162:  MOVLB  0
2164:  CALL   13F2
2168:  MOVLB  1
216A:  DECFSZ x95,F
216C:  BRA    215E
....................   BT_Name = SerialBuffer[54];                                                   // Save the letter which define the Type of K-Junior 
216E:  MOVFF  59,194
....................   SerialCounter = 0;                                                            // Reset the serial buffer 
2172:  MOVLB  0
2174:  CLRF   x73
....................   fprintf(BT,"SELECT 0\n");                                                         // Re-active the communication 
2176:  MOVLW  BA
2178:  MOVWF  FF6
217A:  MOVLW  12
217C:  MOVWF  FF7
217E:  CALL   1552
....................   delay_ms(1000);                                                               // Wait until the communication has restart 
2182:  MOVLW  04
2184:  MOVLB  1
2186:  MOVWF  x95
2188:  MOVLW  FA
218A:  MOVWF  x96
218C:  MOVLB  0
218E:  CALL   13F2
2192:  MOVLB  1
2194:  DECFSZ x95,F
2196:  BRA    2188
....................   BT_config = 0; 
2198:  CLRF   x22
....................   if(SerialPort == SERIAL_USB) 
219A:  MOVLB  0
219C:  MOVF   x74,F
219E:  BNZ   21CE
....................     fprintf(USB,"c,%c\r\n",BT_name) ;                                           // Send the return command and the type of the K-Junior (0 = Standard, P = Pedagogique) 
21A0:  MOVLW  63
21A2:  BTFSS  F9E.4
21A4:  BRA    21A2
21A6:  MOVWF  FAD
21A8:  MOVLW  2C
21AA:  BTFSS  F9E.4
21AC:  BRA    21AA
21AE:  MOVWF  FAD
21B0:  MOVLB  1
21B2:  MOVF   x94,W
21B4:  BTFSS  F9E.4
21B6:  BRA    21B4
21B8:  MOVWF  FAD
21BA:  MOVLW  0D
21BC:  BTFSS  F9E.4
21BE:  BRA    21BC
21C0:  MOVWF  FAD
21C2:  MOVLW  0A
21C4:  BTFSS  F9E.4
21C6:  BRA    21C4
21C8:  MOVWF  FAD
....................   else 
21CA:  BRA    21FE
21CC:  MOVLB  0
....................     fprintf(BT,"c,%c\r\n",BT_name) ;                                            // Send the return command and the type of the K-Junior (0 = Standard, P = Pedagogique) 
21CE:  MOVLW  63
21D0:  BTFSS  FA4.4
21D2:  BRA    21D0
21D4:  MOVLB  F
21D6:  MOVWF  x1C
21D8:  MOVLW  2C
21DA:  BTFSS  FA4.4
21DC:  BRA    21DA
21DE:  MOVWF  x1C
21E0:  MOVLB  1
21E2:  MOVF   x94,W
21E4:  BTFSS  FA4.4
21E6:  BRA    21E4
21E8:  MOVLB  F
21EA:  MOVWF  x1C
21EC:  MOVLW  0D
21EE:  BTFSS  FA4.4
21F0:  BRA    21EE
21F2:  MOVWF  x1C
21F4:  MOVLW  0A
21F6:  BTFSS  FA4.4
21F8:  BRA    21F6
21FA:  MOVWF  x1C
21FC:  MOVLB  1
.................... } 
21FE:  MOVLB  0
2200:  GOTO   49D4 (RETURN)
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Write many Data on the I2C Bus                                               -// 
.................... //--------------------------------------------------------------------------------//  
.................... //#separate 
.................... void __Y(void) 
.................... { 
*
4516:  MOVLB  1
4518:  CLRF   x94
451A:  CLRF   x95
451C:  CLRF   xC8
....................    unsigned char Addresse = 0; 
....................    unsigned char registre = 0; 
....................    unsigned char rcvalue[50]; 
....................    unsigned char nb_bytes = 0; 
....................    unsigned char i; 
....................    Addresse = chartohex(SerialBuffer[2]); 
451E:  MOVFF  25,1CE
4522:  MOVLB  0
4524:  CALL   36CE
4528:  MOVFF  01,194
....................    Addresse = (Addresse<<4) + chartohex(SerialBuffer[3]); 
452C:  MOVLB  1
452E:  SWAPF  x94,W
4530:  MOVWF  xCA
4532:  MOVLW  F0
4534:  ANDWF  xCA,F
4536:  MOVFF  26,1CE
453A:  MOVLB  0
453C:  CALL   36CE
4540:  MOVF   01,W
4542:  MOVLB  1
4544:  ADDWF  xCA,W
4546:  MOVWF  x94
....................  
....................    registre = chartohex(SerialBuffer[5]); 
4548:  MOVFF  28,1CE
454C:  MOVLB  0
454E:  CALL   36CE
4552:  MOVFF  01,195
....................    registre = (registre<<4) + chartohex(SerialBuffer[6]); 
4556:  MOVLB  1
4558:  SWAPF  x95,W
455A:  MOVWF  xCA
455C:  MOVLW  F0
455E:  ANDWF  xCA,F
4560:  MOVFF  29,1CE
4564:  MOVLB  0
4566:  CALL   36CE
456A:  MOVF   01,W
456C:  MOVLB  1
456E:  ADDWF  xCA,W
4570:  MOVWF  x95
....................    nb_bytes = chartohex(SerialBuffer[8]); 
4572:  MOVFF  2B,1CE
4576:  MOVLB  0
4578:  CALL   36CE
457C:  MOVFF  01,1C8
....................    nb_bytes = (nb_bytes<<4) + chartohex(SerialBuffer[9]);        // Number of Data to Write 
4580:  MOVLB  1
4582:  SWAPF  xC8,W
4584:  MOVWF  xCA
4586:  MOVLW  F0
4588:  ANDWF  xCA,F
458A:  MOVFF  2C,1CE
458E:  MOVLB  0
4590:  CALL   36CE
4594:  MOVF   01,W
4596:  MOVLB  1
4598:  ADDWF  xCA,W
459A:  MOVWF  xC8
....................  
....................    for(i=0;i<nb_bytes;i++) 
459C:  CLRF   xC9
459E:  MOVF   xC8,W
45A0:  SUBWF  xC9,W
45A2:  BC    4648
....................    { 
....................       rcvalue[i] = chartohex(SerialBuffer[11+i+i+i]); 
45A4:  CLRF   03
45A6:  MOVF   xC9,W
45A8:  ADDLW  96
45AA:  MOVWF  01
45AC:  MOVLW  01
45AE:  ADDWFC 03,F
45B0:  MOVFF  01,1CA
45B4:  MOVFF  03,1CB
45B8:  MOVLW  0B
45BA:  ADDWF  xC9,W
45BC:  ADDWF  xC9,W
45BE:  ADDWF  xC9,W
45C0:  CLRF   03
45C2:  ADDLW  23
45C4:  MOVWF  FE9
45C6:  MOVLW  00
45C8:  ADDWFC 03,W
45CA:  MOVWF  FEA
45CC:  MOVFF  FEF,1CC
45D0:  MOVFF  1CC,1CE
45D4:  MOVLB  0
45D6:  CALL   36CE
45DA:  MOVFF  1CB,FEA
45DE:  MOVFF  1CA,FE9
45E2:  MOVFF  01,FEF
....................       rcvalue[i] = (rcvalue[i]<<4) + chartohex(SerialBuffer[12+i+i+i]); 
45E6:  CLRF   03
45E8:  MOVLB  1
45EA:  MOVF   xC9,W
45EC:  ADDLW  96
45EE:  MOVWF  01
45F0:  MOVLW  01
45F2:  ADDWFC 03,F
45F4:  MOVFF  01,1CA
45F8:  MOVFF  03,1CB
45FC:  CLRF   03
45FE:  MOVF   xC9,W
4600:  ADDLW  96
4602:  MOVWF  FE9
4604:  MOVLW  01
4606:  ADDWFC 03,W
4608:  MOVWF  FEA
460A:  SWAPF  FEF,W
460C:  MOVWF  xCC
460E:  MOVLW  F0
4610:  ANDWF  xCC,F
4612:  MOVLW  0C
4614:  ADDWF  xC9,W
4616:  ADDWF  xC9,W
4618:  ADDWF  xC9,W
461A:  CLRF   03
461C:  ADDLW  23
461E:  MOVWF  FE9
4620:  MOVLW  00
4622:  ADDWFC 03,W
4624:  MOVWF  FEA
4626:  MOVFF  FEF,1CD
462A:  MOVFF  1CD,1CE
462E:  MOVLB  0
4630:  CALL   36CE
4634:  MOVF   01,W
4636:  MOVLB  1
4638:  ADDWF  xCC,W
463A:  MOVFF  1CB,FEA
463E:  MOVFF  1CA,FE9
4642:  MOVWF  FEF
....................       //delay_ms(1);                     // Needed for module ??? 
....................    } 
4644:  INCF   xC9,F
4646:  BRA    459E
....................     
....................    i2c_start(); 
4648:  BSF    FC5.0
464A:  BTFSC  FC5.0
464C:  BRA    464A
....................    i2c_write( Addresse );                                           // Writing Address of the module 
464E:  MOVFF  194,1CB
4652:  MOVLB  0
4654:  CALL   2DEC
....................    i2c_write( registre );                                           // Writing Address of the register 
4658:  MOVFF  195,1CB
465C:  CALL   2DEC
....................    for(i=0;i<nb_bytes;i++) 
4660:  MOVLB  1
4662:  CLRF   xC9
4664:  MOVF   xC8,W
4666:  SUBWF  xC9,W
4668:  BC    468C
....................    { 
....................       i2c_write( rcvalue[i] );                                        // Writing Data in the register 
466A:  CLRF   03
466C:  MOVF   xC9,W
466E:  ADDLW  96
4670:  MOVWF  FE9
4672:  MOVLW  01
4674:  ADDWFC 03,W
4676:  MOVWF  FEA
4678:  MOVFF  FEF,1CA
467C:  MOVFF  1CA,1CB
4680:  MOVLB  0
4682:  CALL   2DEC
....................    } 
4686:  MOVLB  1
4688:  INCF   xC9,F
468A:  BRA    4664
....................  
....................  
....................    i2c_stop(); 
468C:  BSF    FC5.2
468E:  BTFSC  FC5.2
4690:  BRA    468E
....................    if(SerialPort == SERIAL_USB) 
4692:  MOVLB  0
4694:  MOVF   x74,F
4696:  BNZ   46B2
....................      fprintf(USB,"y\r\n"); 
4698:  MOVLW  79
469A:  BTFSS  F9E.4
469C:  BRA    469A
469E:  MOVWF  FAD
46A0:  MOVLW  0D
46A2:  BTFSS  F9E.4
46A4:  BRA    46A2
46A6:  MOVWF  FAD
46A8:  MOVLW  0A
46AA:  BTFSS  F9E.4
46AC:  BRA    46AA
46AE:  MOVWF  FAD
....................    else 
46B0:  BRA    46CC
....................      fprintf(BT,"y\r\n"); 
46B2:  MOVLW  79
46B4:  BTFSS  FA4.4
46B6:  BRA    46B4
46B8:  MOVLB  F
46BA:  MOVWF  x1C
46BC:  MOVLW  0D
46BE:  BTFSS  FA4.4
46C0:  BRA    46BE
46C2:  MOVWF  x1C
46C4:  MOVLW  0A
46C6:  BTFSS  FA4.4
46C8:  BRA    46C6
46CA:  MOVWF  x1C
46CC:  MOVLB  0
.................... } 
46CE:  GOTO   49D4 (RETURN)
.................... //--------------------------------------------------------------------------------// 
.................... //- This function will be call when a serial command is completely received      -// 
.................... //--------------------------------------------------------------------------------//   
.................... //#separate 
.................... void SerialCommandHandler (void) 
.................... { 
....................  
....................    // If the second char is not a "," or "\r" or "\n" 
....................    if((SerialBuffer[ 1 ] != ',') &&  (SerialBuffer[ 1 ] != 10) && (SerialBuffer[ 1 ] != 13)) 
*
4734:  MOVF   24,W
4736:  SUBLW  2C
4738:  BZ    474C
473A:  MOVF   24,W
473C:  SUBLW  0A
473E:  BZ    474C
4740:  MOVF   24,W
4742:  SUBLW  0D
4744:  BZ    474C
....................    { 
....................       SerialCounter = 0;                                                        // Flush the buffer and do nothing 
4746:  CLRF   x73
....................       SerialCommandOK = 0;                                                      // For the Bluetooth when the connection is not made (communication with USB) 
4748:  BCF    22.4
....................    } 
....................    else 
474A:  BRA    49D4
....................    { 
....................   
....................       switch( SerialBuffer[ 0 ] ) 
....................       { 
474C:  MOVF   23,W
474E:  XORLW  41
4750:  BZ    47C8
4752:  XORLW  03
4754:  BZ    47CE
4756:  XORLW  01
4758:  BZ    47D4
475A:  XORLW  07
475C:  BZ    47DA
475E:  XORLW  01
4760:  BZ    47E0
4762:  XORLW  03
4764:  BZ    47E6
4766:  XORLW  01
4768:  BTFSC  FD8.2
476A:  BRA    4866
476C:  XORLW  0F
476E:  BTFSC  FD8.2
4770:  BRA    48AA
4772:  XORLW  01
4774:  BTFSC  FD8.2
4776:  BRA    48B0
4778:  XORLW  02
477A:  BTFSC  FD8.2
477C:  BRA    491E
477E:  XORLW  01
4780:  BTFSC  FD8.2
4782:  BRA    4924
4784:  XORLW  06
4786:  BTFSC  FD8.2
4788:  BRA    492A
478A:  XORLW  02
478C:  BTFSC  FD8.2
478E:  BRA    4930
4790:  XORLW  01
4792:  BTFSC  FD8.2
4794:  BRA    4936
4796:  XORLW  1D
4798:  BTFSC  FD8.2
479A:  BRA    493C
479C:  XORLW  01
479E:  BTFSC  FD8.2
47A0:  BRA    4942
47A2:  XORLW  07
47A4:  BTFSC  FD8.2
47A6:  BRA    49B2
47A8:  XORLW  02
47AA:  BTFSC  FD8.2
47AC:  BRA    49B8
47AE:  XORLW  01
47B0:  BTFSC  FD8.2
47B2:  BRA    49BE
47B4:  XORLW  0F
47B6:  BTFSC  FD8.2
47B8:  BRA    49C4
47BA:  XORLW  01
47BC:  BTFSC  FD8.2
47BE:  BRA    49CA
47C0:  XORLW  03
47C2:  BTFSC  FD8.2
47C4:  BRA    49CE
47C6:  BRA    49D2
....................    //--------------------------------------------------------------------------------// 
....................    //- Turn the K-Junior on the left or the right for n ms                          -// 
....................    //--------------------------------------------------------------------------------//             
....................          case 'A' : 
....................            __A(); 
47C8:  GOTO   1D8E
....................            break; 
47CC:  BRA    49D4
....................    //--------------------------------------------------------------------------------// 
....................    //- Read the KJunior OS version and revision                                     -// 
....................    //--------------------------------------------------------------------------------//             
....................          case 'B' :                                                             // KJOs Version 
....................             __B(); 
47CE:  GOTO   2060
....................             break; 
47D2:  BRA    49D4
....................  
....................          case 'C' : 
....................             __C(); 
47D4:  GOTO   20F8
....................             break; 
47D8:  BRA    49D4
....................         
....................    //--------------------------------------------------------------------------------// 
....................    //- Set the speed of the 2 motors. Valure are +/- 20 for each one                -// 
....................    //--------------------------------------------------------------------------------// 
....................          case 'D' :                                                             // Set Motors Speed 
....................             __D(); 
47DA:  GOTO   2204
....................             break; 
47DE:  BRA    49D4
....................    //--------------------------------------------------------------------------------// 
....................    //- Read the Speed of the two motors (-20 to +20)                                -// 
....................    //--------------------------------------------------------------------------------//                
....................          case 'E' :                                                             // Read Motors Speed 
....................             __E(); 
47E0:  GOTO   2586
....................             break; 
47E4:  BRA    49D4
....................    //--------------------------------------------------------------------------------// 
....................    //- read the Time base in ms                                                     -// 
....................    //--------------------------------------------------------------------------------// 
....................          case 'F' : 
....................            if(SerialPort == SERIAL_USB) 
47E6:  MOVF   x74,F
47E8:  BNZ   4824
....................             fprintf(USB,"f,%ld\r\n" TimeTip); 
47EA:  MOVLW  66
47EC:  BTFSS  F9E.4
47EE:  BRA    47EC
47F0:  MOVWF  FAD
47F2:  MOVLW  2C
47F4:  BTFSS  F9E.4
47F6:  BRA    47F4
47F8:  MOVWF  FAD
47FA:  MOVLW  41
47FC:  MOVWF  FE9
47FE:  MOVFF  8D,197
4802:  MOVFF  8C,196
4806:  MOVFF  8B,195
480A:  MOVFF  8A,194
480E:  GOTO   26B4
4812:  MOVLW  0D
4814:  BTFSS  F9E.4
4816:  BRA    4814
4818:  MOVWF  FAD
481A:  MOVLW  0A
481C:  BTFSS  F9E.4
481E:  BRA    481C
4820:  MOVWF  FAD
....................            else 
4822:  BRA    4864
....................             fprintf(BT,"f,%ld\r\n" TimeTip); 
4824:  MOVLW  66
4826:  BTFSS  FA4.4
4828:  BRA    4826
482A:  MOVLB  F
482C:  MOVWF  x1C
482E:  MOVLW  2C
4830:  BTFSS  FA4.4
4832:  BRA    4830
4834:  MOVWF  x1C
4836:  MOVLW  41
4838:  MOVWF  FE9
483A:  MOVFF  8D,197
483E:  MOVFF  8C,196
4842:  MOVFF  8B,195
4846:  MOVFF  8A,194
484A:  MOVLB  0
484C:  GOTO   27C4
4850:  MOVLW  0D
4852:  BTFSS  FA4.4
4854:  BRA    4852
4856:  MOVLB  F
4858:  MOVWF  x1C
485A:  MOVLW  0A
485C:  BTFSS  FA4.4
485E:  BRA    485C
4860:  MOVWF  x1C
4862:  MOVLB  0
....................             break; 
4864:  BRA    49D4
....................    //--------------------------------------------------------------------------------// 
....................    //- reset the Time base                                                          -// 
....................    //--------------------------------------------------------------------------------// 
....................          case 'G' :  
....................             TimeTip = 0; 
4866:  CLRF   x8D
4868:  CLRF   x8C
486A:  CLRF   x8B
486C:  CLRF   x8A
....................             if(SerialPort == SERIAL_USB) 
486E:  MOVF   x74,F
4870:  BNZ   488C
....................               fprintf(USB,"g\r\n"); 
4872:  MOVLW  67
4874:  BTFSS  F9E.4
4876:  BRA    4874
4878:  MOVWF  FAD
487A:  MOVLW  0D
487C:  BTFSS  F9E.4
487E:  BRA    487C
4880:  MOVWF  FAD
4882:  MOVLW  0A
4884:  BTFSS  F9E.4
4886:  BRA    4884
4888:  MOVWF  FAD
....................             else 
488A:  BRA    48A8
....................               fprintf(BT,"g\r\n"); 
488C:  MOVLW  67
488E:  BTFSS  FA4.4
4890:  BRA    488E
4892:  MOVLB  F
4894:  MOVWF  x1C
4896:  MOVLW  0D
4898:  BTFSS  FA4.4
489A:  BRA    4898
489C:  MOVWF  x1C
489E:  MOVLW  0A
48A0:  BTFSS  FA4.4
48A2:  BRA    48A0
48A4:  MOVWF  x1C
48A6:  MOVLB  0
....................             break; 
48A8:  BRA    49D4
....................    //--------------------------------------------------------------------------------// 
....................    //- Set the frequency of the buzzer, 0 = Off , 1 = 20Hz, 100 = 2kHz              -// 
....................    //--------------------------------------------------------------------------------//               
....................          case 'H' :  
....................             __H(); 
48AA:  GOTO   29B8
....................             break; 
48AE:  BRA    49D4
....................    //--------------------------------------------------------------------------------// 
....................    //- read the value of the mode switch                                            -// 
....................    //--------------------------------------------------------------------------------//                 
....................          case 'I' :  
....................            if(SerialPort == SERIAL_USB) 
48B0:  MOVF   x74,F
48B2:  BNZ   48E6
....................             fprintf(USB, "i,%x\r\n" , Switchs); 
48B4:  MOVLW  69
48B6:  BTFSS  F9E.4
48B8:  BRA    48B6
48BA:  MOVWF  FAD
48BC:  MOVLW  2C
48BE:  BTFSS  F9E.4
48C0:  BRA    48BE
48C2:  MOVWF  FAD
48C4:  MOVFF  101,197
48C8:  MOVLW  57
48CA:  MOVLB  1
48CC:  MOVWF  x98
48CE:  MOVLB  0
48D0:  CALL   2A8C
48D4:  MOVLW  0D
48D6:  BTFSS  F9E.4
48D8:  BRA    48D6
48DA:  MOVWF  FAD
48DC:  MOVLW  0A
48DE:  BTFSS  F9E.4
48E0:  BRA    48DE
48E2:  MOVWF  FAD
....................            else 
48E4:  BRA    491C
....................             fprintf(BT, "i,%x\r\n" , Switchs); 
48E6:  MOVLW  69
48E8:  BTFSS  FA4.4
48EA:  BRA    48E8
48EC:  MOVLB  F
48EE:  MOVWF  x1C
48F0:  MOVLW  2C
48F2:  BTFSS  FA4.4
48F4:  BRA    48F2
48F6:  MOVWF  x1C
48F8:  MOVFF  101,197
48FC:  MOVLW  57
48FE:  MOVLB  1
4900:  MOVWF  x98
4902:  MOVLB  0
4904:  CALL   2AD2
4908:  MOVLW  0D
490A:  BTFSS  FA4.4
490C:  BRA    490A
490E:  MOVLB  F
4910:  MOVWF  x1C
4912:  MOVLW  0A
4914:  BTFSS  FA4.4
4916:  BRA    4914
4918:  MOVWF  x1C
491A:  MOVLB  0
....................             break; 
491C:  BRA    49D4
....................              
....................    //--------------------------------------------------------------------------------// 
....................    //- Calibrate the IR sensor                                                      -// 
....................    //--------------------------------------------------------------------------------//                 
....................          case 'K' :  
....................             __K(); 
491E:  GOTO   2B1E
....................             break; 
4922:  BRA    49D4
....................  
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Scan the I2C Bus                                                             -// 
.................... //--------------------------------------------------------------------------------//              
....................          case 'J' :                        // Scan I2C Bus 
....................             __J(); 
4924:  GOTO   2E24
....................             break; 
4928:  BRA    49D4
....................          //case 'K' : Unused 
....................    //--------------------------------------------------------------------------------// 
....................    //- Set the LED value                                                            -// 
....................    //--------------------------------------------------------------------------------//                 
....................          case 'L' :    
....................             __L(); 
492A:  GOTO   2F6A
....................              break; 
492E:  BRA    49D4
....................    //--------------------------------------------------------------------------------// 
....................    //- Return the values of the IR Proximity sensor                                 -// 
....................    //--------------------------------------------------------------------------------//                  
....................          case 'N' :  
....................             __N(); 
4930:  GOTO   328E
....................             break; 
4934:  BRA    49D4
....................    //--------------------------------------------------------------------------------// 
....................    //- Return the values of the IR Ambient light sensor                             -// 
....................    //--------------------------------------------------------------------------------//                   
....................          case 'O' :                       
....................             __O(); 
4936:  GOTO   34AE
....................             break; 
493A:  BRA    49D4
....................  
....................   
.................... //--------------------------------------------------------------------------------// 
.................... //- Read on the I2C Bus                                                          -// 
.................... //--------------------------------------------------------------------------------//   
....................          case 'R' :                        // Read I2C 
....................             __R(); 
493C:  GOTO   37FA
....................             break; 
4940:  BRA    49D4
....................              
.................... //--------------------------------------------------------------------------------// 
.................... //- Return the battery voltage                                                   -// 
.................... //--------------------------------------------------------------------------------//   
....................          case 'S' :                        // Read I2C 
....................            if(SerialPort == SERIAL_USB) 
4942:  MOVF   x74,F
4944:  BNZ   4978
....................             fprintf(USB, "s,%4lu\r\n" , BatteryVoltage); 
4946:  MOVLW  73
4948:  BTFSS  F9E.4
494A:  BRA    4948
494C:  MOVWF  FAD
494E:  MOVLW  2C
4950:  BTFSS  F9E.4
4952:  BRA    4950
4954:  MOVWF  FAD
4956:  MOVLW  01
4958:  MOVWF  FE9
495A:  MOVFF  100,195
495E:  MOVFF  FF,194
4962:  GOTO   397A
4966:  MOVLW  0D
4968:  BTFSS  F9E.4
496A:  BRA    4968
496C:  MOVWF  FAD
496E:  MOVLW  0A
4970:  BTFSS  F9E.4
4972:  BRA    4970
4974:  MOVWF  FAD
....................            else 
4976:  BRA    49B0
....................             fprintf(BT, "s,%4lu\r\n" , BatteryVoltage); 
4978:  MOVLW  73
497A:  BTFSS  FA4.4
497C:  BRA    497A
497E:  MOVLB  F
4980:  MOVWF  x1C
4982:  MOVLW  2C
4984:  BTFSS  FA4.4
4986:  BRA    4984
4988:  MOVWF  x1C
498A:  MOVLW  01
498C:  MOVWF  FE9
498E:  MOVFF  100,195
4992:  MOVFF  FF,194
4996:  MOVLB  0
4998:  GOTO   3A26
499C:  MOVLW  0D
499E:  BTFSS  FA4.4
49A0:  BRA    499E
49A2:  MOVLB  F
49A4:  MOVWF  x1C
49A6:  MOVLW  0A
49A8:  BTFSS  FA4.4
49AA:  BRA    49A8
49AC:  MOVWF  x1C
49AE:  MOVLB  0
....................             break; 
49B0:  BRA    49D4
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Return the receiving TV data                                                 -// 
.................... //--------------------------------------------------------------------------------//  
....................          case 'T' :                        // Read TV Remote Sensor 
....................             __T(); 
49B2:  GOTO   3AD6
....................             break; 
49B6:  BRA    49D4
....................  
....................          case 'V' :  
....................             __V(); 
49B8:  GOTO   3B70
....................             break; 
49BC:  BRA    49D4
.................... //--------------------------------------------------------------------------------// 
.................... //- Write a data on the I2C Bus                                                  -// 
.................... //--------------------------------------------------------------------------------//           
....................          case 'W' :                        // Write I2C 
....................             __W(); 
49BE:  GOTO   3D34
....................             break; 
49C2:  BRA    49D4
....................  
.................... //--------------------------------------------------------------------------------// 
.................... //- Read all K-Junior Data in binary mode                                        -// 
.................... //--------------------------------------------------------------------------------// 
....................          
....................          case 'X' :   // Fast binary read 
....................             __X(); 
49C4:  GOTO   3E0E
....................             break; 
49C8:  BRA    49D4
....................     
....................  
....................  //--------------------------------------------------------------------------------// 
.................... //- Write many Data on the I2C Bus                                               -// 
.................... //--------------------------------------------------------------------------------//          
....................          case 'Y' :                                                            
....................             __Y(); 
49CA:  BRA    4516
....................             break; 
49CC:  BRA    49D4
....................    //--------------------------------------------------------------------------------// 
....................    //- Reset the KJunior uC                                                         -// 
....................    //--------------------------------------------------------------------------------//                  
....................          case 'Z' : 
....................             __Z(); 
49CE:  BRA    46D2
....................             break; 
49D0:  BRA    49D4
....................       
....................          default :   // Unknown message command 
....................             __default();   
49D2:  BRA    4712
....................             break; 
....................       } 
....................  
....................    } 
....................    SerialCounter = 0; 
49D4:  CLRF   x73
....................    SerialCommandOK = 0; 
49D6:  BCF    22.4
....................     
....................  
.................... } 
49D8:  GOTO   718E (RETURN)
....................  
....................  
.................... #INT_RDA  
.................... void USB_Serial_Interrupt(void) 
.................... { 
....................  unsigned char FLUSH; 
....................     
....................    SerialPort = SERIAL_USB; 
*
12C4:  CLRF   x74
....................    while(kbhit(USB))                                                               // Read while data available 
....................    { 
12C6:  BTFSS  F9E.5
12C8:  BRA    1334
....................       if((SerialCommandOK == 1) && (BT_config == 0))                            // If a command is still in traitment (and no config Bluetooth is in process), Flush the buffer 
12CA:  BTFSS  22.4
12CC:  BRA    12E8
12CE:  MOVLB  1
12D0:  MOVF   x22,F
12D2:  BTFSC  FD8.2
12D4:  BRA    12DA
12D6:  MOVLB  0
12D8:  BRA    12E8
....................       { 
....................          FLUSH = getc(USB); 
12DA:  BTFSS  F9E.5
12DC:  BRA    12DA
12DE:  MOVFF  FAE,201
12E2:  MOVLB  2
....................       } 
....................       else 
12E4:  BRA    1330
12E6:  MOVLB  0
....................       {       
....................          SerialBuffer[ SerialCounter ] = getc(USB); 
12E8:  CLRF   03
12EA:  MOVF   x73,W
12EC:  ADDLW  23
12EE:  MOVWF  FE9
12F0:  MOVLW  00
12F2:  ADDWFC 03,W
12F4:  MOVWF  FEA
12F6:  BTFSS  F9E.5
12F8:  BRA    12F6
12FA:  MOVFF  FAE,FEF
....................          if((SerialBuffer[ SerialCounter ] == 13) || (SerialBuffer[ SerialCounter ] == 10))   // '\n' & '\r' 
12FE:  CLRF   03
1300:  MOVF   x73,W
1302:  ADDLW  23
1304:  MOVWF  FE9
1306:  MOVLW  00
1308:  ADDWFC 03,W
130A:  MOVWF  FEA
130C:  MOVF   FEF,W
130E:  SUBLW  0D
1310:  BZ    1326
1312:  CLRF   03
1314:  MOVF   x73,W
1316:  ADDLW  23
1318:  MOVWF  FE9
131A:  MOVLW  00
131C:  ADDWFC 03,W
131E:  MOVWF  FEA
1320:  MOVF   FEF,W
1322:  SUBLW  0A
1324:  BNZ   1328
....................          {  
....................             SerialCommandOK = 1;                                                   // Set the Received command Flag 
1326:  BSF    22.4
....................          } 
....................          if (SerialCounter < ( SERIAL_BUFFER_SIZE-1 ))                             // To discard buffer overflow 
1328:  MOVF   x73,W
132A:  SUBLW  4E
132C:  BNC   1330
....................          { 
....................             SerialCounter++; 
132E:  INCF   x73,F
....................          } 
....................       } 
....................    } 
1330:  MOVLB  0
1332:  BRA    12C6
....................        
....................     
.................... } 
....................  
....................  
1334:  BCF    F9E.5
1336:  GOTO   00A8
.................... #INT_RDA2  
.................... void BT_Serial_Interrupt(void) 
.................... { 
....................  unsigned char FLUSH; 
....................    SerialPort = SERIAL_BT; 
133A:  MOVLW  01
133C:  MOVWF  x74
....................    while(kbhit(BT))                                                               // Read while data available 
....................    { 
133E:  BTFSS  FA4.5
1340:  BRA    13B0
....................       if((SerialCommandOK == 1) && (BT_config == 0))                            // If a command is still in traitment (and no config Bluetooth is in process), Flush the buffer 
1342:  BTFSS  22.4
1344:  BRA    1360
1346:  MOVLB  1
1348:  MOVF   x22,F
134A:  BTFSC  FD8.2
134C:  BRA    1352
134E:  MOVLB  0
1350:  BRA    1360
....................       { 
....................          FLUSH = getc(BT); 
1352:  BTFSS  FA4.5
1354:  BRA    1352
1356:  MOVFF  F1D,201
135A:  MOVLB  2
....................       } 
....................       else 
135C:  BRA    13AC
135E:  MOVLB  0
....................       {       
....................          SerialBuffer[ SerialCounter ] = getc(BT); 
1360:  CLRF   03
1362:  MOVF   x73,W
1364:  ADDLW  23
1366:  MOVWF  FE9
1368:  MOVLW  00
136A:  ADDWFC 03,W
136C:  MOVWF  FEA
136E:  BTFSS  FA4.5
1370:  BRA    136E
1372:  MOVLB  F
1374:  MOVFF  F1D,FEF
....................          if((SerialBuffer[ SerialCounter ] == 13) || (SerialBuffer[ SerialCounter ] == 10))   // '\n' & '\r' 
1378:  CLRF   03
137A:  MOVLB  0
137C:  MOVF   x73,W
137E:  ADDLW  23
1380:  MOVWF  FE9
1382:  MOVLW  00
1384:  ADDWFC 03,W
1386:  MOVWF  FEA
1388:  MOVF   FEF,W
138A:  SUBLW  0D
138C:  BZ    13A2
138E:  CLRF   03
1390:  MOVF   x73,W
1392:  ADDLW  23
1394:  MOVWF  FE9
1396:  MOVLW  00
1398:  ADDWFC 03,W
139A:  MOVWF  FEA
139C:  MOVF   FEF,W
139E:  SUBLW  0A
13A0:  BNZ   13A4
....................          {  
....................             SerialCommandOK = 1;                                                   // Set the Received command Flag 
13A2:  BSF    22.4
....................          } 
....................          if (SerialCounter < ( SERIAL_BUFFER_SIZE-1 ))                             // To discard buffer overflow 
13A4:  MOVF   x73,W
13A6:  SUBLW  4E
13A8:  BNC   13AC
....................          { 
....................             SerialCounter++; 
13AA:  INCF   x73,F
....................          } 
....................       } 
....................    } 
13AC:  MOVLB  0
13AE:  BRA    133E
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#org 0xFC00, 0xFFFE {}                                                          // Bootloader Protection 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \file KJunior.h 
....................       \brief This file is the library of all high level functions that can be used when programming KJunior 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /** 
....................    * \defgroup Configuration_Functions 
....................    */ 
.................... /*@{*/ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_init(void) 
....................       \brief KJunior Initialisation. This function initialise all KJunior peripherals 
....................       \param None 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
13B0:  BCF    FA4.5
13B2:  GOTO   00A8
.................... void KJunior_init(void); 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_config_auto_refresh_sensors(int1 Bit) 
....................       \brief Set the refresh mode of all IRs sensors 
....................       \param int1 Manual or Refresh (Default) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_config_auto_refresh_sensors(int1 Bit) 
.................... { 
....................      Auto_Refresh_Sensors=Bit; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_config_auto_refresh_tv_remote(int1 Bit) 
....................       \brief Configure the refresh mode of the TV remote receiver 
....................       \param int1 Manual or Refresh(Default) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_config_auto_refresh_tv_remote(int1 Bit) 
.................... { 
....................       Auto_Refresh_TV_Remote=Bit; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_config_rs232_control(int1 Bit) 
....................       \brief Configure the Serial Remote Control 
....................       \param int1 Disable or Enable (Default) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_config_rs232_control(int1 Bit) 
.................... { 
....................       Enable_RS232_Control=Bit; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_config_tv_remote_control(int1 Bit) 
....................       \brief Configure the TV Remote Control 
....................       \param int1 Disable or Enable (Default) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_config_tv_remote_control(int1 Bit) 
.................... { 
....................       Enable_TV_Remote_Control=Bit; 
*
1BB6:  BCF    22.3
1BB8:  MOVLB  1
1BBA:  BTFSC  x94.0
1BBC:  BSF    22.3
.................... } 
1BBE:  MOVLB  0
1BC0:  GOTO   1BD8 (RETURN)
.................... /*@}*/ 
....................  
.................... /** 
....................    * \defgroup Flags 
....................    */ 
.................... /*@{*/ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_flag_sensors_refreshed(void) 
....................       \brief Test if IRs sensors have been refreshed 
....................       \param None 
....................       \retval int1 1 if sensors have been refreshed 
....................       \warning You must then call KJunior_flag_sensors_reset() to clear the flag 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 KJunior_flag_sensors_refreshed(void) 
.................... { 
....................       return Sensors_Refreshed_Flag; 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_flag_sensors_reset(void) 
....................       \brief Clear IRs sensors refreshed flag 
....................       \param None 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_flag_sensors_reset(void) 
.................... { 
....................       Sensors_Refreshed_Flag = 0; 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_flag_rs232_filtering(void) 
....................       \brief Test if Serial Remote Control is active or not 
....................       \param None 
....................       \retval int1 1 if active otherwise 0 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 KJunior_flag_rs232_filtering(void) 
.................... { 
....................       return Enable_RS232_Control; 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_flag_tv_data_refreshed(void) 
....................       \brief Test if Tv Data have been refreshed 
....................       \param None 
....................       \retval int1 1 if active otherwise 0 
....................       \warning You must then call KJunior_flag_tv_data_reset() to clear the flag 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 KJunior_flag_tv_data_refreshed(void) 
.................... { 
....................       return TV_Data_Available; 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_flag_tv_data_emitting(void) 
....................       \brief Test if Tv Data the data is completely send 
....................       \param None 
....................       \retval int1 1 the data is still emitting otherwise 0 if it's done 
....................       \warning You must then call KJunior_flag_tv_data_reset() to clear the flag 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 KJunior_flag_tv_data_emitting(void) 
.................... { 
....................       return TV_Data_emitting; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_flag_tv_data_reset(void) 
....................       \brief Clear TV Data flag 
....................       \param None 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_flag_tv_data_reset(void) 
.................... { 
....................       TV_Data_Available = 0; 
.................... } 
.................... /*@}*/ 
....................  
.................... /** 
....................    * \defgroup Peripheral_Access_Functions 
....................    */ 
.................... /*@{*/ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn unsigned char KJunior_get_proximity(char Sensor) 
....................       \brief Get proximity value of one IR sensor 
....................       \param char Front, FrontLeft, FrontRight, Left, Right, Rear, GroundLeft, GroundRight 
....................       \retval unsigned_char Proximity Value (0 when nothing) 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... signed int16 KJunior_get_proximity(char Sensor) 
.................... { 
....................       return IR_Proximity[Sensor]; 
*
49E6:  BCF    FD8.0
49E8:  MOVLB  1
49EA:  RLCF   xA3,W
49EC:  CLRF   03
49EE:  ADDLW  A9
49F0:  MOVWF  FE9
49F2:  MOVLW  00
49F4:  ADDWFC 03,W
49F6:  MOVWF  FEA
49F8:  MOVFF  FEF,01
49FC:  INCF   FE9,F
49FE:  MOVF   FEF,W
4A00:  DECF   FE9,F
4A02:  MOVWF  02
.................... } 
4A04:  MOVLB  0
4A06:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn unsigned char KJunior_get_brightness(char Sensor) 
....................       \brief Get brightness value of one IR sensor 
....................       \param char Front, FrontLeft, FrontRight, Left, Right, Rear, GroundLeft, GroundRight 
....................       \retval unsigned_char Brightness Value (0 when lot of light) 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... signed int16 KJunior_get_brightness(char Sensor) 
.................... { 
....................       return IR_Light[Sensor]; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_get_switch_state(char Switch_Number) 
....................       \brief Get Switch State 
....................       \retval int8 Value of the 3 switch (0 to 7) 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned char KJunior_get_switch_state() 
.................... { 
....................       return Switchs; 
*
49DC:  MOVLB  1
49DE:  MOVFF  101,01
.................... } 
49E2:  MOVLB  0
49E4:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn char KJunior_get_tv_data(void) 
....................       \brief Get latest data from the TV remote receiver 
....................       \param None 
....................       \retval char Byte that have been received 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned char KJunior_get_tv_data(void) 
.................... { 
....................       return TV_DATA; 
*
53CA:  MOVF   x84,W
53CC:  MOVWF  01
.................... } 
53CE:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn char KJunior_get_tv_addr(void) 
....................       \brief Get latest address from the TV remote receiver 
....................       \param None 
....................       \retval char Byte that have been received 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned char KJunior_get_tv_addr(void) 
.................... { 
....................       return TV_ADDR; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn char KJunior_send_tv_value(void) 
....................       \brief Send a value on the IR emitter 
....................       \param addr set the address of the communication 
....................       \param data value of the code to send 
....................       \retval char Byte that have been received 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_send_tv_value(unsigned char addr, unsigned char data) 
.................... { 
....................       TV_Addr_send = addr;                                                      // load the address register 
....................       TV_Data_send = data;                                                      // Set the data register 
....................       TV_Data_emitting = 1;                                                     // Set the flag to indicate that a mesasge must be send 
....................       while(TV_Data_pending == 1);                                              // If a IR data is receiving, wait until it's done 
....................       set_timer0(TIMER0_886); 
....................       setup_timer_0(T0_INTERNAL | T0_DIV_1);                                    // Interrupt every 886 us 
....................       TV_Counter = 0;                                                           // reset TV_Counter 
....................       TV_Counter_flag = 0;                                                      // reset the sending phase flag 
....................       disable_interrupts(INT_EXT);                                              // Disable interrupt of the receiving IR, to avoid receiving its own data 
....................       enable_interrupts(INT_TIMER0);                                            // enable the timer0 interrupt to start the emitting     
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_set_speed(signed int8 Left, signed int8 Right) 
....................       \brief Set speed of each motor 
....................       \param signed_int8 Speed of motor (from -20 to 20, 0 = Stop) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_set_speed(signed int8 LeftSpeed,signed int8 RightSpeed) 
.................... { 
....................       PwmMotLeft = LeftSpeed; 
*
4A08:  MOVFF  1A1,1A
....................       PwmMotRight = RightSpeed; 
4A0C:  MOVFF  1A2,1B
....................       if(PwmMotLeft >20)                                                        // Limit the minimum and maximum PWM value to -20 and 20 
4A10:  BTFSC  1A.7
4A12:  BRA    4A20
4A14:  MOVF   1A,W
4A16:  SUBLW  14
4A18:  BC    4A20
....................          PwmMotLeft = 20; 
4A1A:  MOVLW  14
4A1C:  MOVWF  1A
....................       else if(PwmMotLeft < -20)  
4A1E:  BRA    4A2C
4A20:  MOVF   1A,W
4A22:  XORLW  80
4A24:  SUBLW  6B
4A26:  BNC   4A2C
....................          PwmMotLeft = -20; 
4A28:  MOVLW  EC
4A2A:  MOVWF  1A
....................       if(PwmMotRight >20)                                                       // Limit the minimum and maximum PWM value to -20 and 20 
4A2C:  BTFSC  1B.7
4A2E:  BRA    4A3C
4A30:  MOVF   1B,W
4A32:  SUBLW  14
4A34:  BC    4A3C
....................          PwmMotRight = 20; 
4A36:  MOVLW  14
4A38:  MOVWF  1B
....................       else if(PwmMotRight < -20)  
4A3A:  BRA    4A48
4A3C:  MOVF   1B,W
4A3E:  XORLW  80
4A40:  SUBLW  6B
4A42:  BNC   4A48
....................          PwmMotRight = -20;   
4A44:  MOVLW  EC
4A46:  MOVWF  1B
4A48:  CLRF   19
4A4A:  BTFSC  FF2.7
4A4C:  BSF    19.7
4A4E:  BCF    FF2.7
....................           
....................       Motor_Conversion();                                                       // Convert the value to the real PWM and set the PWM output 
4A50:  CALL   0B7E
4A54:  BTFSC  19.7
4A56:  BSF    FF2.7
....................  
.................... } 
4A58:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_beep(int1 State) 
....................       \brief Set the buzzer State 
....................       \param int8 Freq (0 to 48), 1 = 131Hz (Do 2st Octave & 48 = 1.975kHz (Si 5st Octave) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_beep(unsigned char Freq) 
.................... { 
....................       buzzValue = Freq; 
*
4E16:  MOVFF  1A2,105
....................       Set_Freq_note(); 
4E1A:  CALL   28E0
.................... } 
4E1E:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_led_left(int1 State) 
....................       \brief Set the Left Led State 
....................       \param int1 State (0=Off,1=On) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_led_left(int1 State) 
.................... { 
....................       output_bit(LED0, State); 
*
1A3E:  MOVLB  1
1A40:  MOVF   xD9,F
1A42:  BNZ   1A48
1A44:  BCF    F8A.1
1A46:  BRA    1A4A
1A48:  BSF    F8A.1
.................... } 
1A4A:  MOVLB  0
1A4C:  RETURN 0
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_led_frontleft(int1 State) 
....................       \brief Set the FrontLeft Led State 
....................       \param int1 State (0=Off,1=On) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_led_frontleft(int1 State) 
.................... { 
....................       output_bit(LED1, State); 
1A4E:  MOVLB  1
1A50:  MOVF   xD7,F
1A52:  BNZ   1A58
1A54:  BCF    F8A.2
1A56:  BRA    1A5A
1A58:  BSF    F8A.2
.................... } 
1A5A:  MOVLB  0
1A5C:  RETURN 0
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_led_frontright(int1 State) 
....................       \brief Set the FrontRight Led State 
....................       \param int1 State (0=Off,1=On) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_led_frontright(int1 State) 
.................... { 
....................       output_bit(LED2, State); 
1A5E:  MOVLB  1
1A60:  MOVF   xD7,F
1A62:  BNZ   1A68
1A64:  BCF    F8A.3
1A66:  BRA    1A6A
1A68:  BSF    F8A.3
.................... } 
1A6A:  MOVLB  0
1A6C:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_led_right(int1 State) 
....................       \brief Set the Right Led State 
....................       \param int1 State (0=Off,1=On) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_led_right(int1 State) 
.................... { 
....................       output_bit(LED3,State); 
1A6E:  MOVLB  1
1A70:  MOVF   xD7,F
1A72:  BNZ   1A78
1A74:  BCF    F8A.4
1A76:  BRA    1A7A
1A78:  BSF    F8A.4
.................... } 
1A7A:  MOVLB  0
1A7C:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_led_onoff(int1 State) 
....................       \brief Set the OnOff Led State 
....................       \param int1 State (0=Off,1=On) 
....................       \retval None 
....................       \warning This Led is controlled in background by the Scheduler 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_led_onoff(int1 State) 
.................... { 
....................       output_bit(LED4,State); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_manual_refresh_sensors(char Zone) 
....................       \brief Manualy refresh a zone 
....................       \param None 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_manual_refresh_sensors() 
.................... { 
....................    Manual_Refresh_sensors = 1; 
....................    Sensors_Refreshed_Flag = 0; 
.................... } 
.................... /*@}*/ 
....................  
.................... /** 
....................    * \defgroup Time_Functions 
....................    */ 
.................... /*@{*/ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_delay_s(int16 Delay) 
....................       \brief This function stop program execution (but not the interrupts) during the defined time in second 
....................       \param Delay 0 to 65535 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void KJunior_delay_s(int16 Delay) 
.................... { 
....................    int i, b; 
....................    for(i = 0; i< Delay; i++) 
....................    { 
....................         b = delay_ms(1000); 
....................    } 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_delay_ms(int16 Delay) 
....................       \brief This function stop program execution (but not the interrupts) during the defined time in millisecond 
....................       \param Delay 0 to 65535 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_delay_ms(int16 Delay) 
.................... { 
....................    delay_ms(Delay); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_delay_us(int16 Delay) 
....................       \brief This function stop program execution (but not the interrupts) during the defined time in microsecond 
....................       \param Delay 0 to 65535 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_delay_us(int16 Delay) 
.................... { 
....................    delay_us(Delay); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn unsigned int32 KJunior_get_time(void) 
....................       \brief This function return a 32 bits value which is increased every ms 
....................       \param None 
....................       \retval unsigned int32 time value 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 KJunior_get_time(void) 
.................... { 
....................    return TimeTip; 
*
4AB2:  MOVFF  8A,00
4AB6:  MOVFF  8B,01
4ABA:  MOVFF  8C,02
4ABE:  MOVFF  8D,03
.................... } 
4AC2:  RETURN 0
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_set_time(unsigned int32 time) 
....................       \brief This function allow user to set the current time value 
....................       \param unsigned int32 time 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_set_time(unsigned int32 Time) 
.................... { 
....................    TimeTip = Time; 
.................... } 
....................  
.................... /*@}*/ 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_ext_read_PINB6(void) 
....................       \brief Read input PORTB.6 
....................       \param None 
....................       \retval int1 input value (0 or 1) 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 KJunior_ext_read_PINB6(void) 
.................... { 
....................    set_tris_b(TRISB|0x40); 
....................    return input(PIN_B6); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn int1 KJunior_ext_read_PINB7(void) 
....................       \brief Read input PORTB.7 
....................       \param None 
....................       \retval int1 input value (0 or 1) 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 KJunior_ext_read_PINB7(void) 
.................... { 
....................    set_tris_b(TRISB|0x80); 
....................    return input(PIN_B7); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_ext_write_PINB6(int1 Bit) 
....................       \brief Write output PORTB.6 
....................       \param int1 Value to write (0 or 1) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_ext_write_PINB6(int1 Bit) 
.................... { 
....................    set_tris_b(TRISB & 0xBF); 
....................    output_bit(PIN_B6,bit); 
.................... } 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_ext_write_PINB7(int1 Bit) 
....................       \brief Write output PORTB.7 
....................       \param int1 Value to write (0 or 1) 
....................       \retval None 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void KJunior_ext_write_PINB7(int1 Bit) 
.................... { 
....................    set_tris_b(TRISB & 0x7F); 
....................    output_bit(PIN_B7,bit); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /*!   \fn void KJunior_get_Battery(void) 
....................       \brief Read the battery voltage 
....................       \param None 
....................       \retval BatteryVoltage 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned int16 KJunior_get_Battery(void) 
.................... { 
....................   return BatteryVoltage; 
.................... } 
.................... /*@}*/ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... // Linear camera 
.................... #include "HemLinCam.h"  
.................... //--------------------------------------------------------------------------------// 
.................... //-                             HemLinCam Lib. 1.6                               -// 
.................... //-                           -// 
.................... //-  Copyright (C) Alexandre Colot, K-Team S.A. 2002                             -// 
.................... //-  This library is free software; you can redistribute it and/or               -// 
.................... //-  modify it under the terms of the GNU Lesser General Public                  -// 
.................... //-  License as published by the Free Software Foundation; either                -// 
.................... //-  version 2.1 of the License, or any later version.                           -// 
.................... //-                          -// 
.................... //-  This library is distributed in the hope that it will be useful,      -// 
.................... //-  but WITHOUT ANY WARRANTY; without even the implied warranty of     -// 
.................... //-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           -// 
.................... //-  Lesser General Public License for more details.                             -// 
.................... //-                                                                              -// 
.................... //-  You should have received a copy of the GNU Lesser General Public            -// 
.................... //-  License along with this library; if not, write to the Free Software         -// 
.................... //-  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA   -// 
.................... //-                           -// 
.................... //-                           -// 
.................... //-                               __  __  ________                           -// 
.................... //- K-Team S.A.                  |  |/  /|__    __|___  _____  ___  ___          -// 
.................... //- Chemin de Vuasset, CP 111    |     / __ |  | _____|/  _  \|   \/   |         -// 
.................... //- 1028 Preverenges             |  |  \    |  | ____|/  /_\  |        |         -// 
.................... //- Switzerland                  |__|\__\   |__|______|_/   \_|__|\/|__|         -// 
.................... //- alexandre.colot@k-team.com   tel:+41 21 802 5472 fax:+41 21 802 5471         -// 
.................... //-                           -// 
.................... //--------------------------------------------------------------------------------// 
....................  
.................... #define HEMLINCAM_I2C_ADDRESS 0xC0 
....................  
.................... unsigned char HemLinCam_Pixels_Zone1[34]; 
.................... //#locate HemLinCam_Pixels_Zone1=0x0A0 
.................... unsigned char HemLinCam_Pixels_Zone2[34]; 
.................... //#locate HemLinCam_Pixels_Zone2=0x120 
.................... unsigned char HemLinCam_Pixels_Zone3[34]; 
.................... //#locate HemLinCam_Pixels_Zone3=0x1A0 
....................  
.................... void HemLinCam_Init( void ) 
.................... { 
....................   delay_ms(1000); 
*
1A24:  MOVLW  04
1A26:  MOVLB  1
1A28:  MOVWF  x94
1A2A:  MOVLW  FA
1A2C:  MOVWF  x96
1A2E:  MOVLB  0
1A30:  RCALL  13F2
1A32:  MOVLB  1
1A34:  DECFSZ x94,F
1A36:  BRA    1A2A
.................... } 
1A38:  MOVLB  0
1A3A:  GOTO   717C (RETURN)
....................  
.................... char HemLinCam_Read_Version( void ) 
.................... { 
....................       unsigned char value = 0x00; 
....................       i2c_start();                                                // I2C Start Sequence 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
....................       i2c_write(0x00);                                            // Firmware version Register 
....................       i2c_start(); 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS + 1 );                      // HemLinCam I2C Read Address 
....................       value = i2c_read(0); 
....................       i2c_stop();                                                 // I2C Stop Sequence 
....................       return value; 
.................... } 
....................  
.................... //----------------------------------------------------------------// 
.................... //-                Settings Functions                            -// 
....................  
.................... void HemLinCam_Set_Threshold( unsigned char value) 
.................... { 
....................       i2c_start();                                                // I2C Start Sequence 
*
5494:  BSF    FC5.0
5496:  BTFSC  FC5.0
5498:  BRA    5496
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
549A:  MOVLW  C0
549C:  MOVLB  1
549E:  MOVWF  xCB
54A0:  MOVLB  0
54A2:  CALL   2DEC
....................       i2c_write(0x20);                                            // Threshold Register 
54A6:  MOVLW  20
54A8:  MOVLB  1
54AA:  MOVWF  xCB
54AC:  MOVLB  0
54AE:  CALL   2DEC
....................       i2c_write(value); 
54B2:  MOVFF  194,1CB
54B6:  CALL   2DEC
....................       i2c_stop();                                                 // I2C Stop Sequence 
54BA:  BSF    FC5.2
54BC:  BTFSC  FC5.2
54BE:  BRA    54BC
....................       delay_ms(1); 
54C0:  MOVLW  01
54C2:  MOVLB  1
54C4:  MOVWF  x96
54C6:  MOVLB  0
54C8:  CALL   13F2
.................... } 
54CC:  RETURN 0
....................  
.................... unsigned char HemLinCam_Read_Threshold( void ) 
.................... { 
....................       unsigned char value = 0x00; 
....................       i2c_start();                                                // I2C Start Sequence 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
....................       i2c_write(0x20);                                            // Exposition Time Register 
....................       i2c_start(); 
....................       i2c_write(HEMLINCAM_I2C_ADDRESS + 1 );                      // HemLinCam I2C Read Address 
....................       value = i2c_read(0); 
....................       i2c_stop();                                                 // I2C Stop Sequence 
....................       delay_ms(1); 
....................       return value; 
.................... } 
....................  
.................... void HemLinCam_Set_Exposition_Time( unsigned char value) 
.................... { 
....................       i2c_start();                                                // I2C Start Sequence 
*
5432:  BSF    FC5.0
5434:  BTFSC  FC5.0
5436:  BRA    5434
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
5438:  MOVLW  C0
543A:  MOVLB  1
543C:  MOVWF  xCB
543E:  MOVLB  0
5440:  CALL   2DEC
....................       i2c_write(0x21);                                            // Exposition Time Register 
5444:  MOVLW  21
5446:  MOVLB  1
5448:  MOVWF  xCB
544A:  MOVLB  0
544C:  CALL   2DEC
....................       i2c_write(value); 
5450:  MOVFF  194,1CB
5454:  CALL   2DEC
....................       i2c_stop();                                                 // I2C Stop Sequence 
5458:  BSF    FC5.2
545A:  BTFSC  FC5.2
545C:  BRA    545A
....................       delay_ms(1); 
545E:  MOVLW  01
5460:  MOVLB  1
5462:  MOVWF  x96
5464:  MOVLB  0
5466:  CALL   13F2
.................... } 
546A:  RETURN 0
....................  
.................... unsigned char HemLinCam_Read_Exposition_Time( void ) 
.................... { 
*
55AA:  MOVLB  1
55AC:  CLRF   x95
....................       unsigned char value = 0x00; 
....................       i2c_start();                                                // I2C Start Sequence 
55AE:  BSF    FC5.0
55B0:  BTFSC  FC5.0
55B2:  BRA    55B0
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
55B4:  MOVLW  C0
55B6:  MOVWF  xCB
55B8:  MOVLB  0
55BA:  CALL   2DEC
....................       i2c_write(0x21);                                            // Exposition Time Register 
55BE:  MOVLW  21
55C0:  MOVLB  1
55C2:  MOVWF  xCB
55C4:  MOVLB  0
55C6:  CALL   2DEC
....................       i2c_start(); 
55CA:  BSF    FC5.1
55CC:  BTFSC  FC5.1
55CE:  BRA    55CC
....................       i2c_write(HEMLINCAM_I2C_ADDRESS + 1 );                      // HemLinCam I2C Read Address 
55D0:  MOVLW  C1
55D2:  MOVLB  1
55D4:  MOVWF  xCB
55D6:  MOVLB  0
55D8:  CALL   2DEC
....................       value = i2c_read(0); 
55DC:  CLRF   00
55DE:  CALL   2E08
55E2:  MOVFF  01,195
....................       i2c_stop();                                                 // I2C Stop Sequence 
55E6:  BSF    FC5.2
55E8:  BTFSC  FC5.2
55EA:  BRA    55E8
....................       delay_ms(1); 
55EC:  MOVLW  01
55EE:  MOVLB  1
55F0:  MOVWF  x96
55F2:  MOVLB  0
55F4:  CALL   13F2
....................       return value; 
55F8:  MOVLB  1
55FA:  MOVFF  195,01
.................... } 
55FE:  MOVLB  0
5600:  RETURN 0
....................  
.................... void HemLinCam_Read_Pixels( void ) 
.................... { 
....................       int i; 
....................       delay_ms(HemLinCam_Read_Exposition_Time()); 
*
56E2:  RCALL  55AA
56E4:  MOVFF  01,195
56E8:  MOVFF  01,196
56EC:  CALL   13F2
....................       i2c_start();                                                // I2C Start Sequence 
56F0:  BSF    FC5.0
56F2:  BTFSC  FC5.0
56F4:  BRA    56F2
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
56F6:  MOVLW  C0
56F8:  MOVLB  1
56FA:  MOVWF  xCB
56FC:  MOVLB  0
56FE:  CALL   2DEC
....................       i2c_write(0x10); 
5702:  MOVLW  10
5704:  MOVLB  1
5706:  MOVWF  xCB
5708:  MOVLB  0
570A:  CALL   2DEC
....................       i2c_start(); 
570E:  BSF    FC5.1
5710:  BTFSC  FC5.1
5712:  BRA    5710
....................       i2c_write(HEMLINCAM_I2C_ADDRESS + 1 );                      // HemLinCam I2C Read Address 
5714:  MOVLW  C1
5716:  MOVLB  1
5718:  MOVWF  xCB
571A:  MOVLB  0
571C:  CALL   2DEC
....................       for( i = 0 ; i < 34 ; i++ ) 
5720:  MOVLB  1
5722:  CLRF   x94
5724:  MOVF   x94,W
5726:  SUBLW  21
5728:  BNC   574C
....................       { 
....................          HemLinCam_Pixels_Zone1[i] = i2c_read(); 
572A:  CLRF   03
572C:  MOVF   x94,W
572E:  ADDLW  29
5730:  MOVWF  FE9
5732:  MOVLW  01
5734:  ADDWFC 03,W
5736:  MOVWF  FEA
5738:  MOVLW  01
573A:  MOVWF  00
573C:  MOVLB  0
573E:  CALL   2E08
5742:  MOVFF  01,FEF
....................       } 
5746:  MOVLB  1
5748:  INCF   x94,F
574A:  BRA    5724
....................       for( i = 0 ; i < 34 ; i++ ) 
574C:  CLRF   x94
574E:  MOVF   x94,W
5750:  SUBLW  21
5752:  BNC   5776
....................       { 
....................          HemLinCam_Pixels_Zone2[i] = i2c_read(); 
5754:  CLRF   03
5756:  MOVF   x94,W
5758:  ADDLW  4B
575A:  MOVWF  FE9
575C:  MOVLW  01
575E:  ADDWFC 03,W
5760:  MOVWF  FEA
5762:  MOVLW  01
5764:  MOVWF  00
5766:  MOVLB  0
5768:  CALL   2E08
576C:  MOVFF  01,FEF
....................       } 
5770:  MOVLB  1
5772:  INCF   x94,F
5774:  BRA    574E
....................       for( i = 0 ; i < 33 ; i++ ) 
5776:  CLRF   x94
5778:  MOVF   x94,W
577A:  SUBLW  20
577C:  BNC   57A0
....................       { 
....................          HemLinCam_Pixels_Zone3[i] = i2c_read(); 
577E:  CLRF   03
5780:  MOVF   x94,W
5782:  ADDLW  6D
5784:  MOVWF  FE9
5786:  MOVLW  01
5788:  ADDWFC 03,W
578A:  MOVWF  FEA
578C:  MOVLW  01
578E:  MOVWF  00
5790:  MOVLB  0
5792:  CALL   2E08
5796:  MOVFF  01,FEF
....................       } 
579A:  MOVLB  1
579C:  INCF   x94,F
579E:  BRA    5778
....................       HemLinCam_Pixels_Zone3[33] = i2c_read(0); 
57A0:  CLRF   00
57A2:  MOVLB  0
57A4:  CALL   2E08
57A8:  MOVFF  01,18E
....................       i2c_stop(); 
57AC:  BSF    FC5.2
57AE:  BTFSC  FC5.2
57B0:  BRA    57AE
....................       delay_ms(1); 
57B2:  MOVLW  01
57B4:  MOVLB  1
57B6:  MOVWF  x96
57B8:  MOVLB  0
57BA:  CALL   13F2
.................... } 
57BE:  GOTO   580E (RETURN)
....................  
.................... void HemLinCam_Read_Pixels_Thresholded( void ) 
.................... { 
....................       int i; 
....................       delay_ms(HemLinCam_Read_Exposition_Time()); 
*
5602:  RCALL  55AA
5604:  MOVFF  01,195
5608:  MOVFF  01,196
560C:  CALL   13F2
....................       i2c_start();                                                // I2C Start Sequence 
5610:  BSF    FC5.0
5612:  BTFSC  FC5.0
5614:  BRA    5612
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
5616:  MOVLW  C0
5618:  MOVLB  1
561A:  MOVWF  xCB
561C:  MOVLB  0
561E:  CALL   2DEC
....................       i2c_write(0x11); 
5622:  MOVLW  11
5624:  MOVLB  1
5626:  MOVWF  xCB
5628:  MOVLB  0
562A:  CALL   2DEC
....................       i2c_start(); 
562E:  BSF    FC5.1
5630:  BTFSC  FC5.1
5632:  BRA    5630
....................       i2c_write(HEMLINCAM_I2C_ADDRESS + 1 );                      // HemLinCam I2C Read Address 
5634:  MOVLW  C1
5636:  MOVLB  1
5638:  MOVWF  xCB
563A:  MOVLB  0
563C:  CALL   2DEC
....................       for( i = 0 ; i < 34 ; i++ ) 
5640:  MOVLB  1
5642:  CLRF   x94
5644:  MOVF   x94,W
5646:  SUBLW  21
5648:  BNC   566C
....................       { 
....................          HemLinCam_Pixels_Zone1[i] = i2c_read(); 
564A:  CLRF   03
564C:  MOVF   x94,W
564E:  ADDLW  29
5650:  MOVWF  FE9
5652:  MOVLW  01
5654:  ADDWFC 03,W
5656:  MOVWF  FEA
5658:  MOVLW  01
565A:  MOVWF  00
565C:  MOVLB  0
565E:  CALL   2E08
5662:  MOVFF  01,FEF
....................       } 
5666:  MOVLB  1
5668:  INCF   x94,F
566A:  BRA    5644
....................       for( i = 0 ; i < 34 ; i++ ) 
566C:  CLRF   x94
566E:  MOVF   x94,W
5670:  SUBLW  21
5672:  BNC   5696
....................       { 
....................          HemLinCam_Pixels_Zone2[i] = i2c_read(); 
5674:  CLRF   03
5676:  MOVF   x94,W
5678:  ADDLW  4B
567A:  MOVWF  FE9
567C:  MOVLW  01
567E:  ADDWFC 03,W
5680:  MOVWF  FEA
5682:  MOVLW  01
5684:  MOVWF  00
5686:  MOVLB  0
5688:  CALL   2E08
568C:  MOVFF  01,FEF
....................       } 
5690:  MOVLB  1
5692:  INCF   x94,F
5694:  BRA    566E
....................       for( i = 0 ; i < 33 ; i++ ) 
5696:  CLRF   x94
5698:  MOVF   x94,W
569A:  SUBLW  20
569C:  BNC   56C0
....................       { 
....................          HemLinCam_Pixels_Zone3[i] = i2c_read(); 
569E:  CLRF   03
56A0:  MOVF   x94,W
56A2:  ADDLW  6D
56A4:  MOVWF  FE9
56A6:  MOVLW  01
56A8:  ADDWFC 03,W
56AA:  MOVWF  FEA
56AC:  MOVLW  01
56AE:  MOVWF  00
56B0:  MOVLB  0
56B2:  CALL   2E08
56B6:  MOVFF  01,FEF
....................       } 
56BA:  MOVLB  1
56BC:  INCF   x94,F
56BE:  BRA    5698
....................       HemLinCam_Pixels_Zone3[33] = i2c_read(0); 
56C0:  CLRF   00
56C2:  MOVLB  0
56C4:  CALL   2E08
56C8:  MOVFF  01,18E
....................       i2c_stop(); 
56CC:  BSF    FC5.2
56CE:  BTFSC  FC5.2
56D0:  BRA    56CE
....................       delay_ms(1); 
56D2:  MOVLW  01
56D4:  MOVLB  1
56D6:  MOVWF  x96
56D8:  MOVLB  0
56DA:  CALL   13F2
.................... } 
56DE:  GOTO   580E (RETURN)
....................  
.................... void HemLinCam_Set_Led_State( char value) 
.................... { 
....................       i2c_start();                                                // I2C Start Sequence 
*
53D0:  BSF    FC5.0
53D2:  BTFSC  FC5.0
53D4:  BRA    53D2
....................       i2c_write(HEMLINCAM_I2C_ADDRESS);                           // HemLinCam I2C Address 
53D6:  MOVLW  C0
53D8:  MOVLB  1
53DA:  MOVWF  xCB
53DC:  MOVLB  0
53DE:  CALL   2DEC
....................       i2c_write(0x30);                                            // Led Register 
53E2:  MOVLW  30
53E4:  MOVLB  1
53E6:  MOVWF  xCB
53E8:  MOVLB  0
53EA:  CALL   2DEC
....................       i2c_write(value); 
53EE:  MOVFF  195,1CB
53F2:  CALL   2DEC
....................       i2c_stop();                                                 // I2C Stop Sequence 
53F6:  BSF    FC5.2
53F8:  BTFSC  FC5.2
53FA:  BRA    53F8
....................       delay_ms(1); 
53FC:  MOVLW  01
53FE:  MOVLB  1
5400:  MOVWF  x96
5402:  MOVLB  0
5404:  CALL   13F2
.................... } 
5408:  RETURN 0
....................  
....................  
.................... // Utilities to read and output pixels read on linear camera 
.................... #include "simple_camera_reading.h" 
.................... /** 
....................  * @file 
....................  *  
....................  * @brief Utilities to read and print pixels from the linear camera 
....................  */ 
....................  
.................... #ifndef SIMPLE_CAMERA_READING_H 
.................... #define SIMPLE_CAMERA_READING_H 
....................  
.................... // Aliases for arrays named by HemLinCam library 
.................... #define LEFT_PIXELS   HemLinCam_Pixels_Zone1 
.................... #define CENTER_PIXELS HemLinCam_Pixels_Zone2 
.................... #define RIGHT_PIXELS  HemLinCam_Pixels_Zone3 
....................  
.................... int1 cr_threshold_enabled = 0; ///< is camera threshold enabled? 
.................... int8 cr_threshold = 120; ///< default camera threshold 
.................... int8 cr_exposition_time = 1; ///< camera exposition time defaults to 1 
....................  
.................... void  cr_print_pixels(unsigned char *array34); 
.................... char* cr_make_single_pixels_array(); 
.................... void  cr_print_pixels_bluetooth(); 
....................  
.................... #include "simple_camera_reading.c" 
.................... /** 
....................  * @file 
....................  *  
....................  * @brief Utilities to read and print pixels from the linear camera 
....................  */ 
....................  
.................... #include "simple_camera_reading.h" 
.................... /** 
....................  * @file 
....................  *  
....................  * @brief Utilities to read and print pixels from the linear camera 
....................  */ 
....................  
.................... #ifndef SIMPLE_CAMERA_READING_H 
.................... #define SIMPLE_CAMERA_READING_H 
....................  
.................... // Aliases for arrays named by HemLinCam library 
.................... #define LEFT_PIXELS   HemLinCam_Pixels_Zone1 
.................... #define CENTER_PIXELS HemLinCam_Pixels_Zone2 
.................... #define RIGHT_PIXELS  HemLinCam_Pixels_Zone3 
....................  
.................... int1 cr_threshold_enabled = 0; ///< is camera threshold enabled? 
.................... int8 cr_threshold = 120; ///< default camera threshold 
.................... int8 cr_exposition_time = 1; ///< camera exposition time defaults to 1 
....................  
.................... void  cr_print_pixels(unsigned char *array34); 
.................... char* cr_make_single_pixels_array(); 
.................... void  cr_print_pixels_bluetooth(); 
....................  
.................... #include "simple_camera_reading.c" 
....................  
.................... #endif 
....................  
....................  
.................... /** 
....................  * Prints an array of 34 pixels to Bluetooth output. 
....................  * 
....................  * @param array an array of 34 char values (as provided by HemLinCam) 
....................  */ 
.................... void cr_print_pixels(unsigned char *array34) 
.................... { 
*
57C2:  MOVLW  22
57C4:  MOVLB  1
57C6:  MOVWF  x96
....................    // NB: Assume size of 34 
....................    int array_size = 34; 
....................     
....................    for (int i = 0; i<array_size; i++) 
57C8:  CLRF   x97
57CA:  MOVF   x96,W
57CC:  SUBWF  x97,W
57CE:  BC    5800
....................    { 
....................       fprintf (BT, "%u ", array34[i]); 
57D0:  CLRF   03
57D2:  MOVF   x97,W
57D4:  ADDWF  x94,W
57D6:  MOVWF  FE9
57D8:  MOVF   x95,W
57DA:  ADDWFC 03,W
57DC:  MOVWF  FEA
57DE:  MOVFF  FEF,198
57E2:  MOVFF  198,199
57E6:  MOVLW  1B
57E8:  MOVWF  x9A
57EA:  MOVLB  0
57EC:  CALL   3770
57F0:  MOVLW  20
57F2:  BTFSS  FA4.4
57F4:  BRA    57F2
57F6:  MOVLB  F
57F8:  MOVWF  x1C
....................    } 
57FA:  MOVLB  1
57FC:  INCF   x97,F
57FE:  BRA    57CA
.................... } 
5800:  MOVLB  0
5802:  RETURN 0
....................  
.................... /** 
....................  * Concatenate the three 34 pixels arrays into one single 102 pixels array. 
....................  */ 
.................... char* cr_make_single_pixels_array() 
.................... { 
*
5276:  MOVLB  1
5278:  CLRF   xFC
....................    char array[102]; 
....................     
....................    int current_index = 0; 
....................    int i; 
....................     
....................    for (i = 0; i<34; i++) 
527A:  CLRF   xFD
527C:  MOVF   xFD,W
527E:  SUBLW  21
5280:  BNC   52BA
....................    { 
....................       array[current_index++] = LEFT_PIXELS[i]; 
5282:  MOVF   xFC,W
5284:  INCF   xFC,F
5286:  CLRF   03
5288:  ADDLW  96
528A:  MOVWF  01
528C:  MOVLW  01
528E:  ADDWFC 03,F
5290:  MOVFF  03,1FF
5294:  CLRF   03
5296:  MOVF   xFD,W
5298:  ADDLW  29
529A:  MOVWF  FE9
529C:  MOVLW  01
529E:  ADDWFC 03,W
52A0:  MOVWF  FEA
52A2:  MOVFF  FEF,200
52A6:  MOVLB  2
52A8:  MOVFF  1FF,FEA
52AC:  MOVFF  01,FE9
52B0:  MOVFF  200,FEF
....................    } 
52B4:  MOVLB  1
52B6:  INCF   xFD,F
52B8:  BRA    527C
....................    for (i = 0; i<34; i++) 
52BA:  CLRF   xFD
52BC:  MOVF   xFD,W
52BE:  SUBLW  21
52C0:  BNC   52FA
....................    { 
....................       array[current_index++] = CENTER_PIXELS[i]; 
52C2:  MOVF   xFC,W
52C4:  INCF   xFC,F
52C6:  CLRF   03
52C8:  ADDLW  96
52CA:  MOVWF  01
52CC:  MOVLW  01
52CE:  ADDWFC 03,F
52D0:  MOVFF  03,1FF
52D4:  CLRF   03
52D6:  MOVF   xFD,W
52D8:  ADDLW  4B
52DA:  MOVWF  FE9
52DC:  MOVLW  01
52DE:  ADDWFC 03,W
52E0:  MOVWF  FEA
52E2:  MOVFF  FEF,200
52E6:  MOVLB  2
52E8:  MOVFF  1FF,FEA
52EC:  MOVFF  01,FE9
52F0:  MOVFF  200,FEF
....................    } 
52F4:  MOVLB  1
52F6:  INCF   xFD,F
52F8:  BRA    52BC
....................    for (i = 0; i<34; i++) 
52FA:  CLRF   xFD
52FC:  MOVF   xFD,W
52FE:  SUBLW  21
5300:  BNC   533A
....................    { 
....................       array[current_index++] = RIGHT_PIXELS[i]; 
5302:  MOVF   xFC,W
5304:  INCF   xFC,F
5306:  CLRF   03
5308:  ADDLW  96
530A:  MOVWF  01
530C:  MOVLW  01
530E:  ADDWFC 03,F
5310:  MOVFF  03,1FF
5314:  CLRF   03
5316:  MOVF   xFD,W
5318:  ADDLW  6D
531A:  MOVWF  FE9
531C:  MOVLW  01
531E:  ADDWFC 03,W
5320:  MOVWF  FEA
5322:  MOVFF  FEF,200
5326:  MOVLB  2
5328:  MOVFF  1FF,FEA
532C:  MOVFF  01,FE9
5330:  MOVFF  200,FEF
....................    } 
5334:  MOVLB  1
5336:  INCF   xFD,F
5338:  BRA    52FC
....................     
....................    return array; 
533A:  MOVLW  96
533C:  MOVWF  01
533E:  MOVLW  01
5340:  MOVWF  02
.................... } 
5342:  MOVLB  0
5344:  GOTO   5390 (RETURN)
....................  
.................... /** 
....................  * Prints a line of 102 pixel values to Bluetooth serial port. 
....................  */ 
.................... void cr_print_pixels_bluetooth() { 
....................    // Fire the camera shutter to update the pixels arrays 
....................    if (cr_threshold_enabled) 
*
5804:  BTFSS  x88.5
5806:  BRA    580C
....................       HemLinCam_Read_Pixels_Thresholded () ; 
5808:  BRA    5602
....................    else 
580A:  BRA    580E
....................       HemLinCam_Read_Pixels () ; 
580C:  BRA    56E2
....................    
....................     cr_print_pixels (LEFT_PIXELS) ; 
580E:  MOVLW  01
5810:  MOVLB  1
5812:  MOVWF  x95
5814:  MOVLW  29
5816:  MOVWF  x94
5818:  MOVLB  0
581A:  RCALL  57C2
....................     cr_print_pixels (CENTER_PIXELS) ; 
581C:  MOVLW  01
581E:  MOVLB  1
5820:  MOVWF  x95
5822:  MOVLW  4B
5824:  MOVWF  x94
5826:  MOVLB  0
5828:  RCALL  57C2
....................     cr_print_pixels (RIGHT_PIXELS) ; 
582A:  MOVLW  01
582C:  MOVLB  1
582E:  MOVWF  x95
5830:  MOVLW  6D
5832:  MOVWF  x94
5834:  MOVLB  0
5836:  RCALL  57C2
....................     fprintf (BT, "\r\n"); // Windows line break 
5838:  MOVLW  0D
583A:  BTFSS  FA4.4
583C:  BRA    583A
583E:  MOVLB  F
5840:  MOVWF  x1C
5842:  MOVLW  0A
5844:  BTFSS  FA4.4
5846:  BRA    5844
5848:  MOVWF  x1C
.................... } 
584A:  MOVLB  0
584C:  GOTO   71E8 (RETURN)
....................  
....................  
.................... #endif 
....................  
....................  
.................... // Set camera settings with TV remote control 
.................... #include "simple_camera_settings_with_tv_remote.h"  
.................... #ifndef SIMPLE_CAMERA_SETTINGS_WITH_TV_REMOTE_H 
.................... #define SIMPLE_CAMERA_SETTINGS_WITH_TV_REMOTE_H 
....................  
.................... void cs_init(void); 
.................... void cs_reset_tv_remote(void); 
....................  
.................... int1 cs_exp_time_up(void); 
.................... int1 cs_exp_time_down(void; 
....................  
.................... int1 cs_power_button(void); 
....................  
.................... /** 
....................  * Step to increment or decrement when user presses the "Threshold UP" or  
....................  * "Threshold DOWN" key on the TV remote control 
....................  */ 
.................... #define CS_THRESHOLD_INCREMENT 20 
....................  
.................... int1 cs_threshold_up(void); 
.................... int1 cs_threshold_down(void); 
....................  
.................... void cs_set_camera_with_tv_remote(void); 
....................  
.................... #include "simple_camera_settings_with_tv_remote.c" 
.................... #include "simple_camera_settings_with_tv_remote.h" 
.................... #ifndef SIMPLE_CAMERA_SETTINGS_WITH_TV_REMOTE_H 
.................... #define SIMPLE_CAMERA_SETTINGS_WITH_TV_REMOTE_H 
....................  
.................... void cs_init(void); 
.................... void cs_reset_tv_remote(void); 
....................  
.................... int1 cs_exp_time_up(void); 
.................... int1 cs_exp_time_down(void; 
....................  
.................... int1 cs_power_button(void); 
....................  
.................... /** 
....................  * Step to increment or decrement when user presses the "Threshold UP" or  
....................  * "Threshold DOWN" key on the TV remote control 
....................  */ 
.................... #define CS_THRESHOLD_INCREMENT 20 
....................  
.................... int1 cs_threshold_up(void); 
.................... int1 cs_threshold_down(void); 
....................  
.................... void cs_set_camera_with_tv_remote(void); 
....................  
.................... #include "simple_camera_settings_with_tv_remote.c" 
....................  
.................... #endif 
....................  
.................... #include "tv_remote_utils.h" 
.................... /** 
....................  * @file 
....................  *  
....................  * @brief Utilities to read keys pressed from the TV remote control 
....................  */ 
....................  
.................... #ifndef TV_REMOTE_UTILS_H 
.................... #define TV_REMOTE_UTILS_H 
....................  
.................... // Constants for buttons of the TV remote control 
.................... #define TV_POWER        38 
.................... #define TV_MUTE         36 
.................... #define TV_CH_PLUS      30 
.................... #define TV_CH_MINUS     28 
.................... #define TV_VOL_PLUS     18 
.................... #define TV_VOL_MINUS    20 
.................... #define TV_TV_AV        34 
.................... #define TV_I_II         56 
.................... #define TV_3            56 
.................... #define TV_ARROW        56 
.................... // TV_0 ---> TV_11 : Please use to_pad_number if needed 
.................... #define TV_CH_PC        32 
....................  
.................... /** 
....................  * Convert the raw button id from TV remote to the button number. 
....................  * 
....................  * @param raw_input Raw input from TV remote. 
....................  * @return the corresponding button number matching the TV remote raw input. 
....................  */ 
.................... int8 to_pad_number(unsigned char raw_input); 
....................  
.................... /** 
....................  * Returns the last number pressed on the TV remote number pad. 
....................  * 
....................  * @return the last number pressed on the TV remote number pad. 
....................  */ 
.................... int8 get_tv_remote_pad_number(void); 
....................  
.................... #include "tv_remote_utils.c" 
.................... /** 
....................  * @file 
....................  *  
....................  * @brief Utilities to read keys pressed from the TV remote control 
....................  */ 
....................  
.................... /** 
....................  * Convert the raw button id from TV remote to the button number. 
....................  * 
....................  * @param raw_input Raw input from TV remote. 
....................  * @returns the corresponding button number matching the TV remote raw input. 
....................  */ 
.................... int8 to_pad_number(unsigned char raw_input) 
.................... { 
....................    switch((int8) raw_input) 
....................    { 
....................       case 62: 
....................          return 0; 
....................       case 60: 
....................          return 1; 
....................       case 58: 
....................          return 2; 
....................       case 56: 
....................          return 3; 
....................       case 54: 
....................          return 4; 
....................       case 52: 
....................          return 5; 
....................       case 50: 
....................          return 6; 
....................       case 48: 
....................          return 7; 
....................       case 46: 
....................          return 8; 
....................       case 44: 
....................          return 9; 
....................       case 42: 
....................          return 11; 
....................       default: 
....................          return -1; 
....................    } 
.................... } 
....................  
.................... /** 
....................  * Returns the last number pressed on the TV remote number pad. 
....................  * 
....................  * @return the last number pressed on the TV remote number pad. 
....................  */ 
.................... int8 get_tv_remote_pad_number(void) { 
....................    return to_pad_number(KJunior_get_tv_data()); 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "binary_led_transcoder.h" 
.................... #ifndef BINARY_LED_TRANSCODER_H 
.................... #define BINARY_LED_TRANSCODER_H 
....................  
....................  
.................... /** 
....................  * Display the specified number in binary format with the four supplied LEDs. 
....................  * 
....................  * @param number A number from 0 to 9 (limitation due to the TV remote) 
....................  */ 
.................... void led_display_number(int8 number); 
....................  
.................... #include "binary_led_transcoder.c" 
.................... #include "binary_led_transcoder.h" 
.................... #ifndef BINARY_LED_TRANSCODER_H 
.................... #define BINARY_LED_TRANSCODER_H 
....................  
....................  
.................... /** 
....................  * Display the specified number in binary format with the four supplied LEDs. 
....................  * 
....................  * @param number A number from 0 to 9 (limitation due to the TV remote) 
....................  */ 
.................... void led_display_number(int8 number); 
....................  
.................... #include "binary_led_transcoder.c" 
....................  
.................... #endif 
....................  
....................  
.................... /** 
....................  * Display the specified number in binary format with the four supplied LEDs. 
....................  * 
....................  * @param number A number from 0 to 15 
....................  */ 
.................... void led_display_number(int8 number) 
.................... { 
....................    // binary code of decimal numbers from 0 to 15 
....................    int8 codes[16][4] = { 
....................                   {0,0,0,0}, // 0 
....................                   {0,0,0,1}, // 1 
....................                   {0,0,1,0}, // 2 
....................                   {0,0,1,1}, // 3 
....................                   {0,1,0,0}, // 4 
....................                   {0,1,0,1}, // 5 
....................                   {0,1,1,0}, // 6 
....................                   {0,1,1,1}, // 7 
....................                   {1,0,0,0}, // 8 
....................                   {1,0,0,1}, // 9 
....................                   {1,0,1,0}, // 10 
....................                   {1,0,1,1}, // 11 
....................                   {1,1,0,0}, // 12 
....................                   {1,1,0,1}, // 13 
....................                   {1,1,1,0}, // 14 
....................                   {1,1,1,1}, // 15 
....................                    
....................    }; 
*
1A7E:  MOVLB  1
1A80:  CLRF   x96
1A82:  CLRF   x97
1A84:  CLRF   x98
1A86:  CLRF   x99
1A88:  CLRF   x9A
1A8A:  CLRF   x9B
1A8C:  CLRF   x9C
1A8E:  MOVLW  01
1A90:  MOVWF  x9D
1A92:  CLRF   x9E
1A94:  CLRF   x9F
1A96:  MOVWF  xA0
1A98:  CLRF   xA1
1A9A:  CLRF   xA2
1A9C:  CLRF   xA3
1A9E:  MOVWF  xA4
1AA0:  MOVWF  xA5
1AA2:  CLRF   xA6
1AA4:  MOVWF  xA7
1AA6:  CLRF   xA8
1AA8:  CLRF   xA9
1AAA:  CLRF   xAA
1AAC:  MOVWF  xAB
1AAE:  CLRF   xAC
1AB0:  MOVWF  xAD
1AB2:  CLRF   xAE
1AB4:  MOVWF  xAF
1AB6:  MOVWF  xB0
1AB8:  CLRF   xB1
1ABA:  CLRF   xB2
1ABC:  MOVWF  xB3
1ABE:  MOVWF  xB4
1AC0:  MOVWF  xB5
1AC2:  MOVWF  xB6
1AC4:  CLRF   xB7
1AC6:  CLRF   xB8
1AC8:  CLRF   xB9
1ACA:  MOVWF  xBA
1ACC:  CLRF   xBB
1ACE:  CLRF   xBC
1AD0:  MOVWF  xBD
1AD2:  MOVWF  xBE
1AD4:  CLRF   xBF
1AD6:  MOVWF  xC0
1AD8:  CLRF   xC1
1ADA:  MOVWF  xC2
1ADC:  CLRF   xC3
1ADE:  MOVWF  xC4
1AE0:  MOVWF  xC5
1AE2:  MOVWF  xC6
1AE4:  MOVWF  xC7
1AE6:  CLRF   xC8
1AE8:  CLRF   xC9
1AEA:  MOVWF  xCA
1AEC:  MOVWF  xCB
1AEE:  CLRF   xCC
1AF0:  MOVWF  xCD
1AF2:  MOVWF  xCE
1AF4:  MOVWF  xCF
1AF6:  MOVWF  xD0
1AF8:  CLRF   xD1
1AFA:  MOVWF  xD2
1AFC:  MOVWF  xD3
1AFE:  MOVWF  xD4
1B00:  MOVWF  xD5
....................     
....................    // Lit the leds accordling to the table above 
....................    KJunior_led_left(codes[number][0]); 
1B02:  MOVF   x95,W
1B04:  MULLW  04
1B06:  MOVF   FF3,W
1B08:  CLRF   xD7
1B0A:  MOVWF  xD6
1B0C:  MOVLW  96
1B0E:  ADDWF  xD6,W
1B10:  MOVWF  FE9
1B12:  MOVLW  01
1B14:  ADDWFC xD7,W
1B16:  MOVWF  FEA
1B18:  MOVFF  FEF,1D8
1B1C:  MOVFF  1D8,1D9
1B20:  MOVLB  0
1B22:  RCALL  1A3E
....................    KJunior_led_frontleft(codes[number][1]); 
1B24:  MOVLB  1
1B26:  MOVF   x95,W
1B28:  MULLW  04
1B2A:  MOVF   FF3,W
1B2C:  CLRF   xD7
1B2E:  MOVWF  xD6
1B30:  MOVLW  01
1B32:  ADDWF  xD6,W
1B34:  MOVWF  01
1B36:  MOVLW  00
1B38:  ADDWFC xD7,W
1B3A:  MOVWF  03
1B3C:  MOVF   01,W
1B3E:  ADDLW  96
1B40:  MOVWF  FE9
1B42:  MOVLW  01
1B44:  ADDWFC 03,W
1B46:  MOVWF  FEA
1B48:  MOVFF  FEF,1D6
1B4C:  MOVFF  1D6,1D7
1B50:  MOVLB  0
1B52:  RCALL  1A4E
....................    KJunior_led_frontright(codes[number][2]); 
1B54:  MOVLB  1
1B56:  MOVF   x95,W
1B58:  MULLW  04
1B5A:  MOVF   FF3,W
1B5C:  CLRF   xD7
1B5E:  MOVWF  xD6
1B60:  MOVLW  02
1B62:  ADDWF  xD6,W
1B64:  MOVWF  01
1B66:  MOVLW  00
1B68:  ADDWFC xD7,W
1B6A:  MOVWF  03
1B6C:  MOVF   01,W
1B6E:  ADDLW  96
1B70:  MOVWF  FE9
1B72:  MOVLW  01
1B74:  ADDWFC 03,W
1B76:  MOVWF  FEA
1B78:  MOVFF  FEF,1D6
1B7C:  MOVFF  1D6,1D7
1B80:  MOVLB  0
1B82:  RCALL  1A5E
....................    KJunior_led_right(codes[number][3]); 
1B84:  MOVLB  1
1B86:  MOVF   x95,W
1B88:  MULLW  04
1B8A:  MOVF   FF3,W
1B8C:  CLRF   xD7
1B8E:  MOVWF  xD6
1B90:  MOVLW  03
1B92:  ADDWF  xD6,W
1B94:  MOVWF  01
1B96:  MOVLW  00
1B98:  ADDWFC xD7,W
1B9A:  MOVWF  03
1B9C:  MOVF   01,W
1B9E:  ADDLW  96
1BA0:  MOVWF  FE9
1BA2:  MOVLW  01
1BA4:  ADDWFC 03,W
1BA6:  MOVWF  FEA
1BA8:  MOVFF  FEF,1D6
1BAC:  MOVFF  1D6,1D7
1BB0:  MOVLB  0
1BB2:  RCALL  1A6E
.................... } 
1BB4:  RETURN 0
....................  
....................  
.................... #endif 
....................  
....................  
.................... /** 
....................  * Init program to read camera settings from TV remote and set them. 
....................  */ 
.................... void cs_init(void) 
.................... { 
....................    // Force TV remote value to 60, which is the '1' key 
....................    // because exposition time must be 1 by default 
....................    TV_DATA = 60; 
*
1BC4:  MOVLW  3C
1BC6:  MOVWF  x84
....................    // We use leds to show the exposition (just for fun!) 
....................    led_display_number (cr_exposition_time) ; 
1BC8:  MOVFF  190,195
1BCC:  RCALL  1A7E
....................    // Enable TV remote 
....................    KJunior_config_tv_remote_control (ENABLE) ; 
1BCE:  MOVLW  01
1BD0:  MOVLB  1
1BD2:  MOVWF  x94
1BD4:  MOVLB  0
1BD6:  BRA    1BB6
.................... } 
1BD8:  GOTO   7180 (RETURN)
....................  
.................... /** 
....................  * Reset the last pressed key of the TV remote. 
....................  * This is needed to detect multiple presses of the very same key. 
....................  */ 
.................... void cs_reset_tv_remote(void) 
.................... { 
....................   TV_DATA = 0; // important trick to know when using TV remote ! 
*
5850:  CLRF   x84
.................... } 
5852:  GOTO   71EC (RETURN)
....................  
.................... /** 
....................  * Returns true if user pressed the key on the TV remote control to set a greater exposition time. 
....................  */ 
.................... int1 cs_exp_time_up(void) 
.................... { 
....................    return KJunior_get_tv_data() == TV_CH_PLUS; 
*
541E:  RCALL  53CA
5420:  MOVF   01,W
5422:  SUBLW  1E
5424:  BZ    542A
5426:  MOVLW  00
5428:  BRA    542C
542A:  MOVLW  01
542C:  MOVWF  01
.................... } 
542E:  GOTO   552E (RETURN)
....................  
.................... /** 
....................  * Returns true if user pressed the key on the TV remote control to set a smaller exposition time. 
....................  */ 
.................... int1 cs_exp_time_down(void) 
.................... { 
....................    return KJunior_get_tv_data() == TV_CH_MINUS; 
*
546C:  RCALL  53CA
546E:  MOVF   01,W
5470:  SUBLW  1C
5472:  BZ    5478
5474:  MOVLW  00
5476:  BRA    547A
5478:  MOVLW  01
547A:  MOVWF  01
.................... } 
547C:  GOTO   5550 (RETURN)
....................  
.................... /** 
....................  * Returns true if user pressed the power key on the TV remote control  
....................  */ 
.................... int1 cs_power_button(void) { 
....................    return KJunior_get_tv_data() == TV_POWER; 
*
540A:  RCALL  53CA
540C:  MOVF   01,W
540E:  SUBLW  26
5410:  BZ    5416
5412:  MOVLW  00
5414:  BRA    5418
5416:  MOVLW  01
5418:  MOVWF  01
.................... } 
541A:  GOTO   5516 (RETURN)
....................  
.................... /** 
....................  * Returns true if user pressed the key on the TV remote control to set a greater threshold value. 
....................  */ 
.................... int1 cs_threshold_up(void) { 
....................    return KJunior_get_tv_data() == TV_VOL_PLUS; 
*
5480:  RCALL  53CA
5482:  MOVF   01,W
5484:  SUBLW  12
5486:  BZ    548C
5488:  MOVLW  00
548A:  BRA    548E
548C:  MOVLW  01
548E:  MOVWF  01
.................... } 
5490:  GOTO   5576 (RETURN)
....................  
.................... /** 
....................  * Returns true if user pressed the key on the TV remote control to set a smaller threshold value. 
....................  */ 
.................... int1 cs_threshold_down(void) { 
....................    return KJunior_get_tv_data() == TV_VOL_MINUS; 
*
54CE:  RCALL  53CA
54D0:  MOVF   01,W
54D2:  SUBLW  14
54D4:  BZ    54DA
54D6:  MOVLW  00
54D8:  BRA    54DC
54DA:  MOVLW  01
54DC:  MOVWF  01
.................... } 
54DE:  GOTO   5590 (RETURN)
....................  
.................... /** 
....................  * Read key pressed on the TV remote control and set the corresponding camera setting 
....................  * accordingly. 
....................  */ 
.................... void cs_set_camera_with_tv_remote(void) 
.................... { 
....................      // Reset camera settings to default values 
....................      if(KJunior_get_tv_data() == TV_MUTE) 
54E2:  RCALL  53CA
54E4:  MOVF   01,W
54E6:  SUBLW  24
54E8:  BNZ   5514
....................      { 
....................          cr_exposition_time = 1; 
54EA:  MOVLW  01
54EC:  MOVLB  1
54EE:  MOVWF  x90
....................          led_display_number(cr_exposition_time); 
54F0:  MOVFF  190,195
54F4:  MOVLB  0
54F6:  CALL   1A7E
....................          cr_threshold = 120; 
54FA:  MOVLW  78
54FC:  MOVLB  1
54FE:  MOVWF  x8F
....................          cr_threshold_enabled = false; 
5500:  MOVLB  0
5502:  BCF    x88.5
....................          HemLinCam_Set_Led_State(cr_threshold_enabled); 
5504:  MOVLW  00
5506:  BTFSC  x88.5
5508:  MOVLW  01
550A:  MOVLB  1
550C:  MOVWF  x94
550E:  MOVWF  x95
5510:  MOVLB  0
5512:  RCALL  53D0
....................      }   
....................          
....................       // POWER_BUTTON => Activate/Disable threshold. Is disabled by default. 
....................       if(cs_power_button()) 
5514:  BRA    540A
5516:  MOVF   01,F
5518:  BZ    552C
....................       { 
....................          // Toggle threshold 
....................          cr_threshold_enabled = !cr_threshold_enabled; 
551A:  BTG    x88.5
....................           
....................          // Enable / Disable On/Off LED 
....................          HemLinCam_Set_Led_State(cr_threshold_enabled); 
551C:  MOVLW  00
551E:  BTFSC  x88.5
5520:  MOVLW  01
5522:  MOVLB  1
5524:  MOVWF  x94
5526:  MOVWF  x95
5528:  MOVLB  0
552A:  RCALL  53D0
....................       } 
....................        
....................       // Exposition time UP 
....................       if(cs_exp_time_up()) 
552C:  BRA    541E
552E:  MOVF   01,F
5530:  BZ    554E
....................       { 
....................          // We don't check for 255 (max value), user won't try that because 
....................          // image is already full white around 10-15... 
....................          cr_exposition_time++; 
5532:  MOVLB  1
5534:  INCF   x90,F
....................           
....................     // Set the exposition time for real 
....................          HemLinCam_Set_Exposition_Time(cr_exposition_time); 
5536:  MOVFF  190,194
553A:  MOVLB  0
553C:  RCALL  5432
....................          // Show exposition time with LEDs 
....................          // 16 will be shown as 0, 17 as 1, 18 as 2, ... (modulo 16) 
....................          led_display_number(cr_exposition_time % 16); 
553E:  MOVLB  1
5540:  MOVF   x90,W
5542:  ANDLW  0F
5544:  MOVWF  x94
5546:  MOVWF  x95
5548:  MOVLB  0
554A:  CALL   1A7E
....................       } 
....................        
....................       // Exposition time DOWN 
....................       if(cs_exp_time_down()) 
554E:  BRA    546C
5550:  MOVF   01,F
5552:  BZ    5574
....................       { 
....................          if(cr_exposition_time != 0) // do not go below 0 
5554:  MOVLB  1
5556:  MOVF   x90,F
5558:  BZ    555C
....................          { 
....................             cr_exposition_time--; 
555A:  DECF   x90,F
....................          } 
....................           
....................          // Set the exposition time for real 
....................          HemLinCam_Set_Exposition_Time(cr_exposition_time); 
555C:  MOVFF  190,194
5560:  MOVLB  0
5562:  RCALL  5432
....................          led_display_number(cr_exposition_time % 16); 
5564:  MOVLB  1
5566:  MOVF   x90,W
5568:  ANDLW  0F
556A:  MOVWF  x94
556C:  MOVWF  x95
556E:  MOVLB  0
5570:  CALL   1A7E
....................       } 
....................        
....................       // Threshold UP 
....................       if(cs_threshold_up()) 
5574:  BRA    5480
5576:  MOVF   01,F
5578:  BZ    558E
....................       { 
....................          // Do not go over 240 
....................          if(cr_threshold != 240) 
557A:  MOVLB  1
557C:  MOVF   x8F,W
557E:  SUBLW  F0
5580:  BZ    5586
....................          { 
....................             cr_threshold += CS_THRESHOLD_INCREMENT; // Move threshold 40 up 
5582:  MOVLW  14
5584:  ADDWF  x8F,F
....................          } 
....................           
....................          HemLinCam_Set_Threshold(cr_threshold); 
5586:  MOVFF  18F,194
558A:  MOVLB  0
558C:  RCALL  5494
....................       } 
....................        
....................       // Threshold DOWN 
....................       if(cs_threshold_down()) 
558E:  BRA    54CE
5590:  MOVF   01,F
5592:  BZ    55A6
....................       { 
....................          // Do not go below 0 
....................          if(cr_threshold != 0) 
5594:  MOVLB  1
5596:  MOVF   x8F,F
5598:  BZ    559E
....................          { 
....................             cr_threshold -= CS_THRESHOLD_INCREMENT; 
559A:  MOVLW  14
559C:  SUBWF  x8F,F
....................          } 
....................           
....................          HemLinCam_Set_Threshold(cr_threshold); 
559E:  MOVFF  18F,194
55A2:  MOVLB  0
55A4:  RCALL  5494
....................       } 
.................... } 
55A6:  GOTO   71E4 (RETURN)
....................  
....................  
.................... #endif 
....................  
....................  
.................... // Basic functions such as sleep_ms() 
.................... #include "basic_functions.h"  
.................... /** 
....................  * @file 
....................  *  
....................  * @brief A melting pot of basic functions 
....................  * 
....................  * This file holds some pretty basicu functions, for example sleep or rotate functions. 
....................  * Note that it is not complete at the time... 
....................  * 
....................  *@author Lucy Linder, Mathieu Clement, Yves Kalberer 
....................  *@version 0.1 
....................  *@date 11.11.2012 
....................  * 
....................  */ 
....................  
.................... #ifndef BASIC_FUNC 
.................... #define BASIC_FUNC 1 
....................  
.................... #define DIAMETER 100 //!< diameter of the robot, wheel to wheel 
.................... #define PI 3.141592653 
.................... #define PERIM (DIAMETER * PI) //!< perimeter of the robot, wheel to wheel 
....................  
....................  
.................... void sleep_s(unsigned int32); //!< alternative to the KJunior_delay_s function 
.................... void sleep_ms(unsigned int32); //!< alternative to the KJunior_delay_ms function 
.................... void rotate_no_move(unsigned int32 angle, int speed); //!< a try to make the robot rotate on itself at the specified angle 
.................... unsigned int get_speed_in_mms(int32 speed); //!< returns the speed in m/ms according to the formula found in the KJunior documentation 
....................  
.................... #include "basic_functions.c" 
....................  /** 
....................  * @file 
....................  *  
....................  * @brief A melting pot of basic functions 
....................  * 
....................  * See the basic_function.h file for more informations. 
....................  * 
....................  *@author Lucy Linder, Mathieu Clement, Yves Kalberer 
....................  *@version 0.1 
....................  *@date 11.11.2012 
....................  */ 
....................   
....................   
.................... /** 
....................  * This method is an alternative to the KJunior_delay_s 
....................  * which is badly implemented and highly imprecise. 
....................  * the time to hold is expressed in seconds. 
....................  */ 
.................... void sleep_s(unsigned int32 seconds) 
.................... { 
....................     unsigned int32 t1 = KJunior_get_time(); 
....................     while( (KJunior_get_time() - t1) < seconds); 
.................... } 
....................  
.................... /** 
....................  * This method is an alternative to the KJunior_delay_ms 
....................  * which is badly implemented and highly imprecise. 
....................  * the time to hold is expressed in milliseconds. 
....................  */ 
.................... void sleep_ms(unsigned int32 ms) 
.................... { 
*
4AC4:  RCALL  4AB2
4AC6:  MOVFF  03,1A9
4ACA:  MOVFF  02,1A8
4ACE:  MOVFF  01,1A7
4AD2:  MOVFF  00,1A6
....................     unsigned int32 t1 = KJunior_get_time(); 
....................     while( (KJunior_get_time() - t1) < ms); 
4AD6:  RCALL  4AB2
4AD8:  MOVFF  03,1AD
4ADC:  MOVFF  02,1AC
4AE0:  MOVFF  01,1AB
4AE4:  MOVFF  00,1AA
4AE8:  MOVLB  1
4AEA:  MOVF   xA6,W
4AEC:  SUBWF  xAA,F
4AEE:  MOVF   xA7,W
4AF0:  SUBWFB xAB,F
4AF2:  MOVF   xA8,W
4AF4:  SUBWFB xAC,F
4AF6:  MOVF   xA9,W
4AF8:  SUBWFB xAD,F
4AFA:  MOVF   xAD,W
4AFC:  SUBWF  xA5,W
4AFE:  BNC   4B30
4B00:  BTFSC  FD8.2
4B02:  BRA    4B08
4B04:  MOVLB  0
4B06:  BRA    4AD6
4B08:  MOVF   xAC,W
4B0A:  SUBWF  xA4,W
4B0C:  BNC   4B30
4B0E:  BTFSC  FD8.2
4B10:  BRA    4B16
4B12:  MOVLB  0
4B14:  BRA    4AD6
4B16:  MOVF   xAB,W
4B18:  SUBWF  xA3,W
4B1A:  BNC   4B30
4B1C:  BTFSC  FD8.2
4B1E:  BRA    4B24
4B20:  MOVLB  0
4B22:  BRA    4AD6
4B24:  MOVF   xA2,W
4B26:  SUBWF  xAA,W
4B28:  BTFSC  FD8.0
4B2A:  BRA    4B30
4B2C:  MOVLB  0
4B2E:  BRA    4AD6
.................... } 
4B30:  MOVLB  0
4B32:  RETURN 0
....................  
....................  
.................... /** 
....................  * This method was a try in order to make the robot rotate on itself the specified angle  
....................  * according to its speed. The problem is that the actual speed of the  
....................  * robot is not precise, so even if the calculation is right, it is impossible 
....................  * to really make it stop where we want. 
....................  */ 
.................... void rotate_no_move(unsigned int32 angle, int speed) 
.................... { 
....................    unsigned int speed_ms = get_speed_in_mms(speed); 
....................    fprintf(USB, "speed ms : %ud \r\n", speed_ms); 
....................    unsigned int32 ms = (unsigned int32) (PERIM * 1000 / speed_ms); 
....................    fprintf(USB, "ms : %Ld \r\n", ms); 
....................    KJunior_set_speed(speed, -speed); 
....................    sleep_ms(ms); 
....................    KJunior_set_speed(0, 0); 
....................     
.................... } 
....................  
.................... /** 
....................  * returns the speed in meter/milliseconds according to the  
....................  * formula found in the KJunior documentation. 
....................  */ 
.................... unsigned int get_speed_in_mms(int32 speed) 
.................... { 
....................    return (unsigned int)((speed * 70.0 / 20.0) + 30); 
.................... } 
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... // Melodies to be played on the buzzer and utilities to play notes 
.................... #include "simple_beep.h"  
.................... #ifndef SIMPLE_BEEP 
.................... #define SIMPLE_BEEP 1 
.................... // This library is useful to make some frickin' noise with the Robot! 
....................  
.................... // MUTE buzzer 
.................... #define MUTE      0 
....................  
.................... // Notes 
.................... // Please refer to K-Junior documentation for more information. 
.................... #define C_2       1 
.................... #define C_SHARP_2 2 
.................... #define D_FLAT_2  2 
.................... #define D_2       3 
.................... #define D_SHARP_2 4 
.................... #define E_FLAT_2  4 
.................... #define E_2       5 
.................... #define F_2       6 
.................... #define F_SHARP_2 7 
.................... #define G_FLAT_2  7 
.................... #define G_2       8 
.................... #define G_SHARP_2 9 
.................... #define A_FLAT_2  9 
.................... #define A_2       10 
.................... #define A_SHARP_2 11 
.................... #define B_FLAT_2  11 
.................... #define B_2       12 
....................  
.................... #define C_3       13 
.................... #define C_SHARP_3 14 
.................... #define D_FLAT_3  14 
.................... #define D_3       15 
.................... #define D_SHARP_3 16 
.................... #define E_FLAT_3  16 
.................... #define E_3       17 
.................... #define F_3       18 
.................... #define F_SHARP_3 19 
.................... #define G_FLAT_3  19 
.................... #define G_3       20 
.................... #define G_SHARP_3 21 
.................... #define A_FLAT_3  21 
.................... #define A_3       22 
.................... #define A_SHARP_3 23 
.................... #define B_FLAT_3  23 
.................... #define B_3       24 
....................  
.................... #define C_4       25 
.................... #define C_SHARP_4 26 
.................... #define D_FLAT_4  26 
.................... #define D_4       27 
.................... #define D_SHARP_4 28 
.................... #define E_FLAT_4  28 
.................... #define E_4       29 
.................... #define F_4       30 
.................... #define F_SHARP_4 31 
.................... #define G_FLAT_4  31 
.................... #define G_4       32 
.................... #define G_SHARP_4 33 
.................... #define A_FLAT_4  33 
.................... #define A_4       34 
.................... #define A_SHARP_4 35 
.................... #define B_FLAT_4  35 
.................... #define B_4       36 
....................  
.................... #define C_5       37 
.................... #define C_SHARP_5 38 
.................... #define D_FLAT_5  38 
.................... #define D_5       39 
.................... #define D_SHARP_5 40 
.................... #define E_FLAT_5  40 
.................... #define E_5       41 
.................... #define F_5       42 
.................... #define F_SHARP_5 43 
.................... #define G_FLAT_5  43 
.................... #define G_5       44 
.................... #define G_SHARP_5 45 
.................... #define A_FLAT_5  45 
.................... #define A_5       46 
.................... #define A_SHARP_5 47 
.................... #define B_FLAT_5  47 
.................... #define B_5       48 
....................  
....................  
.................... void incremental_beep(void); 
....................  
.................... float note_length_ms(int8 value, int8 tempo); 
....................  
.................... void beep_note(int8 note, int8 note_value, int8 tempo); 
....................  
.................... void beep_blues_scale(void); 
....................  
.................... void beep_star_wars(void); 
....................  
.................... void beep_badinerie(void); 
....................  
.................... #include "simple_beep.c" 
.................... /** 
....................  * @file 
....................  *  
....................  * @brief Utilities to play notes with the buzzer 
....................  */ 
....................  
.................... /** 
....................  * Go up the scale very quickly with the buzzer. 
....................  */ 
.................... void incremental_beep(void) 
.................... { 
....................    for(int8 i=0; i<=48; i++) 
....................    { 
....................       KJunior_beep(i); 
....................       KJunior_delay_ms(10); 
....................    } 
....................     
....................    // Stop buzzing 
....................    KJunior_beep(MUTE); 
.................... } 
....................  
.................... /** 
....................  * Returns the duration in ms of the specified note value depending on the tempo. 
....................  * 
....................  * @param value Note value. E.g. 1 for whole note, 2 for half note, 
....................  * 4 for quarter note, 8 for eighth note, 16 for sixteenth note, ... 
....................  * (and also 3 for a dotted quarter note for instance). 
....................  * @param tempo Tempo in beats per minute 
....................  * @return the duration in ms of the specified note value depending on the tempo.  
....................  */ 
.................... float note_length_ms(int8 value, int8 tempo) 
.................... { 
*
5B6E:  BCF    FD8.1
5B70:  MOVLB  1
5B72:  CLRF   xB4
5B74:  MOVLW  03
5B76:  MOVWF  xB3
5B78:  MOVLW  A9
5B7A:  MOVWF  xB2
5B7C:  MOVLW  80
5B7E:  MOVWF  xB1
5B80:  CLRF   xB8
5B82:  CLRF   xB7
5B84:  CLRF   xB6
5B86:  MOVFF  19F,1B5
5B8A:  MOVLB  0
5B8C:  CALL   2620
5B90:  MOVFF  03,1A7
5B94:  MOVFF  02,1A6
5B98:  MOVFF  01,1A5
5B9C:  MOVFF  00,1A4
5BA0:  BCF    FD8.1
5BA2:  MOVFF  03,1B4
5BA6:  MOVFF  02,1B3
5BAA:  MOVFF  01,1B2
5BAE:  MOVFF  00,1B1
5BB2:  MOVLB  1
5BB4:  CLRF   xB8
5BB6:  CLRF   xB7
5BB8:  CLRF   xB6
5BBA:  MOVFF  19E,1B5
5BBE:  MOVLB  0
5BC0:  CALL   2620
5BC4:  MOVFF  03,1A7
5BC8:  MOVFF  02,1A6
5BCC:  MOVFF  01,1A5
5BD0:  MOVFF  00,1A4
5BD4:  BRA    5856
5BD6:  MOVFF  03,1A3
5BDA:  MOVFF  02,1A2
5BDE:  MOVFF  01,1A1
5BE2:  MOVFF  00,1A0
....................    // We know the tempo means : how many quarters note are they in one minute? 
....................    // E.g. at 60 bpm, one quarter note has a duration of 1 second. 
....................    // at 120 bpm, one quarter note has a duration of 0.5 second 
....................     
....................    // The formula is: (60 / tempo) * 4 * (1/value) [seconds] 
....................    // As we want the answer in miliseconds, we multiply by 1000. 
....................    float length = 240000 / tempo / value; 
....................    fprintf(USB, "Value: 1/%d at %d bpm is %f\r\n", value, tempo, length); 
5BE6:  MOVLW  D4
5BE8:  MOVWF  FF6
5BEA:  MOVLW  13
5BEC:  MOVWF  FF7
5BEE:  MOVLW  09
5BF0:  MOVLB  1
5BF2:  MOVWF  xA4
5BF4:  MOVLB  0
5BF6:  CALL   143E
5BFA:  MOVFF  19E,1A4
5BFE:  MOVLW  18
5C00:  MOVLB  1
5C02:  MOVWF  xA5
5C04:  MOVLB  0
5C06:  CALL   23F4
5C0A:  MOVLW  DF
5C0C:  MOVWF  FF6
5C0E:  MOVLW  13
5C10:  MOVWF  FF7
5C12:  MOVLW  04
5C14:  MOVLB  1
5C16:  MOVWF  xA4
5C18:  MOVLB  0
5C1A:  CALL   143E
5C1E:  MOVFF  19F,1A4
5C22:  MOVLW  18
5C24:  MOVLB  1
5C26:  MOVWF  xA5
5C28:  MOVLB  0
5C2A:  CALL   23F4
5C2E:  MOVLW  E5
5C30:  MOVWF  FF6
5C32:  MOVLW  13
5C34:  MOVWF  FF7
5C36:  MOVLW  08
5C38:  MOVLB  1
5C3A:  MOVWF  xA4
5C3C:  MOVLB  0
5C3E:  CALL   143E
5C42:  MOVLW  89
5C44:  MOVWF  FE9
5C46:  MOVFF  1A3,1A7
5C4A:  MOVFF  1A2,1A6
5C4E:  MOVFF  1A1,1A5
5C52:  MOVFF  1A0,1A4
5C56:  MOVLW  02
5C58:  MOVLB  1
5C5A:  MOVWF  xA8
5C5C:  MOVLB  0
5C5E:  BRA    59CA
5C60:  MOVLW  0D
5C62:  BTFSS  F9E.4
5C64:  BRA    5C62
5C66:  MOVWF  FAD
5C68:  MOVLW  0A
5C6A:  BTFSS  F9E.4
5C6C:  BRA    5C6A
5C6E:  MOVWF  FAD
....................    return length; 
5C70:  MOVFF  1A0,00
5C74:  MOVFF  1A1,01
5C78:  MOVFF  1A2,02
5C7C:  MOVFF  1A3,03
.................... } 
5C80:  GOTO   5D12 (RETURN)
....................  
.................... // Last number shown with leds (see binary led transcoder.c) 
.................... int8 bp_last_led = 0; 
....................  
.................... /** 
....................  * Toggle leds to give visual feedback of the playing tune. 
....................  */ 
.................... void toggle_led(void) 
.................... { 
....................    // This function has to be lightning FAST! 
....................  
....................    if(bp_last_led >= 0 && bp_last_led < 3) 
5C84:  MOVLB  1
5C86:  MOVF   x91,W
5C88:  SUBLW  02
5C8A:  BNC   5C90
....................    { 
....................       bp_last_led++; 
5C8C:  INCF   x91,F
....................    } 
....................    else 
5C8E:  BRA    5C92
....................    { 
....................       bp_last_led = 0; 
5C90:  CLRF   x91
....................    } 
....................     
....................    if(bp_last_led == 0) { 
5C92:  MOVF   x91,F
5C94:  BNZ   5CAE
....................       KJunior_led_left(1); 
5C96:  MOVLW  01
5C98:  MOVWF  xD9
5C9A:  MOVLB  0
5C9C:  CALL   1A3E
....................       KJunior_led_right(0); 
5CA0:  MOVLB  1
5CA2:  CLRF   xD7
5CA4:  MOVLB  0
5CA6:  CALL   1A6E
....................    } else if (bp_last_led == 1) { 
5CAA:  BRA    5CFC
5CAC:  MOVLB  1
5CAE:  DECFSZ x91,W
5CB0:  BRA    5CCA
....................       KJunior_led_left(0); 
5CB2:  CLRF   xD9
5CB4:  MOVLB  0
5CB6:  CALL   1A3E
....................       KJunior_led_frontleft(1); 
5CBA:  MOVLW  01
5CBC:  MOVLB  1
5CBE:  MOVWF  xD7
5CC0:  MOVLB  0
5CC2:  CALL   1A4E
....................    } else if (bp_last_led == 2) { 
5CC6:  BRA    5CFC
5CC8:  MOVLB  1
5CCA:  MOVF   x91,W
5CCC:  SUBLW  02
5CCE:  BNZ   5CE8
....................       KJunior_led_frontleft(0); 
5CD0:  CLRF   xD7
5CD2:  MOVLB  0
5CD4:  CALL   1A4E
....................       KJunior_led_frontright(1); 
5CD8:  MOVLW  01
5CDA:  MOVLB  1
5CDC:  MOVWF  xD7
5CDE:  MOVLB  0
5CE0:  CALL   1A5E
....................    } else { 
5CE4:  BRA    5CFC
5CE6:  MOVLB  1
....................       KJunior_led_frontright(0); 
5CE8:  CLRF   xD7
5CEA:  MOVLB  0
5CEC:  CALL   1A5E
....................       KJunior_led_right(1); 
5CF0:  MOVLW  01
5CF2:  MOVLB  1
5CF4:  MOVWF  xD7
5CF6:  MOVLB  0
5CF8:  CALL   1A6E
....................    } 
.................... } 
5CFC:  GOTO   5D24 (RETURN)
....................  
.................... /** 
....................  * Beep a note. 
....................  *  
....................  * @param note the note to play (see simple_beep.h constants) 
....................  * @param note_value the note value (e.g. 4 for a quarter note, 1 for a whole note) 
....................  * @param tempo the tempo 
....................  */ 
.................... void beep_note(int8 note, int8 note_value, int8 tempo) 
.................... { 
....................    KJunior_beep(note); 
5D00:  MOVFF  197,1A2
5D04:  CALL   4E16
....................    float total_length = note_length_ms(note_value, tempo); 
5D08:  MOVFF  198,19E
5D0C:  MOVFF  199,19F
5D10:  BRA    5B6E
5D12:  MOVFF  03,19D
5D16:  MOVFF  02,19C
5D1A:  MOVFF  01,19B
5D1E:  MOVFF  00,19A
....................    toggle_led(); 
5D22:  BRA    5C84
....................    sleep_ms(total_length); 
5D24:  MOVFF  19D,1B4
5D28:  MOVFF  19C,1B3
5D2C:  MOVFF  19B,1B2
5D30:  MOVFF  19A,1B1
5D34:  RCALL  5988
5D36:  MOVFF  03,1A1
5D3A:  MOVFF  02,1A0
5D3E:  MOVFF  01,19F
5D42:  MOVFF  00,19E
5D46:  MOVFF  03,1A5
5D4A:  MOVFF  02,1A4
5D4E:  MOVFF  01,1A3
5D52:  MOVFF  00,1A2
5D56:  CALL   4AC4
....................    KJunior_beep(MUTE); 
5D5A:  MOVLB  1
5D5C:  CLRF   xA2
5D5E:  MOVLB  0
5D60:  CALL   4E16
....................    // note spacing by muting in-between 
....................    sleep_ms(10); 
5D64:  MOVLB  1
5D66:  CLRF   xA5
5D68:  CLRF   xA4
5D6A:  CLRF   xA3
5D6C:  MOVLW  0A
5D6E:  MOVWF  xA2
5D70:  MOVLB  0
5D72:  CALL   4AC4
.................... } 
5D76:  RETURN 0
....................  
.................... /** 
....................  * Play the Blues scale (C - Eb - F - F# - G - Bb - C) 
....................  */ 
.................... void beep_blues_scale(void) 
.................... { 
....................    int8 tempo = 120; 
....................    int8 note_value = 4; 
....................    
....................    beep_note(C_2, note_value, tempo); 
....................    beep_note(E_FLAT_2, note_value, tempo); 
....................    beep_note(F_2, note_value, tempo); 
....................    beep_note(F_SHARP_2, note_value, tempo); 
....................    beep_note(G_2, note_value, tempo); 
....................    beep_note(B_FLAT_2, note_value, tempo); 
....................    beep_note(C_3, note_value, tempo); 
.................... } 
....................  
.................... /** 
....................  * Play Star wars tune 
....................  */ 
.................... void beep_star_wars(void) 
.................... { 
....................    int8 tempo = 100; 
....................     
....................    int8 triolet= 14; 
....................     
....................    // Intro 
....................    beep_note(D_2, triolet, tempo); 
....................    beep_note(D_2, triolet, tempo); 
....................    beep_note(D_2, triolet, tempo); 
....................     
....................    // Theme 
....................    beep_note(G_2, 2, tempo); 
....................    beep_note(D_3, 2, tempo); 
....................     
....................    beep_note(C_3, triolet, tempo); 
....................    beep_note(B_2, triolet, tempo); 
....................    beep_note(A_2, triolet, tempo); 
....................     
....................    beep_note(G_3, 2, tempo), 
....................    beep_note(D_3, 4, tempo); 
....................     
....................    beep_note(C_3, triolet, tempo); 
....................    beep_note(B_2, triolet, tempo); 
....................    beep_note(A_2, triolet, tempo); 
....................     
....................    beep_note(G_3, 2, tempo), 
....................    beep_note(D_3, 4, tempo); 
....................     
....................    beep_note(C_3, triolet, tempo); 
....................    beep_note(B_2, triolet, tempo); 
....................    beep_note(C_3, triolet, tempo); 
....................     
....................    beep_note(A_2, 2, tempo); 
....................     
....................    beep_note(D_2, 6, tempo); 
....................    beep_note(D_2, 16, tempo); 
....................     
....................     
....................    // Theme again 
....................    beep_note(G_2, 2, tempo); 
....................    beep_note(D_3, 2, tempo); 
....................     
....................    beep_note(C_3, triolet, tempo); 
....................    beep_note(B_2, triolet, tempo); 
....................    beep_note(A_2, triolet, tempo); 
....................     
....................    beep_note(G_3, 2, tempo), 
....................    beep_note(D_3, 4, tempo); 
....................     
....................    beep_note(C_3, triolet, tempo); 
....................    beep_note(B_2, triolet, tempo); 
....................    beep_note(A_2, triolet, tempo); 
....................     
....................    beep_note(G_3, 2, tempo), 
....................    beep_note(D_3, 4, tempo); 
....................     
....................    beep_note(C_3, triolet, tempo); 
....................    beep_note(B_2, triolet, tempo); 
....................    beep_note(C_3, triolet, tempo); 
....................     
....................    beep_note(A_2, 2, tempo); 
....................    beep_note(MUTE, 4, tempo); 
....................     
....................    beep_note(D_2, 6, tempo); 
....................    beep_note(D_2, 16, tempo); 
....................     
....................    // Secundo 
....................    beep_note(E_2, 3, tempo); 
....................    beep_note(E_2, 8, tempo); 
....................    beep_note(C_3, 8, tempo); 
....................    beep_note(B_2, 8, tempo); 
....................    beep_note(A_2, 8, tempo); 
....................    beep_note(G_2, 8, tempo); 
....................     
....................    beep_note(G_2, triolet, tempo); 
....................    beep_note(A_2, triolet, tempo); 
....................    beep_note(B_2, triolet, tempo); 
....................    beep_note(A_2, 6, tempo); 
....................    beep_note(E_2, 16, tempo); 
....................    beep_note(F_SHARP_2, 4, tempo); 
....................     
....................    beep_note(D_2, 6, tempo); 
....................    beep_note(D_2, 16, tempo);  
....................     
....................    beep_note(E_2, 3, tempo); 
....................    beep_note(E_2, 8, tempo); 
....................    beep_note(C_3, 8, tempo); 
....................    beep_note(B_2, 8, tempo); 
....................    beep_note(A_2, 8, tempo); 
....................    beep_note(G_2, 8, tempo); 
....................     
....................    beep_note(D_3, 3, tempo); 
....................    beep_note(A_2, 16, tempo); 
....................    beep_note(A_2, 2, tempo); 
....................     
....................    beep_note(MUTE, 4, tempo); 
....................    beep_note(G_2, 4, tempo); 
....................    beep_note(B_2, 4, tempo); 
....................    beep_note(D_2, 4, tempo); 
....................    beep_note(G_3, 8, tempo); 
....................    beep_note(G_3, 8, tempo); 
.................... } 
....................  
.................... /** 
....................  * Play Bach Badinerie (BWV1067) 
....................  */ 
.................... void beep_badinerie(void) 
.................... { 
5D78:  MOVLW  82
5D7A:  MOVLB  1
5D7C:  MOVWF  x94
....................  
.................... int8 tempo = 130; 
....................  
.................... // Pause 2 seconds 
.................... sleep_ms(2000); 
5D7E:  CLRF   xA5
5D80:  CLRF   xA4
5D82:  MOVLW  07
5D84:  MOVWF  xA3
5D86:  MOVLW  D0
5D88:  MOVWF  xA2
5D8A:  MOVLB  0
5D8C:  CALL   4AC4
....................  
.................... // Repeat two times 
.................... for(int i=0; i<2; i++) 
5D90:  MOVLB  1
5D92:  CLRF   x95
5D94:  MOVF   x95,W
5D96:  SUBLW  01
5D98:  BTFSS  FD8.0
5D9A:  GOTO   64CE
.................... { 
.................... beep_note(B_3, 8, tempo); 
5D9E:  MOVLW  18
5DA0:  MOVWF  x97
5DA2:  MOVLW  08
5DA4:  MOVWF  x98
5DA6:  MOVFF  194,199
5DAA:  MOVLB  0
5DAC:  RCALL  5D00
.................... beep_note(D_4, 16, tempo); 
5DAE:  MOVLW  1B
5DB0:  MOVLB  1
5DB2:  MOVWF  x97
5DB4:  MOVLW  10
5DB6:  MOVWF  x98
5DB8:  MOVFF  194,199
5DBC:  MOVLB  0
5DBE:  RCALL  5D00
.................... beep_note(B_3, 16, tempo); 
5DC0:  MOVLW  18
5DC2:  MOVLB  1
5DC4:  MOVWF  x97
5DC6:  MOVLW  10
5DC8:  MOVWF  x98
5DCA:  MOVFF  194,199
5DCE:  MOVLB  0
5DD0:  RCALL  5D00
.................... beep_note(F_SHARP_3, 8, tempo); 
5DD2:  MOVLW  13
5DD4:  MOVLB  1
5DD6:  MOVWF  x97
5DD8:  MOVLW  08
5DDA:  MOVWF  x98
5DDC:  MOVFF  194,199
5DE0:  MOVLB  0
5DE2:  RCALL  5D00
.................... beep_note(B_3, 16, tempo); 
5DE4:  MOVLW  18
5DE6:  MOVLB  1
5DE8:  MOVWF  x97
5DEA:  MOVLW  10
5DEC:  MOVWF  x98
5DEE:  MOVFF  194,199
5DF2:  MOVLB  0
5DF4:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
5DF6:  MOVLW  13
5DF8:  MOVLB  1
5DFA:  MOVWF  x97
5DFC:  MOVLW  10
5DFE:  MOVWF  x98
5E00:  MOVFF  194,199
5E04:  MOVLB  0
5E06:  RCALL  5D00
.................... beep_note(D_3, 8, tempo); 
5E08:  MOVLW  0F
5E0A:  MOVLB  1
5E0C:  MOVWF  x97
5E0E:  MOVLW  08
5E10:  MOVWF  x98
5E12:  MOVFF  194,199
5E16:  MOVLB  0
5E18:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
5E1A:  MOVLW  13
5E1C:  MOVLB  1
5E1E:  MOVWF  x97
5E20:  MOVLW  10
5E22:  MOVWF  x98
5E24:  MOVFF  194,199
5E28:  MOVLB  0
5E2A:  RCALL  5D00
.................... beep_note(D_3, 16, tempo); 
5E2C:  MOVLW  0F
5E2E:  MOVLB  1
5E30:  MOVWF  x97
5E32:  MOVLW  10
5E34:  MOVWF  x98
5E36:  MOVFF  194,199
5E3A:  MOVLB  0
5E3C:  RCALL  5D00
.................... beep_note(B_2, 4, tempo); 
5E3E:  MOVLW  0C
5E40:  MOVLB  1
5E42:  MOVWF  x97
5E44:  MOVLW  04
5E46:  MOVWF  x98
5E48:  MOVFF  194,199
5E4C:  MOVLB  0
5E4E:  RCALL  5D00
....................  
.................... beep_note(F_SHARP_2, 16, tempo); 
5E50:  MOVLW  07
5E52:  MOVLB  1
5E54:  MOVWF  x97
5E56:  MOVLW  10
5E58:  MOVWF  x98
5E5A:  MOVFF  194,199
5E5E:  MOVLB  0
5E60:  RCALL  5D00
.................... beep_note(B_2, 16, tempo); 
5E62:  MOVLW  0C
5E64:  MOVLB  1
5E66:  MOVWF  x97
5E68:  MOVLW  10
5E6A:  MOVWF  x98
5E6C:  MOVFF  194,199
5E70:  MOVLB  0
5E72:  RCALL  5D00
.................... beep_note(D_3, 16, tempo); 
5E74:  MOVLW  0F
5E76:  MOVLB  1
5E78:  MOVWF  x97
5E7A:  MOVLW  10
5E7C:  MOVWF  x98
5E7E:  MOVFF  194,199
5E82:  MOVLB  0
5E84:  RCALL  5D00
.................... beep_note(B_2, 16, tempo); 
5E86:  MOVLW  0C
5E88:  MOVLB  1
5E8A:  MOVWF  x97
5E8C:  MOVLW  10
5E8E:  MOVWF  x98
5E90:  MOVFF  194,199
5E94:  MOVLB  0
5E96:  RCALL  5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
5E98:  MOVLW  0E
5E9A:  MOVLB  1
5E9C:  MOVWF  x97
5E9E:  MOVLW  10
5EA0:  MOVWF  x98
5EA2:  MOVFF  194,199
5EA6:  MOVLB  0
5EA8:  RCALL  5D00
.................... beep_note(B_2, 16, tempo); 
5EAA:  MOVLW  0C
5EAC:  MOVLB  1
5EAE:  MOVWF  x97
5EB0:  MOVLW  10
5EB2:  MOVWF  x98
5EB4:  MOVFF  194,199
5EB8:  MOVLB  0
5EBA:  RCALL  5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
5EBC:  MOVLW  0E
5EBE:  MOVLB  1
5EC0:  MOVWF  x97
5EC2:  MOVLW  10
5EC4:  MOVWF  x98
5EC6:  MOVFF  194,199
5ECA:  MOVLB  0
5ECC:  RCALL  5D00
.................... beep_note(B_2, 16, tempo); 
5ECE:  MOVLW  0C
5ED0:  MOVLB  1
5ED2:  MOVWF  x97
5ED4:  MOVLW  10
5ED6:  MOVWF  x98
5ED8:  MOVFF  194,199
5EDC:  MOVLB  0
5EDE:  RCALL  5D00
.................... beep_note(A_SHARP_2, 16, tempo); 
5EE0:  MOVLW  0B
5EE2:  MOVLB  1
5EE4:  MOVWF  x97
5EE6:  MOVLW  10
5EE8:  MOVWF  x98
5EEA:  MOVFF  194,199
5EEE:  MOVLB  0
5EF0:  RCALL  5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
5EF2:  MOVLW  0E
5EF4:  MOVLB  1
5EF6:  MOVWF  x97
5EF8:  MOVLW  10
5EFA:  MOVWF  x98
5EFC:  MOVFF  194,199
5F00:  MOVLB  0
5F02:  RCALL  5D00
.................... beep_note(E_3, 16, tempo); 
5F04:  MOVLW  11
5F06:  MOVLB  1
5F08:  MOVWF  x97
5F0A:  MOVLW  10
5F0C:  MOVWF  x98
5F0E:  MOVFF  194,199
5F12:  MOVLB  0
5F14:  RCALL  5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
5F16:  MOVLW  0E
5F18:  MOVLB  1
5F1A:  MOVWF  x97
5F1C:  MOVLW  10
5F1E:  MOVWF  x98
5F20:  MOVFF  194,199
5F24:  MOVLB  0
5F26:  RCALL  5D00
.................... beep_note(D_3, 8, tempo); 
5F28:  MOVLW  0F
5F2A:  MOVLB  1
5F2C:  MOVWF  x97
5F2E:  MOVLW  08
5F30:  MOVWF  x98
5F32:  MOVFF  194,199
5F36:  MOVLB  0
5F38:  RCALL  5D00
.................... beep_note(B_2, 8, tempo); 
5F3A:  MOVLW  0C
5F3C:  MOVLB  1
5F3E:  MOVWF  x97
5F40:  MOVLW  08
5F42:  MOVWF  x98
5F44:  MOVFF  194,199
5F48:  MOVLB  0
5F4A:  RCALL  5D00
....................  
.................... // very first section again 
.................... beep_note(B_3, 8, tempo); 
5F4C:  MOVLW  18
5F4E:  MOVLB  1
5F50:  MOVWF  x97
5F52:  MOVLW  08
5F54:  MOVWF  x98
5F56:  MOVFF  194,199
5F5A:  MOVLB  0
5F5C:  RCALL  5D00
.................... beep_note(D_4, 16, tempo);                                                                            
5F5E:  MOVLW  1B
5F60:  MOVLB  1
5F62:  MOVWF  x97
5F64:  MOVLW  10
5F66:  MOVWF  x98
5F68:  MOVFF  194,199
5F6C:  MOVLB  0
5F6E:  RCALL  5D00
.................... beep_note(B_3, 16, tempo);                                                                            
5F70:  MOVLW  18
5F72:  MOVLB  1
5F74:  MOVWF  x97
5F76:  MOVLW  10
5F78:  MOVWF  x98
5F7A:  MOVFF  194,199
5F7E:  MOVLB  0
5F80:  RCALL  5D00
.................... beep_note(F_SHARP_3, 8, tempo);                                                                       
5F82:  MOVLW  13
5F84:  MOVLB  1
5F86:  MOVWF  x97
5F88:  MOVLW  08
5F8A:  MOVWF  x98
5F8C:  MOVFF  194,199
5F90:  MOVLB  0
5F92:  RCALL  5D00
.................... beep_note(B_3, 16, tempo);                                                                            
5F94:  MOVLW  18
5F96:  MOVLB  1
5F98:  MOVWF  x97
5F9A:  MOVLW  10
5F9C:  MOVWF  x98
5F9E:  MOVFF  194,199
5FA2:  MOVLB  0
5FA4:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo);                                                                      
5FA6:  MOVLW  13
5FA8:  MOVLB  1
5FAA:  MOVWF  x97
5FAC:  MOVLW  10
5FAE:  MOVWF  x98
5FB0:  MOVFF  194,199
5FB4:  MOVLB  0
5FB6:  RCALL  5D00
.................... beep_note(D_3, 8, tempo); 
5FB8:  MOVLW  0F
5FBA:  MOVLB  1
5FBC:  MOVWF  x97
5FBE:  MOVLW  08
5FC0:  MOVWF  x98
5FC2:  MOVFF  194,199
5FC6:  MOVLB  0
5FC8:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
5FCA:  MOVLW  13
5FCC:  MOVLB  1
5FCE:  MOVWF  x97
5FD0:  MOVLW  10
5FD2:  MOVWF  x98
5FD4:  MOVFF  194,199
5FD8:  MOVLB  0
5FDA:  RCALL  5D00
.................... beep_note(D_3, 16, tempo); 
5FDC:  MOVLW  0F
5FDE:  MOVLB  1
5FE0:  MOVWF  x97
5FE2:  MOVLW  10
5FE4:  MOVWF  x98
5FE6:  MOVFF  194,199
5FEA:  MOVLB  0
5FEC:  RCALL  5D00
.................... beep_note(B_2, 4, tempo); 
5FEE:  MOVLW  0C
5FF0:  MOVLB  1
5FF2:  MOVWF  x97
5FF4:  MOVLW  04
5FF6:  MOVWF  x98
5FF8:  MOVFF  194,199
5FFC:  MOVLB  0
5FFE:  RCALL  5D00
....................  
.................... beep_note(D_3, 8, tempo); 
6000:  MOVLW  0F
6002:  MOVLB  1
6004:  MOVWF  x97
6006:  MOVLW  08
6008:  MOVWF  x98
600A:  MOVFF  194,199
600E:  MOVLB  0
6010:  RCALL  5D00
.................... beep_note(D_3, 8, tempo); 
6012:  MOVLW  0F
6014:  MOVLB  1
6016:  MOVWF  x97
6018:  MOVLW  08
601A:  MOVWF  x98
601C:  MOVFF  194,199
6020:  MOVLB  0
6022:  RCALL  5D00
.................... beep_note(D_3, 8, tempo); // 2nd row 
6024:  MOVLW  0F
6026:  MOVLB  1
6028:  MOVWF  x97
602A:  MOVLW  08
602C:  MOVWF  x98
602E:  MOVFF  194,199
6032:  MOVLB  0
6034:  RCALL  5D00
.................... beep_note(D_3, 8, tempo); 
6036:  MOVLW  0F
6038:  MOVLB  1
603A:  MOVWF  x97
603C:  MOVLW  08
603E:  MOVWF  x98
6040:  MOVFF  194,199
6044:  MOVLB  0
6046:  RCALL  5D00
.................... beep_note(B_3, 8, tempo); 
6048:  MOVLW  18
604A:  MOVLB  1
604C:  MOVWF  x97
604E:  MOVLW  08
6050:  MOVWF  x98
6052:  MOVFF  194,199
6056:  MOVLB  0
6058:  RCALL  5D00
.................... beep_note(D_3, 8, tempo); 
605A:  MOVLW  0F
605C:  MOVLB  1
605E:  MOVWF  x97
6060:  MOVLW  08
6062:  MOVWF  x98
6064:  MOVFF  194,199
6068:  MOVLB  0
606A:  RCALL  5D00
.................... // trille 
.................... beep_note(D_3, 32, tempo); 
606C:  MOVLW  0F
606E:  MOVLB  1
6070:  MOVWF  x97
6072:  MOVLW  20
6074:  MOVWF  x98
6076:  MOVFF  194,199
607A:  MOVLB  0
607C:  RCALL  5D00
.................... beep_note(E_3, 32, tempo); 
607E:  MOVLW  11
6080:  MOVLB  1
6082:  MOVWF  x97
6084:  MOVLW  20
6086:  MOVWF  x98
6088:  MOVFF  194,199
608C:  MOVLB  0
608E:  RCALL  5D00
.................... beep_note(D_3, 32, tempo); 
6090:  MOVLW  0F
6092:  MOVLB  1
6094:  MOVWF  x97
6096:  MOVLW  20
6098:  MOVWF  x98
609A:  MOVFF  194,199
609E:  MOVLB  0
60A0:  RCALL  5D00
.................... beep_note(E_3, 32, tempo); 
60A2:  MOVLW  11
60A4:  MOVLB  1
60A6:  MOVWF  x97
60A8:  MOVLW  20
60AA:  MOVWF  x98
60AC:  MOVFF  194,199
60B0:  MOVLB  0
60B2:  RCALL  5D00
.................... beep_note(C_SHARP_3, 8, tempo); 
60B4:  MOVLW  0E
60B6:  MOVLB  1
60B8:  MOVWF  x97
60BA:  MOVLW  08
60BC:  MOVWF  x98
60BE:  MOVFF  194,199
60C2:  MOVLB  0
60C4:  RCALL  5D00
....................  
.................... beep_note(F_SHARP_3, 8, tempo); 
60C6:  MOVLW  13
60C8:  MOVLB  1
60CA:  MOVWF  x97
60CC:  MOVLW  08
60CE:  MOVWF  x98
60D0:  MOVFF  194,199
60D4:  MOVLB  0
60D6:  RCALL  5D00
.................... beep_note(F_SHARP_3, 8, tempo); 
60D8:  MOVLW  13
60DA:  MOVLB  1
60DC:  MOVWF  x97
60DE:  MOVLW  08
60E0:  MOVWF  x98
60E2:  MOVFF  194,199
60E6:  MOVLB  0
60E8:  RCALL  5D00
.................... beep_note(F_SHARP_3, 8, tempo); 
60EA:  MOVLW  13
60EC:  MOVLB  1
60EE:  MOVWF  x97
60F0:  MOVLW  08
60F2:  MOVWF  x98
60F4:  MOVFF  194,199
60F8:  MOVLB  0
60FA:  RCALL  5D00
.................... beep_note(F_SHARP_3, 8, tempo); 
60FC:  MOVLW  13
60FE:  MOVLB  1
6100:  MOVWF  x97
6102:  MOVLW  08
6104:  MOVWF  x98
6106:  MOVFF  194,199
610A:  MOVLB  0
610C:  RCALL  5D00
.................... beep_note(D_4, 8, tempo); 
610E:  MOVLW  1B
6110:  MOVLB  1
6112:  MOVWF  x97
6114:  MOVLW  08
6116:  MOVWF  x98
6118:  MOVFF  194,199
611C:  MOVLB  0
611E:  RCALL  5D00
.................... beep_note(F_SHARP_3, 8, tempo); 
6120:  MOVLW  13
6122:  MOVLB  1
6124:  MOVWF  x97
6126:  MOVLW  08
6128:  MOVWF  x98
612A:  MOVFF  194,199
612E:  MOVLB  0
6130:  RCALL  5D00
.................... // trille 
.................... beep_note(F_SHARP_3, 32, tempo); 
6132:  MOVLW  13
6134:  MOVLB  1
6136:  MOVWF  x97
6138:  MOVLW  20
613A:  MOVWF  x98
613C:  MOVFF  194,199
6140:  MOVLB  0
6142:  RCALL  5D00
.................... beep_note(G_SHARP_3, 32, tempo); 
6144:  MOVLW  15
6146:  MOVLB  1
6148:  MOVWF  x97
614A:  MOVLW  20
614C:  MOVWF  x98
614E:  MOVFF  194,199
6152:  MOVLB  0
6154:  RCALL  5D00
.................... beep_note(F_SHARP_3, 32, tempo); 
6156:  MOVLW  13
6158:  MOVLB  1
615A:  MOVWF  x97
615C:  MOVLW  20
615E:  MOVWF  x98
6160:  MOVFF  194,199
6164:  MOVLB  0
6166:  RCALL  5D00
.................... beep_note(G_SHARP_3, 32, tempo); 
6168:  MOVLW  15
616A:  MOVLB  1
616C:  MOVWF  x97
616E:  MOVLW  20
6170:  MOVWF  x98
6172:  MOVFF  194,199
6176:  MOVLB  0
6178:  RCALL  5D00
.................... beep_note(F_3, 8, tempo); // E# 
617A:  MOVLW  12
617C:  MOVLB  1
617E:  MOVWF  x97
6180:  MOVLW  08
6182:  MOVWF  x98
6184:  MOVFF  194,199
6188:  MOVLB  0
618A:  RCALL  5D00
....................  
.................... beep_note(C_SHARP_3, 16, tempo); 
618C:  MOVLW  0E
618E:  MOVLB  1
6190:  MOVWF  x97
6192:  MOVLW  10
6194:  MOVWF  x98
6196:  MOVFF  194,199
619A:  MOVLB  0
619C:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
619E:  MOVLW  13
61A0:  MOVLB  1
61A2:  MOVWF  x97
61A4:  MOVLW  10
61A6:  MOVWF  x98
61A8:  MOVFF  194,199
61AC:  MOVLB  0
61AE:  RCALL  5D00
.................... beep_note(A_3, 16, tempo); 
61B0:  MOVLW  16
61B2:  MOVLB  1
61B4:  MOVWF  x97
61B6:  MOVLW  10
61B8:  MOVWF  x98
61BA:  MOVFF  194,199
61BE:  MOVLB  0
61C0:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
61C2:  MOVLW  13
61C4:  MOVLB  1
61C6:  MOVWF  x97
61C8:  MOVLW  10
61CA:  MOVWF  x98
61CC:  MOVFF  194,199
61D0:  MOVLB  0
61D2:  RCALL  5D00
.................... beep_note(G_SHARP_3, 16, tempo); 
61D4:  MOVLW  15
61D6:  MOVLB  1
61D8:  MOVWF  x97
61DA:  MOVLW  10
61DC:  MOVWF  x98
61DE:  MOVFF  194,199
61E2:  MOVLB  0
61E4:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
61E6:  MOVLW  13
61E8:  MOVLB  1
61EA:  MOVWF  x97
61EC:  MOVLW  10
61EE:  MOVWF  x98
61F0:  MOVFF  194,199
61F4:  MOVLB  0
61F6:  RCALL  5D00
.................... beep_note(G_SHARP_3, 16, tempo); 
61F8:  MOVLW  15
61FA:  MOVLB  1
61FC:  MOVWF  x97
61FE:  MOVLW  10
6200:  MOVWF  x98
6202:  MOVFF  194,199
6206:  MOVLB  0
6208:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
620A:  MOVLW  13
620C:  MOVLB  1
620E:  MOVWF  x97
6210:  MOVLW  10
6212:  MOVWF  x98
6214:  MOVFF  194,199
6218:  MOVLB  0
621A:  RCALL  5D00
.................... beep_note(F_3, 16, tempo); // E# 
621C:  MOVLW  12
621E:  MOVLB  1
6220:  MOVWF  x97
6222:  MOVLW  10
6224:  MOVWF  x98
6226:  MOVFF  194,199
622A:  MOVLB  0
622C:  RCALL  5D00
.................... beep_note(G_SHARP_3, 16, tempo); 
622E:  MOVLW  15
6230:  MOVLB  1
6232:  MOVWF  x97
6234:  MOVLW  10
6236:  MOVWF  x98
6238:  MOVFF  194,199
623C:  MOVLB  0
623E:  RCALL  5D00
.................... beep_note(B_3, 16, tempo); 
6240:  MOVLW  18
6242:  MOVLB  1
6244:  MOVWF  x97
6246:  MOVLW  10
6248:  MOVWF  x98
624A:  MOVFF  194,199
624E:  MOVLB  0
6250:  RCALL  5D00
.................... beep_note(G_SHARP_3, 16, tempo); 
6252:  MOVLW  15
6254:  MOVLB  1
6256:  MOVWF  x97
6258:  MOVLW  10
625A:  MOVWF  x98
625C:  MOVFF  194,199
6260:  MOVLB  0
6262:  RCALL  5D00
....................  
.................... beep_note(A_3, 16, tempo); 
6264:  MOVLW  16
6266:  MOVLB  1
6268:  MOVWF  x97
626A:  MOVLW  10
626C:  MOVWF  x98
626E:  MOVFF  194,199
6272:  MOVLB  0
6274:  RCALL  5D00
.................... beep_note(G_SHARP_3, 16, tempo); 
6276:  MOVLW  15
6278:  MOVLB  1
627A:  MOVWF  x97
627C:  MOVLW  10
627E:  MOVWF  x98
6280:  MOVFF  194,199
6284:  MOVLB  0
6286:  RCALL  5D00
.................... beep_note(A_3, 16, tempo); 
6288:  MOVLW  16
628A:  MOVLB  1
628C:  MOVWF  x97
628E:  MOVLW  10
6290:  MOVWF  x98
6292:  MOVFF  194,199
6296:  MOVLB  0
6298:  RCALL  5D00
.................... beep_note(G_SHARP_3, 16, tempo); 
629A:  MOVLW  15
629C:  MOVLB  1
629E:  MOVWF  x97
62A0:  MOVLW  10
62A2:  MOVWF  x98
62A4:  MOVFF  194,199
62A8:  MOVLB  0
62AA:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
62AC:  MOVLW  13
62AE:  MOVLB  1
62B0:  MOVWF  x97
62B2:  MOVLW  10
62B4:  MOVWF  x98
62B6:  MOVFF  194,199
62BA:  MOVLB  0
62BC:  RCALL  5D00
.................... beep_note(A_3, 16, tempo); 
62BE:  MOVLW  16
62C0:  MOVLB  1
62C2:  MOVWF  x97
62C4:  MOVLW  10
62C6:  MOVWF  x98
62C8:  MOVFF  194,199
62CC:  MOVLB  0
62CE:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
62D0:  MOVLW  13
62D2:  MOVLB  1
62D4:  MOVWF  x97
62D6:  MOVLW  10
62D8:  MOVWF  x98
62DA:  MOVFF  194,199
62DE:  MOVLB  0
62E0:  RCALL  5D00
.................... beep_note(F_3, 16, tempo); // E# 
62E2:  MOVLW  12
62E4:  MOVLB  1
62E6:  MOVWF  x97
62E8:  MOVLW  10
62EA:  MOVWF  x98
62EC:  MOVFF  194,199
62F0:  MOVLB  0
62F2:  RCALL  5D00
....................  
.................... beep_note(F_SHARP_3, 16, tempo); // E# 
62F4:  MOVLW  13
62F6:  MOVLB  1
62F8:  MOVWF  x97
62FA:  MOVLW  10
62FC:  MOVWF  x98
62FE:  MOVFF  194,199
6302:  MOVLB  0
6304:  RCALL  5D00
.................... beep_note(B_3, 16, tempo); 
6306:  MOVLW  18
6308:  MOVLB  1
630A:  MOVWF  x97
630C:  MOVLW  10
630E:  MOVWF  x98
6310:  MOVFF  194,199
6314:  MOVLB  0
6316:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
6318:  MOVLW  13
631A:  MOVLB  1
631C:  MOVWF  x97
631E:  MOVLW  10
6320:  MOVWF  x98
6322:  MOVFF  194,199
6326:  MOVLB  0
6328:  RCALL  5D00
.................... beep_note(F_3, 16, tempo); // E# 
632A:  MOVLW  12
632C:  MOVLB  1
632E:  MOVWF  x97
6330:  MOVLW  10
6332:  MOVWF  x98
6334:  MOVFF  194,199
6338:  MOVLB  0
633A:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
633C:  MOVLW  13
633E:  MOVLB  1
6340:  MOVWF  x97
6342:  MOVLW  10
6344:  MOVWF  x98
6346:  MOVFF  194,199
634A:  MOVLB  0
634C:  RCALL  5D00
.................... beep_note(C_SHARP_4, 16, tempo); 
634E:  MOVLW  1A
6350:  MOVLB  1
6352:  MOVWF  x97
6354:  MOVLW  10
6356:  MOVWF  x98
6358:  MOVFF  194,199
635C:  MOVLB  0
635E:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
6360:  MOVLW  13
6362:  MOVLB  1
6364:  MOVWF  x97
6366:  MOVLW  10
6368:  MOVWF  x98
636A:  MOVFF  194,199
636E:  MOVLB  0
6370:  RCALL  5D00
.................... beep_note(E_3, 16, tempo); 
6372:  MOVLW  11
6374:  MOVLB  1
6376:  MOVWF  x97
6378:  MOVLW  10
637A:  MOVWF  x98
637C:  MOVFF  194,199
6380:  MOVLB  0
6382:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
6384:  MOVLW  13
6386:  MOVLB  1
6388:  MOVWF  x97
638A:  MOVLW  10
638C:  MOVWF  x98
638E:  MOVFF  194,199
6392:  MOVLB  0
6394:  RCALL  5D00
.................... beep_note(D_4, 16, tempo); 
6396:  MOVLW  1B
6398:  MOVLB  1
639A:  MOVWF  x97
639C:  MOVLW  10
639E:  MOVWF  x98
63A0:  MOVFF  194,199
63A4:  MOVLB  0
63A6:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
63A8:  MOVLW  13
63AA:  MOVLB  1
63AC:  MOVWF  x97
63AE:  MOVLW  10
63B0:  MOVWF  x98
63B2:  MOVFF  194,199
63B6:  MOVLB  0
63B8:  RCALL  5D00
.................... beep_note(F_3, 16, tempo); // E# 
63BA:  MOVLW  12
63BC:  MOVLB  1
63BE:  MOVWF  x97
63C0:  MOVLW  10
63C2:  MOVWF  x98
63C4:  MOVFF  194,199
63C8:  MOVLB  0
63CA:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
63CC:  MOVLW  13
63CE:  MOVLB  1
63D0:  MOVWF  x97
63D2:  MOVLW  10
63D4:  MOVWF  x98
63D6:  MOVFF  194,199
63DA:  MOVLB  0
63DC:  RCALL  5D00
.................... beep_note(D_4, 16, tempo); 
63DE:  MOVLW  1B
63E0:  MOVLB  1
63E2:  MOVWF  x97
63E4:  MOVLW  10
63E6:  MOVWF  x98
63E8:  MOVFF  194,199
63EC:  MOVLB  0
63EE:  RCALL  5D00
.................... beep_note(C_SHARP_4, 16, tempo); 
63F0:  MOVLW  1A
63F2:  MOVLB  1
63F4:  MOVWF  x97
63F6:  MOVLW  10
63F8:  MOVWF  x98
63FA:  MOVFF  194,199
63FE:  MOVLB  0
6400:  RCALL  5D00
.................... beep_note(B_3, 16, tempo); 
6402:  MOVLW  18
6404:  MOVLB  1
6406:  MOVWF  x97
6408:  MOVLW  10
640A:  MOVWF  x98
640C:  MOVFF  194,199
6410:  MOVLB  0
6412:  RCALL  5D00
.................... beep_note(C_SHARP_4, 16, tempo); 
6414:  MOVLW  1A
6416:  MOVLB  1
6418:  MOVWF  x97
641A:  MOVLW  10
641C:  MOVWF  x98
641E:  MOVFF  194,199
6422:  MOVLB  0
6424:  RCALL  5D00
.................... beep_note(A_3, 16, tempo); 
6426:  MOVLW  16
6428:  MOVLB  1
642A:  MOVWF  x97
642C:  MOVLW  10
642E:  MOVWF  x98
6430:  MOVFF  194,199
6434:  MOVLB  0
6436:  RCALL  5D00
.................... beep_note(G_SHARP_3, 16, tempo); 
6438:  MOVLW  15
643A:  MOVLB  1
643C:  MOVWF  x97
643E:  MOVLW  10
6440:  MOVWF  x98
6442:  MOVFF  194,199
6446:  MOVLB  0
6448:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
644A:  MOVLW  13
644C:  MOVLB  1
644E:  MOVWF  x97
6450:  MOVLW  10
6452:  MOVWF  x98
6454:  MOVFF  194,199
6458:  MOVLB  0
645A:  RCALL  5D00
.................... beep_note(A_3, 8, tempo); 
645C:  MOVLW  16
645E:  MOVLB  1
6460:  MOVWF  x97
6462:  MOVLW  08
6464:  MOVWF  x98
6466:  MOVFF  194,199
646A:  MOVLB  0
646C:  RCALL  5D00
.................... // trille 
.................... beep_note(G_SHARP_3, 32, tempo); 
646E:  MOVLW  15
6470:  MOVLB  1
6472:  MOVWF  x97
6474:  MOVLW  20
6476:  MOVWF  x98
6478:  MOVFF  194,199
647C:  MOVLB  0
647E:  RCALL  5D00
.................... beep_note(A_3, 32, tempo); 
6480:  MOVLW  16
6482:  MOVLB  1
6484:  MOVWF  x97
6486:  MOVLW  20
6488:  MOVWF  x98
648A:  MOVFF  194,199
648E:  MOVLB  0
6490:  RCALL  5D00
.................... beep_note(G_SHARP_3, 32, tempo); 
6492:  MOVLW  15
6494:  MOVLB  1
6496:  MOVWF  x97
6498:  MOVLW  20
649A:  MOVWF  x98
649C:  MOVFF  194,199
64A0:  MOVLB  0
64A2:  RCALL  5D00
.................... beep_note(A_3, 32, tempo); 
64A4:  MOVLW  16
64A6:  MOVLB  1
64A8:  MOVWF  x97
64AA:  MOVLW  20
64AC:  MOVWF  x98
64AE:  MOVFF  194,199
64B2:  MOVLB  0
64B4:  RCALL  5D00
.................... beep_note(F_SHARP_3, 4, tempo); 
64B6:  MOVLW  13
64B8:  MOVLB  1
64BA:  MOVWF  x97
64BC:  MOVLW  04
64BE:  MOVWF  x98
64C0:  MOVFF  194,199
64C4:  MOVLB  0
64C6:  RCALL  5D00
.................... } // end for repeat two times (1st part) 
64C8:  MOVLB  1
64CA:  INCF   x95,F
64CC:  BRA    5D94
....................  
.................... /* 
....................    ################## 
....................    #### 2nd PART #### 
....................    ################## 
.................... */ 
.................... for(int i2=0; i2<2; i2++) 
64CE:  CLRF   x96
64D0:  MOVF   x96,W
64D2:  SUBLW  01
64D4:  BTFSS  FD8.0
64D6:  GOTO   7040
.................... { 
....................  
.................... beep_note(F_SHARP_3, 8, tempo); 
64DA:  MOVLW  13
64DC:  MOVWF  x97
64DE:  MOVLW  08
64E0:  MOVWF  x98
64E2:  MOVFF  194,199
64E6:  MOVLB  0
64E8:  RCALL  5D00
.................... beep_note(A_3, 16, tempo); 
64EA:  MOVLW  16
64EC:  MOVLB  1
64EE:  MOVWF  x97
64F0:  MOVLW  10
64F2:  MOVWF  x98
64F4:  MOVFF  194,199
64F8:  MOVLB  0
64FA:  RCALL  5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
64FC:  MOVLW  13
64FE:  MOVLB  1
6500:  MOVWF  x97
6502:  MOVLW  10
6504:  MOVWF  x98
6506:  MOVFF  194,199
650A:  MOVLB  0
650C:  CALL   5D00
.................... beep_note(C_SHARP_3, 8, tempo); 
6510:  MOVLW  0E
6512:  MOVLB  1
6514:  MOVWF  x97
6516:  MOVLW  08
6518:  MOVWF  x98
651A:  MOVFF  194,199
651E:  MOVLB  0
6520:  CALL   5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
6524:  MOVLW  13
6526:  MOVLB  1
6528:  MOVWF  x97
652A:  MOVLW  10
652C:  MOVWF  x98
652E:  MOVFF  194,199
6532:  MOVLB  0
6534:  CALL   5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
6538:  MOVLW  0E
653A:  MOVLB  1
653C:  MOVWF  x97
653E:  MOVLW  10
6540:  MOVWF  x98
6542:  MOVFF  194,199
6546:  MOVLB  0
6548:  CALL   5D00
.................... beep_note(A_2, 8, tempo); 
654C:  MOVLW  0A
654E:  MOVLB  1
6550:  MOVWF  x97
6552:  MOVLW  08
6554:  MOVWF  x98
6556:  MOVFF  194,199
655A:  MOVLB  0
655C:  CALL   5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
6560:  MOVLW  0E
6562:  MOVLB  1
6564:  MOVWF  x97
6566:  MOVLW  10
6568:  MOVWF  x98
656A:  MOVFF  194,199
656E:  MOVLB  0
6570:  CALL   5D00
.................... beep_note(A_2, 16, tempo); 
6574:  MOVLW  0A
6576:  MOVLB  1
6578:  MOVWF  x97
657A:  MOVLW  10
657C:  MOVWF  x98
657E:  MOVFF  194,199
6582:  MOVLB  0
6584:  CALL   5D00
.................... beep_note(F_SHARP_2, 4, tempo); 
6588:  MOVLW  07
658A:  MOVLB  1
658C:  MOVWF  x97
658E:  MOVLW  04
6590:  MOVWF  x98
6592:  MOVFF  194,199
6596:  MOVLB  0
6598:  CALL   5D00
....................  
.................... beep_note(C_3, 8, tempo); // C becarre 
659C:  MOVLW  0D
659E:  MOVLB  1
65A0:  MOVWF  x97
65A2:  MOVLW  08
65A4:  MOVWF  x98
65A6:  MOVFF  194,199
65AA:  MOVLB  0
65AC:  CALL   5D00
.................... beep_note(B_2, 8, tempo); 
65B0:  MOVLW  0C
65B2:  MOVLB  1
65B4:  MOVWF  x97
65B6:  MOVLW  08
65B8:  MOVWF  x98
65BA:  MOVFF  194,199
65BE:  MOVLB  0
65C0:  CALL   5D00
.................... beep_note(E_3, 8, tempo); 
65C4:  MOVLW  11
65C6:  MOVLB  1
65C8:  MOVWF  x97
65CA:  MOVLW  08
65CC:  MOVWF  x98
65CE:  MOVFF  194,199
65D2:  MOVLB  0
65D4:  CALL   5D00
.................... beep_note(D_SHARP_3, 16, tempo); 
65D8:  MOVLW  10
65DA:  MOVLB  1
65DC:  MOVWF  x97
65DE:  MOVWF  x98
65E0:  MOVFF  194,199
65E4:  MOVLB  0
65E6:  CALL   5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
65EA:  MOVLW  13
65EC:  MOVLB  1
65EE:  MOVWF  x97
65F0:  MOVLW  10
65F2:  MOVWF  x98
65F4:  MOVFF  194,199
65F8:  MOVLB  0
65FA:  CALL   5D00
.................... beep_note(A_3, 8, tempo); 
65FE:  MOVLW  16
6600:  MOVLB  1
6602:  MOVWF  x97
6604:  MOVLW  08
6606:  MOVWF  x98
6608:  MOVFF  194,199
660C:  MOVLB  0
660E:  CALL   5D00
.................... beep_note(G_3, 16, tempo); 
6612:  MOVLW  14
6614:  MOVLB  1
6616:  MOVWF  x97
6618:  MOVLW  10
661A:  MOVWF  x98
661C:  MOVFF  194,199
6620:  MOVLB  0
6622:  CALL   5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
6626:  MOVLW  13
6628:  MOVLB  1
662A:  MOVWF  x97
662C:  MOVLW  10
662E:  MOVWF  x98
6630:  MOVFF  194,199
6634:  MOVLB  0
6636:  CALL   5D00
.................... beep_note(G_3, 8, tempo); 
663A:  MOVLW  14
663C:  MOVLB  1
663E:  MOVWF  x97
6640:  MOVLW  08
6642:  MOVWF  x98
6644:  MOVFF  194,199
6648:  MOVLB  0
664A:  CALL   5D00
.................... beep_note(E_3, 8, tempo); 
664E:  MOVLW  11
6650:  MOVLB  1
6652:  MOVWF  x97
6654:  MOVLW  08
6656:  MOVWF  x98
6658:  MOVFF  194,199
665C:  MOVLB  0
665E:  CALL   5D00
....................  
.................... beep_note(G_3, 8, tempo); 
6662:  MOVLW  14
6664:  MOVLB  1
6666:  MOVWF  x97
6668:  MOVLW  08
666A:  MOVWF  x98
666C:  MOVFF  194,199
6670:  MOVLB  0
6672:  CALL   5D00
.................... beep_note(B_3, 16, tempo); 
6676:  MOVLW  18
6678:  MOVLB  1
667A:  MOVWF  x97
667C:  MOVLW  10
667E:  MOVWF  x98
6680:  MOVFF  194,199
6684:  MOVLB  0
6686:  CALL   5D00
.................... beep_note(G_3, 16, tempo); 
668A:  MOVLW  14
668C:  MOVLB  1
668E:  MOVWF  x97
6690:  MOVLW  10
6692:  MOVWF  x98
6694:  MOVFF  194,199
6698:  MOVLB  0
669A:  CALL   5D00
.................... beep_note(E_3, 8, tempo); 
669E:  MOVLW  11
66A0:  MOVLB  1
66A2:  MOVWF  x97
66A4:  MOVLW  08
66A6:  MOVWF  x98
66A8:  MOVFF  194,199
66AC:  MOVLB  0
66AE:  CALL   5D00
.................... beep_note(G_3, 16, tempo);                                         
66B2:  MOVLW  14
66B4:  MOVLB  1
66B6:  MOVWF  x97
66B8:  MOVLW  10
66BA:  MOVWF  x98
66BC:  MOVFF  194,199
66C0:  MOVLB  0
66C2:  CALL   5D00
.................... beep_note(E_3, 16, tempo);                                         
66C6:  MOVLW  11
66C8:  MOVLB  1
66CA:  MOVWF  x97
66CC:  MOVLW  10
66CE:  MOVWF  x98
66D0:  MOVFF  194,199
66D4:  MOVLB  0
66D6:  CALL   5D00
.................... beep_note(C_SHARP_3, 8, tempo);                                    
66DA:  MOVLW  0E
66DC:  MOVLB  1
66DE:  MOVWF  x97
66E0:  MOVLW  08
66E2:  MOVWF  x98
66E4:  MOVFF  194,199
66E8:  MOVLB  0
66EA:  CALL   5D00
.................... beep_note(E_3, 16, tempo);                                         
66EE:  MOVLW  11
66F0:  MOVLB  1
66F2:  MOVWF  x97
66F4:  MOVLW  10
66F6:  MOVWF  x98
66F8:  MOVFF  194,199
66FC:  MOVLB  0
66FE:  CALL   5D00
.................... beep_note(C_SHARP_3, 16, tempo);                                   
6702:  MOVLW  0E
6704:  MOVLB  1
6706:  MOVWF  x97
6708:  MOVLW  10
670A:  MOVWF  x98
670C:  MOVFF  194,199
6710:  MOVLB  0
6712:  CALL   5D00
.................... beep_note(A_2, 4, tempo); 
6716:  MOVLW  0A
6718:  MOVLB  1
671A:  MOVWF  x97
671C:  MOVLW  04
671E:  MOVWF  x98
6720:  MOVFF  194,199
6724:  MOVLB  0
6726:  CALL   5D00
.................... beep_note(MUTE, 16, tempo); // mute instead of quarter + sixteenth 
672A:  MOVLB  1
672C:  CLRF   x97
672E:  MOVLW  10
6730:  MOVWF  x98
6732:  MOVFF  194,199
6736:  MOVLB  0
6738:  CALL   5D00
....................  
.................... beep_note(D_3, 16, tempo); 
673C:  MOVLW  0F
673E:  MOVLB  1
6740:  MOVWF  x97
6742:  MOVLW  10
6744:  MOVWF  x98
6746:  MOVFF  194,199
674A:  MOVLB  0
674C:  CALL   5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
6750:  MOVLW  13
6752:  MOVLB  1
6754:  MOVWF  x97
6756:  MOVLW  10
6758:  MOVWF  x98
675A:  MOVFF  194,199
675E:  MOVLB  0
6760:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
6764:  MOVLW  0F
6766:  MOVLB  1
6768:  MOVWF  x97
676A:  MOVLW  10
676C:  MOVWF  x98
676E:  MOVFF  194,199
6772:  MOVLB  0
6774:  CALL   5D00
.................... beep_note(E_3, 16, tempo); 
6778:  MOVLW  11
677A:  MOVLB  1
677C:  MOVWF  x97
677E:  MOVLW  10
6780:  MOVWF  x98
6782:  MOVFF  194,199
6786:  MOVLB  0
6788:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
678C:  MOVLW  0F
678E:  MOVLB  1
6790:  MOVWF  x97
6792:  MOVLW  10
6794:  MOVWF  x98
6796:  MOVFF  194,199
679A:  MOVLB  0
679C:  CALL   5D00
.................... beep_note(E_3, 16, tempo); 
67A0:  MOVLW  11
67A2:  MOVLB  1
67A4:  MOVWF  x97
67A6:  MOVLW  10
67A8:  MOVWF  x98
67AA:  MOVFF  194,199
67AE:  MOVLB  0
67B0:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
67B4:  MOVLW  0F
67B6:  MOVLB  1
67B8:  MOVWF  x97
67BA:  MOVLW  10
67BC:  MOVWF  x98
67BE:  MOVFF  194,199
67C2:  MOVLB  0
67C4:  CALL   5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
67C8:  MOVLW  0E
67CA:  MOVLB  1
67CC:  MOVWF  x97
67CE:  MOVLW  10
67D0:  MOVWF  x98
67D2:  MOVFF  194,199
67D6:  MOVLB  0
67D8:  CALL   5D00
.................... beep_note(E_3, 16, tempo); 
67DC:  MOVLW  11
67DE:  MOVLB  1
67E0:  MOVWF  x97
67E2:  MOVLW  10
67E4:  MOVWF  x98
67E6:  MOVFF  194,199
67EA:  MOVLB  0
67EC:  CALL   5D00
.................... beep_note(G_3, 16, tempo); 
67F0:  MOVLW  14
67F2:  MOVLB  1
67F4:  MOVWF  x97
67F6:  MOVLW  10
67F8:  MOVWF  x98
67FA:  MOVFF  194,199
67FE:  MOVLB  0
6800:  CALL   5D00
.................... beep_note(E_3, 16, tempo); 
6804:  MOVLW  11
6806:  MOVLB  1
6808:  MOVWF  x97
680A:  MOVLW  10
680C:  MOVWF  x98
680E:  MOVFF  194,199
6812:  MOVLB  0
6814:  CALL   5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
6818:  MOVLW  13
681A:  MOVLB  1
681C:  MOVWF  x97
681E:  MOVLW  10
6820:  MOVWF  x98
6822:  MOVFF  194,199
6826:  MOVLB  0
6828:  CALL   5D00
.................... beep_note(E_3, 16, tempo); 
682C:  MOVLW  11
682E:  MOVLB  1
6830:  MOVWF  x97
6832:  MOVLW  10
6834:  MOVWF  x98
6836:  MOVFF  194,199
683A:  MOVLB  0
683C:  CALL   5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
6840:  MOVLW  13
6842:  MOVLB  1
6844:  MOVWF  x97
6846:  MOVLW  10
6848:  MOVWF  x98
684A:  MOVFF  194,199
684E:  MOVLB  0
6850:  CALL   5D00
.................... beep_note(E_3, 16, tempo); 
6854:  MOVLW  11
6856:  MOVLB  1
6858:  MOVWF  x97
685A:  MOVLW  10
685C:  MOVWF  x98
685E:  MOVFF  194,199
6862:  MOVLB  0
6864:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
6868:  MOVLW  0F
686A:  MOVLB  1
686C:  MOVWF  x97
686E:  MOVLW  10
6870:  MOVWF  x98
6872:  MOVFF  194,199
6876:  MOVLB  0
6878:  CALL   5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
687C:  MOVLW  13
687E:  MOVLB  1
6880:  MOVWF  x97
6882:  MOVLW  10
6884:  MOVWF  x98
6886:  MOVFF  194,199
688A:  MOVLB  0
688C:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
6890:  MOVLW  0F
6892:  MOVLB  1
6894:  MOVWF  x97
6896:  MOVLW  10
6898:  MOVWF  x98
689A:  MOVFF  194,199
689E:  MOVLB  0
68A0:  CALL   5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
68A4:  MOVLW  0E
68A6:  MOVLB  1
68A8:  MOVWF  x97
68AA:  MOVLW  10
68AC:  MOVWF  x98
68AE:  MOVFF  194,199
68B2:  MOVLB  0
68B4:  CALL   5D00
....................  
.................... beep_note(D_3, 16, tempo); 
68B8:  MOVLW  0F
68BA:  MOVLB  1
68BC:  MOVWF  x97
68BE:  MOVLW  10
68C0:  MOVWF  x98
68C2:  MOVFF  194,199
68C6:  MOVLB  0
68C8:  CALL   5D00
.................... beep_note(G_3, 16, tempo); // ! 
68CC:  MOVLW  14
68CE:  MOVLB  1
68D0:  MOVWF  x97
68D2:  MOVLW  10
68D4:  MOVWF  x98
68D6:  MOVFF  194,199
68DA:  MOVLB  0
68DC:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
68E0:  MOVLW  0F
68E2:  MOVLB  1
68E4:  MOVWF  x97
68E6:  MOVLW  10
68E8:  MOVWF  x98
68EA:  MOVFF  194,199
68EE:  MOVLB  0
68F0:  CALL   5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
68F4:  MOVLW  0E
68F6:  MOVLB  1
68F8:  MOVWF  x97
68FA:  MOVLW  10
68FC:  MOVWF  x98
68FE:  MOVFF  194,199
6902:  MOVLB  0
6904:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
6908:  MOVLW  0F
690A:  MOVLB  1
690C:  MOVWF  x97
690E:  MOVLW  10
6910:  MOVWF  x98
6912:  MOVFF  194,199
6916:  MOVLB  0
6918:  CALL   5D00
.................... beep_note(A_3, 16, tempo); // ! 
691C:  MOVLW  16
691E:  MOVLB  1
6920:  MOVWF  x97
6922:  MOVLW  10
6924:  MOVWF  x98
6926:  MOVFF  194,199
692A:  MOVLB  0
692C:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
6930:  MOVLW  0F
6932:  MOVLB  1
6934:  MOVWF  x97
6936:  MOVLW  10
6938:  MOVWF  x98
693A:  MOVFF  194,199
693E:  MOVLB  0
6940:  CALL   5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
6944:  MOVLW  0E
6946:  MOVLB  1
6948:  MOVWF  x97
694A:  MOVLW  10
694C:  MOVWF  x98
694E:  MOVFF  194,199
6952:  MOVLB  0
6954:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
6958:  MOVLW  0F
695A:  MOVLB  1
695C:  MOVWF  x97
695E:  MOVLW  10
6960:  MOVWF  x98
6962:  MOVFF  194,199
6966:  MOVLB  0
6968:  CALL   5D00
.................... beep_note(B_3, 16, tempo); // ! 
696C:  MOVLW  18
696E:  MOVLB  1
6970:  MOVWF  x97
6972:  MOVLW  10
6974:  MOVWF  x98
6976:  MOVFF  194,199
697A:  MOVLB  0
697C:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
6980:  MOVLW  0F
6982:  MOVLB  1
6984:  MOVWF  x97
6986:  MOVLW  10
6988:  MOVWF  x98
698A:  MOVFF  194,199
698E:  MOVLB  0
6990:  CALL   5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
6994:  MOVLW  0E
6996:  MOVLB  1
6998:  MOVWF  x97
699A:  MOVLW  10
699C:  MOVWF  x98
699E:  MOVFF  194,199
69A2:  MOVLB  0
69A4:  CALL   5D00
....................  
.................... beep_note(D_3, 16, tempo); 
69A8:  MOVLW  0F
69AA:  MOVLB  1
69AC:  MOVWF  x97
69AE:  MOVLW  10
69B0:  MOVWF  x98
69B2:  MOVFF  194,199
69B6:  MOVLB  0
69B8:  CALL   5D00
.................... beep_note(B_3, 16, tempo); 
69BC:  MOVLW  18
69BE:  MOVLB  1
69C0:  MOVWF  x97
69C2:  MOVLW  10
69C4:  MOVWF  x98
69C6:  MOVFF  194,199
69CA:  MOVLB  0
69CC:  CALL   5D00
.................... beep_note(A_3, 16, tempo); 
69D0:  MOVLW  16
69D2:  MOVLB  1
69D4:  MOVWF  x97
69D6:  MOVLW  10
69D8:  MOVWF  x98
69DA:  MOVFF  194,199
69DE:  MOVLB  0
69E0:  CALL   5D00
.................... beep_note(G_3, 16, tempo); 
69E4:  MOVLW  14
69E6:  MOVLB  1
69E8:  MOVWF  x97
69EA:  MOVLW  10
69EC:  MOVWF  x98
69EE:  MOVFF  194,199
69F2:  MOVLB  0
69F4:  CALL   5D00
.................... beep_note(A_3, 16, tempo); 
69F8:  MOVLW  16
69FA:  MOVLB  1
69FC:  MOVWF  x97
69FE:  MOVLW  10
6A00:  MOVWF  x98
6A02:  MOVFF  194,199
6A06:  MOVLB  0
6A08:  CALL   5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
6A0C:  MOVLW  13
6A0E:  MOVLB  1
6A10:  MOVWF  x97
6A12:  MOVLW  10
6A14:  MOVWF  x98
6A16:  MOVFF  194,199
6A1A:  MOVLB  0
6A1C:  CALL   5D00
.................... beep_note(E_3, 16, tempo); 
6A20:  MOVLW  11
6A22:  MOVLB  1
6A24:  MOVWF  x97
6A26:  MOVLW  10
6A28:  MOVWF  x98
6A2A:  MOVFF  194,199
6A2E:  MOVLB  0
6A30:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
6A34:  MOVLW  0F
6A36:  MOVLB  1
6A38:  MOVWF  x97
6A3A:  MOVLW  10
6A3C:  MOVWF  x98
6A3E:  MOVFF  194,199
6A42:  MOVLB  0
6A44:  CALL   5D00
.................... beep_note(F_SHARP_3, 8, tempo); 
6A48:  MOVLW  13
6A4A:  MOVLB  1
6A4C:  MOVWF  x97
6A4E:  MOVLW  08
6A50:  MOVWF  x98
6A52:  MOVFF  194,199
6A56:  MOVLB  0
6A58:  CALL   5D00
.................... // trille 
.................... beep_note(E_3, 32, tempo); 
6A5C:  MOVLW  11
6A5E:  MOVLB  1
6A60:  MOVWF  x97
6A62:  MOVLW  20
6A64:  MOVWF  x98
6A66:  MOVFF  194,199
6A6A:  MOVLB  0
6A6C:  CALL   5D00
.................... beep_note(F_SHARP_3, 32, tempo); 
6A70:  MOVLW  13
6A72:  MOVLB  1
6A74:  MOVWF  x97
6A76:  MOVLW  20
6A78:  MOVWF  x98
6A7A:  MOVFF  194,199
6A7E:  MOVLB  0
6A80:  CALL   5D00
.................... beep_note(E_3, 32, tempo); 
6A84:  MOVLW  11
6A86:  MOVLB  1
6A88:  MOVWF  x97
6A8A:  MOVLW  20
6A8C:  MOVWF  x98
6A8E:  MOVFF  194,199
6A92:  MOVLB  0
6A94:  CALL   5D00
.................... beep_note(F_SHARP_3, 32, tempo); 
6A98:  MOVLW  13
6A9A:  MOVLB  1
6A9C:  MOVWF  x97
6A9E:  MOVLW  20
6AA0:  MOVWF  x98
6AA2:  MOVFF  194,199
6AA6:  MOVLB  0
6AA8:  CALL   5D00
.................... beep_note(D_3, 4, tempo); 
6AAC:  MOVLW  0F
6AAE:  MOVLB  1
6AB0:  MOVWF  x97
6AB2:  MOVLW  04
6AB4:  MOVWF  x98
6AB6:  MOVFF  194,199
6ABA:  MOVLB  0
6ABC:  CALL   5D00
....................  
.................... beep_note(F_SHARP_3, 8, tempo); 
6AC0:  MOVLW  13
6AC2:  MOVLB  1
6AC4:  MOVWF  x97
6AC6:  MOVLW  08
6AC8:  MOVWF  x98
6ACA:  MOVFF  194,199
6ACE:  MOVLB  0
6AD0:  CALL   5D00
.................... beep_note(F_SHARP_3, 8, tempo); 
6AD4:  MOVLW  13
6AD6:  MOVLB  1
6AD8:  MOVWF  x97
6ADA:  MOVLW  08
6ADC:  MOVWF  x98
6ADE:  MOVFF  194,199
6AE2:  MOVLB  0
6AE4:  CALL   5D00
.................... beep_note(F_SHARP_3, 8, tempo); 
6AE8:  MOVLW  13
6AEA:  MOVLB  1
6AEC:  MOVWF  x97
6AEE:  MOVLW  08
6AF0:  MOVWF  x98
6AF2:  MOVFF  194,199
6AF6:  MOVLB  0
6AF8:  CALL   5D00
.................... beep_note(F_SHARP_3, 8, tempo); 
6AFC:  MOVLW  13
6AFE:  MOVLB  1
6B00:  MOVWF  x97
6B02:  MOVLW  08
6B04:  MOVWF  x98
6B06:  MOVFF  194,199
6B0A:  MOVLB  0
6B0C:  CALL   5D00
.................... beep_note(D_4, 8, tempo); 
6B10:  MOVLW  1B
6B12:  MOVLB  1
6B14:  MOVWF  x97
6B16:  MOVLW  08
6B18:  MOVWF  x98
6B1A:  MOVFF  194,199
6B1E:  MOVLB  0
6B20:  CALL   5D00
.................... beep_note(F_SHARP_3, 8, tempo); 
6B24:  MOVLW  13
6B26:  MOVLB  1
6B28:  MOVWF  x97
6B2A:  MOVLW  08
6B2C:  MOVWF  x98
6B2E:  MOVFF  194,199
6B32:  MOVLB  0
6B34:  CALL   5D00
.................... // trille 
.................... beep_note(F_SHARP_3, 32, tempo); 
6B38:  MOVLW  13
6B3A:  MOVLB  1
6B3C:  MOVWF  x97
6B3E:  MOVLW  20
6B40:  MOVWF  x98
6B42:  MOVFF  194,199
6B46:  MOVLB  0
6B48:  CALL   5D00
.................... beep_note(G_3, 32, tempo); 
6B4C:  MOVLW  14
6B4E:  MOVLB  1
6B50:  MOVWF  x97
6B52:  MOVLW  20
6B54:  MOVWF  x98
6B56:  MOVFF  194,199
6B5A:  MOVLB  0
6B5C:  CALL   5D00
.................... beep_note(F_SHARP_3, 32, tempo); 
6B60:  MOVLW  13
6B62:  MOVLB  1
6B64:  MOVWF  x97
6B66:  MOVLW  20
6B68:  MOVWF  x98
6B6A:  MOVFF  194,199
6B6E:  MOVLB  0
6B70:  CALL   5D00
.................... beep_note(G_3, 32, tempo); 
6B74:  MOVLW  14
6B76:  MOVLB  1
6B78:  MOVWF  x97
6B7A:  MOVLW  20
6B7C:  MOVWF  x98
6B7E:  MOVFF  194,199
6B82:  MOVLB  0
6B84:  CALL   5D00
.................... beep_note(E_3, 8, tempo); 
6B88:  MOVLW  11
6B8A:  MOVLB  1
6B8C:  MOVWF  x97
6B8E:  MOVLW  08
6B90:  MOVWF  x98
6B92:  MOVFF  194,199
6B96:  MOVLB  0
6B98:  CALL   5D00
....................  
.................... beep_note(E_3, 8, tempo); 
6B9C:  MOVLW  11
6B9E:  MOVLB  1
6BA0:  MOVWF  x97
6BA2:  MOVLW  08
6BA4:  MOVWF  x98
6BA6:  MOVFF  194,199
6BAA:  MOVLB  0
6BAC:  CALL   5D00
.................... beep_note(E_3, 8, tempo); 
6BB0:  MOVLW  11
6BB2:  MOVLB  1
6BB4:  MOVWF  x97
6BB6:  MOVLW  08
6BB8:  MOVWF  x98
6BBA:  MOVFF  194,199
6BBE:  MOVLB  0
6BC0:  CALL   5D00
.................... beep_note(E_3, 8, tempo); 
6BC4:  MOVLW  11
6BC6:  MOVLB  1
6BC8:  MOVWF  x97
6BCA:  MOVLW  08
6BCC:  MOVWF  x98
6BCE:  MOVFF  194,199
6BD2:  MOVLB  0
6BD4:  CALL   5D00
.................... beep_note(E_3, 8, tempo); 
6BD8:  MOVLW  11
6BDA:  MOVLB  1
6BDC:  MOVWF  x97
6BDE:  MOVLW  08
6BE0:  MOVWF  x98
6BE2:  MOVFF  194,199
6BE6:  MOVLB  0
6BE8:  CALL   5D00
.................... beep_note(C_SHARP_4, 8, tempo); 
6BEC:  MOVLW  1A
6BEE:  MOVLB  1
6BF0:  MOVWF  x97
6BF2:  MOVLW  08
6BF4:  MOVWF  x98
6BF6:  MOVFF  194,199
6BFA:  MOVLB  0
6BFC:  CALL   5D00
.................... beep_note(E_3, 8, tempo); 
6C00:  MOVLW  11
6C02:  MOVLB  1
6C04:  MOVWF  x97
6C06:  MOVLW  08
6C08:  MOVWF  x98
6C0A:  MOVFF  194,199
6C0E:  MOVLB  0
6C10:  CALL   5D00
.................... // trille 
.................... beep_note(E_3, 32, tempo); 
6C14:  MOVLW  11
6C16:  MOVLB  1
6C18:  MOVWF  x97
6C1A:  MOVLW  20
6C1C:  MOVWF  x98
6C1E:  MOVFF  194,199
6C22:  MOVLB  0
6C24:  CALL   5D00
.................... beep_note(F_SHARP_3, 32, tempo); 
6C28:  MOVLW  13
6C2A:  MOVLB  1
6C2C:  MOVWF  x97
6C2E:  MOVLW  20
6C30:  MOVWF  x98
6C32:  MOVFF  194,199
6C36:  MOVLB  0
6C38:  CALL   5D00
.................... beep_note(E_3, 32, tempo); 
6C3C:  MOVLW  11
6C3E:  MOVLB  1
6C40:  MOVWF  x97
6C42:  MOVLW  20
6C44:  MOVWF  x98
6C46:  MOVFF  194,199
6C4A:  MOVLB  0
6C4C:  CALL   5D00
.................... beep_note(F_SHARP_3, 32, tempo); 
6C50:  MOVLW  13
6C52:  MOVLB  1
6C54:  MOVWF  x97
6C56:  MOVLW  20
6C58:  MOVWF  x98
6C5A:  MOVFF  194,199
6C5E:  MOVLB  0
6C60:  CALL   5D00
.................... beep_note(D_3, 4, tempo); 
6C64:  MOVLW  0F
6C66:  MOVLB  1
6C68:  MOVWF  x97
6C6A:  MOVLW  04
6C6C:  MOVWF  x98
6C6E:  MOVFF  194,199
6C72:  MOVLB  0
6C74:  CALL   5D00
.................... beep_note(D_3, 8, tempo); 
6C78:  MOVLW  0F
6C7A:  MOVLB  1
6C7C:  MOVWF  x97
6C7E:  MOVLW  08
6C80:  MOVWF  x98
6C82:  MOVFF  194,199
6C86:  MOVLB  0
6C88:  CALL   5D00
....................  
.................... beep_note(B_3, 8, tempo); 
6C8C:  MOVLW  18
6C8E:  MOVLB  1
6C90:  MOVWF  x97
6C92:  MOVLW  08
6C94:  MOVWF  x98
6C96:  MOVFF  194,199
6C9A:  MOVLB  0
6C9C:  CALL   5D00
.................... beep_note(D_4, 16, tempo); 
6CA0:  MOVLW  1B
6CA2:  MOVLB  1
6CA4:  MOVWF  x97
6CA6:  MOVLW  10
6CA8:  MOVWF  x98
6CAA:  MOVFF  194,199
6CAE:  MOVLB  0
6CB0:  CALL   5D00
.................... beep_note(B_3, 16, tempo); 
6CB4:  MOVLW  18
6CB6:  MOVLB  1
6CB8:  MOVWF  x97
6CBA:  MOVLW  10
6CBC:  MOVWF  x98
6CBE:  MOVFF  194,199
6CC2:  MOVLB  0
6CC4:  CALL   5D00
.................... beep_note(G_3, 6, tempo); // noire pointÃ©e 
6CC8:  MOVLW  14
6CCA:  MOVLB  1
6CCC:  MOVWF  x97
6CCE:  MOVLW  06
6CD0:  MOVWF  x98
6CD2:  MOVFF  194,199
6CD6:  MOVLB  0
6CD8:  CALL   5D00
.................... beep_note(B_3, 32, tempo); 
6CDC:  MOVLW  18
6CDE:  MOVLB  1
6CE0:  MOVWF  x97
6CE2:  MOVLW  20
6CE4:  MOVWF  x98
6CE6:  MOVFF  194,199
6CEA:  MOVLB  0
6CEC:  CALL   5D00
.................... beep_note(A_3, 32, tempo); 
6CF0:  MOVLW  16
6CF2:  MOVLB  1
6CF4:  MOVWF  x97
6CF6:  MOVLW  20
6CF8:  MOVWF  x98
6CFA:  MOVFF  194,199
6CFE:  MOVLB  0
6D00:  CALL   5D00
.................... beep_note(G_3, 32, tempo); 
6D04:  MOVLW  14
6D06:  MOVLB  1
6D08:  MOVWF  x97
6D0A:  MOVLW  20
6D0C:  MOVWF  x98
6D0E:  MOVFF  194,199
6D12:  MOVLB  0
6D14:  CALL   5D00
.................... beep_note(F_SHARP_3, 32, tempo); 
6D18:  MOVLW  13
6D1A:  MOVLB  1
6D1C:  MOVWF  x97
6D1E:  MOVLW  20
6D20:  MOVWF  x98
6D22:  MOVFF  194,199
6D26:  MOVLB  0
6D28:  CALL   5D00
....................  
.................... beep_note(E_3, 6, tempo); // noire pointÃ©e 
6D2C:  MOVLW  11
6D2E:  MOVLB  1
6D30:  MOVWF  x97
6D32:  MOVLW  06
6D34:  MOVWF  x98
6D36:  MOVFF  194,199
6D3A:  MOVLB  0
6D3C:  CALL   5D00
.................... beep_note(G_3, 32, tempo); 
6D40:  MOVLW  14
6D42:  MOVLB  1
6D44:  MOVWF  x97
6D46:  MOVLW  20
6D48:  MOVWF  x98
6D4A:  MOVFF  194,199
6D4E:  MOVLB  0
6D50:  CALL   5D00
.................... beep_note(F_SHARP_3, 32, tempo); 
6D54:  MOVLW  13
6D56:  MOVLB  1
6D58:  MOVWF  x97
6D5A:  MOVLW  20
6D5C:  MOVWF  x98
6D5E:  MOVFF  194,199
6D62:  MOVLB  0
6D64:  CALL   5D00
.................... beep_note(E_3, 32, tempo); 
6D68:  MOVLW  11
6D6A:  MOVLB  1
6D6C:  MOVWF  x97
6D6E:  MOVLW  20
6D70:  MOVWF  x98
6D72:  MOVFF  194,199
6D76:  MOVLB  0
6D78:  CALL   5D00
.................... beep_note(D_3, 32, tempo); 
6D7C:  MOVLW  0F
6D7E:  MOVLB  1
6D80:  MOVWF  x97
6D82:  MOVLW  20
6D84:  MOVWF  x98
6D86:  MOVFF  194,199
6D8A:  MOVLB  0
6D8C:  CALL   5D00
.................... beep_note(C_3, 16, tempo); // do bÃ©carre 
6D90:  MOVLW  0D
6D92:  MOVLB  1
6D94:  MOVWF  x97
6D96:  MOVLW  10
6D98:  MOVWF  x98
6D9A:  MOVFF  194,199
6D9E:  MOVLB  0
6DA0:  CALL   5D00
.................... beep_note(E_3, 16, tempo); 
6DA4:  MOVLW  11
6DA6:  MOVLB  1
6DA8:  MOVWF  x97
6DAA:  MOVLW  10
6DAC:  MOVWF  x98
6DAE:  MOVFF  194,199
6DB2:  MOVLB  0
6DB4:  CALL   5D00
.................... beep_note(G_3, 16, tempo); 
6DB8:  MOVLW  14
6DBA:  MOVLB  1
6DBC:  MOVWF  x97
6DBE:  MOVLW  10
6DC0:  MOVWF  x98
6DC2:  MOVFF  194,199
6DC6:  MOVLB  0
6DC8:  CALL   5D00
.................... beep_note(E_3, 16, tempo); 
6DCC:  MOVLW  11
6DCE:  MOVLB  1
6DD0:  MOVWF  x97
6DD2:  MOVLW  10
6DD4:  MOVWF  x98
6DD6:  MOVFF  194,199
6DDA:  MOVLB  0
6DDC:  CALL   5D00
.................... beep_note(C_3, 16, tempo); // do bÃ©carre (mesure) 
6DE0:  MOVLW  0D
6DE2:  MOVLB  1
6DE4:  MOVWF  x97
6DE6:  MOVLW  10
6DE8:  MOVWF  x98
6DEA:  MOVFF  194,199
6DEE:  MOVLB  0
6DF0:  CALL   5D00
.................... beep_note(B_2, 16, tempo); 
6DF4:  MOVLW  0C
6DF6:  MOVLB  1
6DF8:  MOVWF  x97
6DFA:  MOVLW  10
6DFC:  MOVWF  x98
6DFE:  MOVFF  194,199
6E02:  MOVLB  0
6E04:  CALL   5D00
.................... beep_note(C_3, 16, tempo); // do bÃ©carre (mesure) 
6E08:  MOVLW  0D
6E0A:  MOVLB  1
6E0C:  MOVWF  x97
6E0E:  MOVLW  10
6E10:  MOVWF  x98
6E12:  MOVFF  194,199
6E16:  MOVLB  0
6E18:  CALL   5D00
.................... beep_note(B_2, 16, tempo); 
6E1C:  MOVLW  0C
6E1E:  MOVLB  1
6E20:  MOVWF  x97
6E22:  MOVLW  10
6E24:  MOVWF  x98
6E26:  MOVFF  194,199
6E2A:  MOVLB  0
6E2C:  CALL   5D00
....................  
.................... beep_note(A_SHARP_2, 8 tempo); 
6E30:  MOVLW  0B
6E32:  MOVLB  1
6E34:  MOVWF  x97
6E36:  MOVLW  08
6E38:  MOVWF  x98
6E3A:  MOVFF  194,199
6E3E:  MOVLB  0
6E40:  CALL   5D00
.................... beep_note(F_SHARP_2, 8, tempo); 
6E44:  MOVLW  07
6E46:  MOVLB  1
6E48:  MOVWF  x97
6E4A:  MOVLW  08
6E4C:  MOVWF  x98
6E4E:  MOVFF  194,199
6E52:  MOVLB  0
6E54:  CALL   5D00
.................... beep_note(G_2, 8 tempo); 
6E58:  MOVLW  08
6E5A:  MOVLB  1
6E5C:  MOVWF  x97
6E5E:  MOVWF  x98
6E60:  MOVFF  194,199
6E64:  MOVLB  0
6E66:  CALL   5D00
.................... beep_note(F_SHARP_2, 8, tempo); 
6E6A:  MOVLW  07
6E6C:  MOVLB  1
6E6E:  MOVWF  x97
6E70:  MOVLW  08
6E72:  MOVWF  x98
6E74:  MOVFF  194,199
6E78:  MOVLB  0
6E7A:  CALL   5D00
....................  
.................... beep_note(B_2, 8, tempo); 
6E7E:  MOVLW  0C
6E80:  MOVLB  1
6E82:  MOVWF  x97
6E84:  MOVLW  08
6E86:  MOVWF  x98
6E88:  MOVFF  194,199
6E8C:  MOVLB  0
6E8E:  CALL   5D00
.................... beep_note(A_SHARP_2, 16, tempo); 
6E92:  MOVLW  0B
6E94:  MOVLB  1
6E96:  MOVWF  x97
6E98:  MOVLW  10
6E9A:  MOVWF  x98
6E9C:  MOVFF  194,199
6EA0:  MOVLB  0
6EA2:  CALL   5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
6EA6:  MOVLW  0E
6EA8:  MOVLB  1
6EAA:  MOVWF  x97
6EAC:  MOVLW  10
6EAE:  MOVWF  x98
6EB0:  MOVFF  194,199
6EB4:  MOVLB  0
6EB6:  CALL   5D00
.................... beep_note(E_3, 8, tempo); 
6EBA:  MOVLW  11
6EBC:  MOVLB  1
6EBE:  MOVWF  x97
6EC0:  MOVLW  08
6EC2:  MOVWF  x98
6EC4:  MOVFF  194,199
6EC8:  MOVLB  0
6ECA:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
6ECE:  MOVLW  0F
6ED0:  MOVLB  1
6ED2:  MOVWF  x97
6ED4:  MOVLW  10
6ED6:  MOVWF  x98
6ED8:  MOVFF  194,199
6EDC:  MOVLB  0
6EDE:  CALL   5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
6EE2:  MOVLW  0E
6EE4:  MOVLB  1
6EE6:  MOVWF  x97
6EE8:  MOVLW  10
6EEA:  MOVWF  x98
6EEC:  MOVFF  194,199
6EF0:  MOVLB  0
6EF2:  CALL   5D00
.................... beep_note(D_3, 8, tempo); 
6EF6:  MOVLW  0F
6EF8:  MOVLB  1
6EFA:  MOVWF  x97
6EFC:  MOVLW  08
6EFE:  MOVWF  x98
6F00:  MOVFF  194,199
6F04:  MOVLB  0
6F06:  CALL   5D00
....................  
.................... beep_note(B_2, 32, tempo); 
6F0A:  MOVLW  0C
6F0C:  MOVLB  1
6F0E:  MOVWF  x97
6F10:  MOVLW  20
6F12:  MOVWF  x98
6F14:  MOVFF  194,199
6F18:  MOVLB  0
6F1A:  CALL   5D00
.................... beep_note(C_SHARP_3, 32, tempo); 
6F1E:  MOVLW  0E
6F20:  MOVLB  1
6F22:  MOVWF  x97
6F24:  MOVLW  20
6F26:  MOVWF  x98
6F28:  MOVFF  194,199
6F2C:  MOVLB  0
6F2E:  CALL   5D00
.................... beep_note(D_3, 32, tempo); 
6F32:  MOVLW  0F
6F34:  MOVLB  1
6F36:  MOVWF  x97
6F38:  MOVLW  20
6F3A:  MOVWF  x98
6F3C:  MOVFF  194,199
6F40:  MOVLB  0
6F42:  CALL   5D00
.................... beep_note(E_3, 32, tempo); 
6F46:  MOVLW  11
6F48:  MOVLB  1
6F4A:  MOVWF  x97
6F4C:  MOVLW  20
6F4E:  MOVWF  x98
6F50:  MOVFF  194,199
6F54:  MOVLB  0
6F56:  CALL   5D00
.................... beep_note(F_SHARP_3, 8, tempo); 
6F5A:  MOVLW  13
6F5C:  MOVLB  1
6F5E:  MOVWF  x97
6F60:  MOVLW  08
6F62:  MOVWF  x98
6F64:  MOVFF  194,199
6F68:  MOVLB  0
6F6A:  CALL   5D00
....................  
.................... beep_note(D_3, 16, tempo); 
6F6E:  MOVLW  0F
6F70:  MOVLB  1
6F72:  MOVWF  x97
6F74:  MOVLW  10
6F76:  MOVWF  x98
6F78:  MOVFF  194,199
6F7C:  MOVLB  0
6F7E:  CALL   5D00
.................... beep_note(F_SHARP_3, 16, tempo); 
6F82:  MOVLW  13
6F84:  MOVLB  1
6F86:  MOVWF  x97
6F88:  MOVLW  10
6F8A:  MOVWF  x98
6F8C:  MOVFF  194,199
6F90:  MOVLB  0
6F92:  CALL   5D00
.................... beep_note(B_3, 8, tempo); 
6F96:  MOVLW  18
6F98:  MOVLB  1
6F9A:  MOVWF  x97
6F9C:  MOVLW  08
6F9E:  MOVWF  x98
6FA0:  MOVFF  194,199
6FA4:  MOVLB  0
6FA6:  CALL   5D00
.................... beep_note(F_SHARP_3, 8, tempo); 
6FAA:  MOVLW  13
6FAC:  MOVLB  1
6FAE:  MOVWF  x97
6FB0:  MOVLW  08
6FB2:  MOVWF  x98
6FB4:  MOVFF  194,199
6FB8:  MOVLB  0
6FBA:  CALL   5D00
....................  
.................... beep_note(E_3, 16, tempo); 
6FBE:  MOVLW  11
6FC0:  MOVLB  1
6FC2:  MOVWF  x97
6FC4:  MOVLW  10
6FC6:  MOVWF  x98
6FC8:  MOVFF  194,199
6FCC:  MOVLB  0
6FCE:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
6FD2:  MOVLW  0F
6FD4:  MOVLB  1
6FD6:  MOVWF  x97
6FD8:  MOVLW  10
6FDA:  MOVWF  x98
6FDC:  MOVFF  194,199
6FE0:  MOVLB  0
6FE2:  CALL   5D00
.................... beep_note(C_SHARP_3, 16, tempo); 
6FE6:  MOVLW  0E
6FE8:  MOVLB  1
6FEA:  MOVWF  x97
6FEC:  MOVLW  10
6FEE:  MOVWF  x98
6FF0:  MOVFF  194,199
6FF4:  MOVLB  0
6FF6:  CALL   5D00
.................... beep_note(D_3, 16, tempo); 
6FFA:  MOVLW  0F
6FFC:  MOVLB  1
6FFE:  MOVWF  x97
7000:  MOVLW  10
7002:  MOVWF  x98
7004:  MOVFF  194,199
7008:  MOVLB  0
700A:  CALL   5D00
....................  
.................... // Very last note is special and played outside the for loop 
.................... if(i2==0){  
700E:  MOVLB  1
7010:  MOVF   x96,F
7012:  BNZ   703A
....................    beep_note(B_2, 4, tempo); 
7014:  MOVLW  0C
7016:  MOVWF  x97
7018:  MOVLW  04
701A:  MOVWF  x98
701C:  MOVFF  194,199
7020:  MOVLB  0
7022:  CALL   5D00
....................    beep_note(MUTE, 2, tempo); 
7026:  MOVLB  1
7028:  CLRF   x97
702A:  MOVLW  02
702C:  MOVWF  x98
702E:  MOVFF  194,199
7032:  MOVLB  0
7034:  CALL   5D00
7038:  MOVLB  1
.................... } 
....................  
.................... } // end for repeat two times (2nd part) 
703A:  INCF   x96,F
703C:  GOTO   64D0
....................  
.................... // Ending / CODA 
.................... beep_note(MUTE, 4, tempo); 
7040:  CLRF   x97
7042:  MOVLW  04
7044:  MOVWF  x98
7046:  MOVFF  194,199
704A:  MOVLB  0
704C:  CALL   5D00
.................... beep_note(C_SHARP_3, 4, tempo); 
7050:  MOVLW  0E
7052:  MOVLB  1
7054:  MOVWF  x97
7056:  MOVLW  04
7058:  MOVWF  x98
705A:  MOVFF  194,199
705E:  MOVLB  0
7060:  CALL   5D00
.................... beep_note(B_2, 2, tempo); 
7064:  MOVLW  0C
7066:  MOVLB  1
7068:  MOVWF  x97
706A:  MOVLW  02
706C:  MOVWF  x98
706E:  MOVFF  194,199
7072:  MOVLB  0
7074:  CALL   5D00
....................  
.................... } // end beep_badinerie() 
7078:  GOTO   720E (RETURN)
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... // Output a number on the 4 leds in a binary way 
.................... #include "binary_led_transcoder.h"  
.................... #ifndef BINARY_LED_TRANSCODER_H 
.................... #define BINARY_LED_TRANSCODER_H 
....................  
....................  
.................... /** 
....................  * Display the specified number in binary format with the four supplied LEDs. 
....................  * 
....................  * @param number A number from 0 to 9 (limitation due to the TV remote) 
....................  */ 
.................... void led_display_number(int8 number); 
....................  
.................... #include "binary_led_transcoder.c" 
....................  
.................... #endif 
....................  
....................  
.................... // Utilities to read keys pressed on the TV remote control 
.................... #include "tv_remote_utils.h"  
.................... /** 
....................  * @file 
....................  *  
....................  * @brief Utilities to read keys pressed from the TV remote control 
....................  */ 
....................  
.................... #ifndef TV_REMOTE_UTILS_H 
.................... #define TV_REMOTE_UTILS_H 
....................  
.................... // Constants for buttons of the TV remote control 
.................... #define TV_POWER        38 
.................... #define TV_MUTE         36 
.................... #define TV_CH_PLUS      30 
.................... #define TV_CH_MINUS     28 
.................... #define TV_VOL_PLUS     18 
.................... #define TV_VOL_MINUS    20 
.................... #define TV_TV_AV        34 
.................... #define TV_I_II         56 
.................... #define TV_3            56 
.................... #define TV_ARROW        56 
.................... // TV_0 ---> TV_11 : Please use to_pad_number if needed 
.................... #define TV_CH_PC        32 
....................  
.................... /** 
....................  * Convert the raw button id from TV remote to the button number. 
....................  * 
....................  * @param raw_input Raw input from TV remote. 
....................  * @return the corresponding button number matching the TV remote raw input. 
....................  */ 
.................... int8 to_pad_number(unsigned char raw_input); 
....................  
.................... /** 
....................  * Returns the last number pressed on the TV remote number pad. 
....................  * 
....................  * @return the last number pressed on the TV remote number pad. 
....................  */ 
.................... int8 get_tv_remote_pad_number(void); 
....................  
.................... #include "tv_remote_utils.c" 
....................  
.................... #endif 
....................  
....................  
.................... // The Multitasking Program 
.................... #include "multitasking.h"  
.................... /** 
....................  * @file 
....................  *  
....................  * @brief The Multitasking program 
....................  *  
....................  * This program makes the robot : 
....................  *   - play a "police" sound 
....................  *   - light on and off the leds in a "circular" way 
....................  *   - avoid obstacles : on the sides, forward, backward 
....................  *   - the robot will also go backward for a while if a missing ground is detected 
....................  * 
....................  * purpose : to demonstrate how we can simulate multitasking with sequential  
....................  * instructions. We got inspired by the processors, which often simply use  
....................  * quick context switch between applications to simulate multithreading. 
....................  *  
....................  * @authors Mathieu Clement, Lucy Linder 
....................  */ 
....................  
.................... #ifndef MULTITASKING_bla 
.................... #define MULTITASKING_bla 1 
....................  
.................... #define MT_NORMAL_SPEED 5 
.................... #define MT_GROUND_MISSING_LIMIT 2800 
.................... #define MT_PROXIMITY  1200   //!< limit under which an obstacle is not avoided 
.................... #define MT_BEEP_DELTA 500    //!< milliseconds between each beep 
.................... #define MT_LED_DELTA  100     //!< milliseconds between led switches 
.................... #define MT_GROUND_MISSING_BACKWARDS_DELTA 500 //!< the time during which to go backwards when a "missing ground" is detected, in ms 
.................... #define MT_GROUND_MISSING_ROTATE_DELTA    2000 //!< the time during which to turn after a "backward ground missing avoidance" 
....................  
....................  
.................... //variables 
.................... int1  mt_should_beep_A=0;  //!< boolean, to know which sound (A or B) is the next to play 
.................... int8  mt_increment = 1; //!< used to switch between leds - varies between 1 and -1 
.................... int8  mt_led_control = 0; //!< used to keep track of which is the current lit led 
.................... int1  mt_be_silent_please = 0; //!< to run the multitasking method without the sirens 
....................  
.................... //methods 
.................... void mt_set_led(int nbr, int state); //!< lights on or off the specified led (state : 0 = OFF, 1 = ON ) 
.................... void mt_led_incr(void); //!< increment or decrement the led counter (the leds are lit in the sequence 0 - 1 - 2 -... - 4 - 3 ... - 0 - 1 etc) 
.................... int1 mt_ground_is_missing(void); //!< returns true if the ground captor does not detect the ground 
.................... void mt_turn_left(void); //!< turns left 
.................... void mt_turn_right(void); //!< turns right 
....................  
.................... void multitasking(void); //!< contains the main method (while loop) for the multitasking program 
....................  
....................  
.................... #include "multitasking.c" 
.................... //!< used in order to make the robot beep  
.................... #include "simple_beep.h" 
.................... #ifndef SIMPLE_BEEP 
.................... #define SIMPLE_BEEP 1 
.................... // This library is useful to make some frickin' noise with the Robot! 
....................  
.................... // MUTE buzzer 
.................... #define MUTE      0 
....................  
.................... // Notes 
.................... // Please refer to K-Junior documentation for more information. 
.................... #define C_2       1 
.................... #define C_SHARP_2 2 
.................... #define D_FLAT_2  2 
.................... #define D_2       3 
.................... #define D_SHARP_2 4 
.................... #define E_FLAT_2  4 
.................... #define E_2       5 
.................... #define F_2       6 
.................... #define F_SHARP_2 7 
.................... #define G_FLAT_2  7 
.................... #define G_2       8 
.................... #define G_SHARP_2 9 
.................... #define A_FLAT_2  9 
.................... #define A_2       10 
.................... #define A_SHARP_2 11 
.................... #define B_FLAT_2  11 
.................... #define B_2       12 
....................  
.................... #define C_3       13 
.................... #define C_SHARP_3 14 
.................... #define D_FLAT_3  14 
.................... #define D_3       15 
.................... #define D_SHARP_3 16 
.................... #define E_FLAT_3  16 
.................... #define E_3       17 
.................... #define F_3       18 
.................... #define F_SHARP_3 19 
.................... #define G_FLAT_3  19 
.................... #define G_3       20 
.................... #define G_SHARP_3 21 
.................... #define A_FLAT_3  21 
.................... #define A_3       22 
.................... #define A_SHARP_3 23 
.................... #define B_FLAT_3  23 
.................... #define B_3       24 
....................  
.................... #define C_4       25 
.................... #define C_SHARP_4 26 
.................... #define D_FLAT_4  26 
.................... #define D_4       27 
.................... #define D_SHARP_4 28 
.................... #define E_FLAT_4  28 
.................... #define E_4       29 
.................... #define F_4       30 
.................... #define F_SHARP_4 31 
.................... #define G_FLAT_4  31 
.................... #define G_4       32 
.................... #define G_SHARP_4 33 
.................... #define A_FLAT_4  33 
.................... #define A_4       34 
.................... #define A_SHARP_4 35 
.................... #define B_FLAT_4  35 
.................... #define B_4       36 
....................  
.................... #define C_5       37 
.................... #define C_SHARP_5 38 
.................... #define D_FLAT_5  38 
.................... #define D_5       39 
.................... #define D_SHARP_5 40 
.................... #define E_FLAT_5  40 
.................... #define E_5       41 
.................... #define F_5       42 
.................... #define F_SHARP_5 43 
.................... #define G_FLAT_5  43 
.................... #define G_5       44 
.................... #define G_SHARP_5 45 
.................... #define A_FLAT_5  45 
.................... #define A_5       46 
.................... #define A_SHARP_5 47 
.................... #define B_FLAT_5  47 
.................... #define B_5       48 
....................  
....................  
.................... void incremental_beep(void); 
....................  
.................... float note_length_ms(int8 value, int8 tempo); 
....................  
.................... void beep_note(int8 note, int8 note_value, int8 tempo); 
....................  
.................... void beep_blues_scale(void); 
....................  
.................... void beep_star_wars(void); 
....................  
.................... void beep_badinerie(void); 
....................  
.................... #include "simple_beep.c" 
....................  
....................  
.................... #endif 
....................  
.................... /******************************************************************************* 
....................  * @file 
....................  *  
....................  * @brief The Multitasking program 
....................  * See the multitasking.h file for more informations... 
....................  * 
....................  *******************************************************************************/ 
.................... /** 
....................  * simple method to make the robot turn left at normal speed 
....................  */ 
.................... void mt_turn_left()  { KJunior_set_speed( -MT_NORMAL_SPEED,  MT_NORMAL_SPEED ); } 
*
4F08:  MOVLW  FB
4F0A:  MOVLB  1
4F0C:  MOVWF  xA1
4F0E:  MOVLW  05
4F10:  MOVWF  xA2
4F12:  MOVLB  0
4F14:  RCALL  4A08
4F16:  RETURN 0
....................  
.................... /** 
....................  * simple method to make the robot turn right at normal speed  
....................  */ 
.................... void mt_turn_right() { KJunior_set_speed(  MT_NORMAL_SPEED, -MT_NORMAL_SPEED ); } 
4F18:  MOVLW  05
4F1A:  MOVLB  1
4F1C:  MOVWF  xA1
4F1E:  MOVLW  FB
4F20:  MOVWF  xA2
4F22:  MOVLB  0
4F24:  RCALL  4A08
4F26:  RETURN 0
....................  
....................  
.................... /** 
....................  * Increments the led_control variable in the following sequence : 
....................  *    0 - 1 - 2 - 3 - 4 - 3 - 2 - 1 - 0 - 1 - ... 
....................  * Uses the "increment" variable to do a +1 or a -1 operation. 
....................  **/ 
.................... void mt_led_incr() 
.................... { 
....................    mt_set_led( mt_led_control, 0 ); //turns of the current led 
*
4E7E:  MOVFF  193,1A1
4E82:  MOVLB  1
4E84:  CLRF   xA2
4E86:  MOVLB  0
4E88:  RCALL  4E20
....................    mt_led_control += mt_increment;  
4E8A:  MOVLB  1
4E8C:  MOVF   x92,W
4E8E:  ADDWF  x93,F
....................    mt_set_led( mt_led_control, 1 ); //turns on the next led  
4E90:  MOVFF  193,1A1
4E94:  MOVLW  01
4E96:  MOVWF  xA2
4E98:  MOVLB  0
4E9A:  RCALL  4E20
....................     
....................    if( mt_led_control == 0 || mt_led_control == 3)  
4E9C:  MOVLB  1
4E9E:  MOVF   x93,F
4EA0:  BZ    4EA8
4EA2:  MOVF   x93,W
4EA4:  SUBLW  03
4EA6:  BNZ   4EAA
....................       mt_increment = -mt_increment; 
4EA8:  NEGF   x92
....................        
.................... }//end led_incr 
4EAA:  MOVLB  0
4EAC:  GOTO   4FFC (RETURN)
....................  
....................  
.................... /** 
....................  * lights on or off the specified led. 
....................  * nbr : led  
....................  *   0 = left led 
....................  *   1 = front left led 
....................  *   2 = front right led 
....................  *   3 = right led 
....................  * control : 1 = ON, 0 = OFF 
....................  **/ 
.................... void mt_set_led(int nbr, int state){ 
....................  
....................    switch(nbr){ 
*
4E20:  MOVLB  1
4E22:  MOVF   xA1,W
4E24:  ADDLW  FC
4E26:  BC    4E58
4E28:  ADDLW  04
4E2A:  MOVLB  0
4E2C:  GOTO   4E5C
....................       case 0: 
....................          KJunior_led_left(state); 
4E30:  MOVFF  1A2,1D9
4E34:  CALL   1A3E
....................          return; 
4E38:  BRA    4E56
....................       case 1: 
....................          KJunior_led_frontleft(state); 
4E3A:  MOVFF  1A2,1D7
4E3E:  CALL   1A4E
....................          return; 
4E42:  BRA    4E56
....................       case 2: 
....................          KJunior_led_frontright(state); 
4E44:  MOVFF  1A2,1D7
4E48:  CALL   1A5E
....................          return; 
4E4C:  BRA    4E56
....................       case 3: 
....................          KJunior_led_right(state); 
4E4E:  MOVFF  1A2,1D7
4E52:  CALL   1A6E
....................          return; 
4E56:  MOVLB  1
....................    } 
.................... }//end set_led 
4E58:  MOVLB  0
4E5A:  RETURN 0
....................  
....................  
....................  
.................... /** 
....................  * returns true (1) if the ground is not detected by the ground front captors 
....................  * 
....................  **/ 
.................... int1 mt_ground_is_missing() 
.................... { 
....................    return KJunior_get_proximity( GROUNDFRONTLEFT  ) < MT_GROUND_MISSING_LIMIT ||  
....................           KJunior_get_proximity( GROUNDFRONTRIGHT ) < MT_GROUND_MISSING_LIMIT; 
*
4EB0:  MOVLW  07
4EB2:  MOVLB  1
4EB4:  MOVWF  xA3
4EB6:  MOVLB  0
4EB8:  RCALL  49E6
4EBA:  MOVFF  02,1A2
4EBE:  MOVFF  01,1A1
4EC2:  MOVLB  1
4EC4:  BTFSC  02.7
4EC6:  BRA    4EFE
4EC8:  MOVF   xA2,W
4ECA:  SUBLW  0A
4ECC:  BNC   4ED6
4ECE:  BNZ   4EFE
4ED0:  MOVF   xA1,W
4ED2:  SUBLW  EF
4ED4:  BC    4EFE
4ED6:  MOVLW  08
4ED8:  MOVWF  xA3
4EDA:  MOVLB  0
4EDC:  RCALL  49E6
4EDE:  MOVFF  02,1A2
4EE2:  MOVFF  01,1A1
4EE6:  MOVLB  1
4EE8:  BTFSC  02.7
4EEA:  BRA    4EFE
4EEC:  MOVF   xA2,W
4EEE:  SUBLW  0A
4EF0:  BNC   4EFA
4EF2:  BNZ   4EFE
4EF4:  MOVF   xA1,W
4EF6:  SUBLW  EF
4EF8:  BC    4EFE
4EFA:  MOVLW  00
4EFC:  BRA    4F00
4EFE:  MOVLW  01
4F00:  MOVWF  01
.................... } 
4F02:  MOVLB  0
4F04:  GOTO   5012 (RETURN)
....................  
....................  
.................... /*********************** main method ******************************************/ 
.................... void multitasking() 
.................... { 
*
4F28:  RCALL  4AB2
4F2A:  MOVFF  03,197
4F2E:  MOVFF  02,196
4F32:  MOVFF  01,195
4F36:  MOVFF  00,194
4F3A:  MOVFF  197,19B
4F3E:  MOVFF  196,19A
4F42:  MOVFF  195,199
4F46:  MOVFF  194,198
4F4A:  MOVLB  1
4F4C:  CLRF   x9F
4F4E:  CLRF   x9E
4F50:  CLRF   x9D
4F52:  CLRF   x9C
4F54:  CLRF   xA0
....................  int32 beep_last_time = KJunior_get_time(); 
....................  int32 led_last_time =  beep_last_time; 
....................  int32 ground_missing_timer = 0; 
....................  int8  ground_missing_state = 0; 
....................   
....................   
....................  While (1) 
....................  {  
....................    //beeps 
....................    if( !mt_be_silent_please ) 
4F56:  MOVLB  0
4F58:  BTFSC  x88.7
4F5A:  BRA    4FC0
....................    { 
....................       if( (KJunior_get_time() - beep_last_time) > MT_BEEP_DELTA )  
4F5C:  RCALL  4AB2
4F5E:  MOVFF  03,1A4
4F62:  MOVFF  02,1A3
4F66:  MOVFF  01,1A2
4F6A:  MOVFF  00,1A1
4F6E:  MOVLB  1
4F70:  MOVF   x94,W
4F72:  SUBWF  xA1,F
4F74:  MOVF   x95,W
4F76:  SUBWFB xA2,F
4F78:  MOVF   x96,W
4F7A:  SUBWFB xA3,F
4F7C:  MOVF   x97,W
4F7E:  SUBWFB xA4,F
4F80:  BNZ   4F96
4F82:  MOVF   xA3,F
4F84:  BNZ   4F96
4F86:  MOVF   xA2,W
4F88:  SUBLW  00
4F8A:  BC    4FC2
4F8C:  XORLW  FF
4F8E:  BNZ   4F96
4F90:  MOVF   xA1,W
4F92:  SUBLW  F4
4F94:  BC    4FC2
....................       { 
....................       
....................          mt_should_beep_A = !mt_should_beep_A; 
4F96:  MOVLB  0
4F98:  BTG    x88.6
....................          KJunior_beep( mt_should_beep_A ? A_3 : E_3 );  
4F9A:  BTFSS  x88.6
4F9C:  BRA    4FA2
4F9E:  MOVLW  16
4FA0:  BRA    4FA4
4FA2:  MOVLW  11
4FA4:  MOVLB  1
4FA6:  MOVWF  xA1
4FA8:  MOVWF  xA2
4FAA:  MOVLB  0
4FAC:  RCALL  4E16
....................          beep_last_time = KJunior_get_time(); 
4FAE:  RCALL  4AB2
4FB0:  MOVFF  03,197
4FB4:  MOVFF  02,196
4FB8:  MOVFF  01,195
4FBC:  MOVFF  00,194
4FC0:  MOVLB  1
....................       } 
....................    } 
....................     
....................     
....................    //leds 
....................    if((KJunior_get_time() - led_last_time) > MT_LED_DELTA )  
4FC2:  MOVLB  0
4FC4:  RCALL  4AB2
4FC6:  MOVFF  03,1A4
4FCA:  MOVFF  02,1A3
4FCE:  MOVFF  01,1A2
4FD2:  MOVFF  00,1A1
4FD6:  MOVLB  1
4FD8:  MOVF   x98,W
4FDA:  SUBWF  xA1,F
4FDC:  MOVF   x99,W
4FDE:  SUBWFB xA2,F
4FE0:  MOVF   x9A,W
4FE2:  SUBWFB xA3,F
4FE4:  MOVF   x9B,W
4FE6:  SUBWFB xA4,F
4FE8:  BNZ   4FF8
4FEA:  MOVF   xA3,F
4FEC:  BNZ   4FF8
4FEE:  MOVF   xA2,F
4FF0:  BNZ   4FF8
4FF2:  MOVF   xA1,W
4FF4:  SUBLW  64
4FF6:  BC    500E
....................    { 
....................       mt_led_incr(); 
4FF8:  MOVLB  0
4FFA:  BRA    4E7E
....................       led_last_time = KJunior_get_time(); 
4FFC:  RCALL  4AB2
4FFE:  MOVFF  03,19B
5002:  MOVFF  02,19A
5006:  MOVFF  01,199
500A:  MOVFF  00,198
....................    } 
....................   
....................    //checks that the floor is still here 
....................    if( mt_ground_is_missing() )  
500E:  MOVLB  0
5010:  BRA    4EB0
5012:  MOVF   01,F
5014:  BZ    503C
....................    {    
....................          KJunior_set_speed(-20, -20);   
5016:  MOVLW  EC
5018:  MOVLB  1
501A:  MOVWF  xA1
501C:  MOVWF  xA2
501E:  MOVLB  0
5020:  RCALL  4A08
....................          ground_missing_state = 1; 
5022:  MOVLW  01
5024:  MOVLB  1
5026:  MOVWF  xA0
....................          ground_missing_timer = KJunior_get_time(); 
5028:  MOVLB  0
502A:  RCALL  4AB2
502C:  MOVFF  03,19F
5030:  MOVFF  02,19E
5034:  MOVFF  01,19D
5038:  MOVFF  00,19C
....................    } 
....................     
....................    //if the robot is going backwards to avoid a missing ground 
....................    if ( ground_missing_state == 1 )  
503C:  MOVLB  1
503E:  DECFSZ xA0,W
5040:  BRA    509C
....................    { 
....................     
....................       if( KJunior_get_time() - ground_missing_timer > MT_GROUND_MISSING_BACKWARDS_DELTA ) 
5042:  MOVLB  0
5044:  RCALL  4AB2
5046:  MOVFF  03,1A4
504A:  MOVFF  02,1A3
504E:  MOVFF  01,1A2
5052:  MOVFF  00,1A1
5056:  MOVLB  1
5058:  MOVF   x9C,W
505A:  SUBWF  xA1,F
505C:  MOVF   x9D,W
505E:  SUBWFB xA2,F
5060:  MOVF   x9E,W
5062:  SUBWFB xA3,F
5064:  MOVF   x9F,W
5066:  SUBWFB xA4,F
5068:  BNZ   507E
506A:  MOVF   xA3,F
506C:  BNZ   507E
506E:  MOVF   xA2,W
5070:  SUBLW  00
5072:  BC    509A
5074:  XORLW  FF
5076:  BNZ   507E
5078:  MOVF   xA1,W
507A:  SUBLW  F4
507C:  BC    509A
....................       { 
....................          //if the robot moved backwards enough, go to step 2 (rotate) 
....................          ground_missing_state = 2; 
507E:  MOVLW  02
5080:  MOVWF  xA0
....................          ground_missing_timer = KJunior_get_time(); 
5082:  MOVLB  0
5084:  RCALL  4AB2
5086:  MOVFF  03,19F
508A:  MOVFF  02,19E
508E:  MOVFF  01,19D
5092:  MOVFF  00,19C
....................          mt_turn_left(); 
5096:  RCALL  4F08
5098:  MOVLB  1
....................       } 
....................        
....................       CONTINUE; 
509A:  BRA    4F56
....................    } 
....................     
....................    //if the robot is turing in order to avoid a missing ground 
....................    if( ground_missing_state == 2 ) 
509C:  MOVF   xA0,W
509E:  SUBLW  02
50A0:  BNZ   50E0
....................    { 
....................     
....................       if( KJunior_get_time() - ground_missing_timer <= MT_GROUND_MISSING_ROTATE_DELTA ) 
50A2:  MOVLB  0
50A4:  RCALL  4AB2
50A6:  MOVFF  03,1A4
50AA:  MOVFF  02,1A3
50AE:  MOVFF  01,1A2
50B2:  MOVFF  00,1A1
50B6:  MOVLB  1
50B8:  MOVF   x9C,W
50BA:  SUBWF  xA1,F
50BC:  MOVF   x9D,W
50BE:  SUBWFB xA2,F
50C0:  MOVF   x9E,W
50C2:  SUBWFB xA3,F
50C4:  MOVF   x9F,W
50C6:  SUBWFB xA4,F
50C8:  BNZ   50DE
50CA:  MOVF   xA3,F
50CC:  BNZ   50DE
50CE:  MOVF   xA2,W
50D0:  SUBLW  07
50D2:  BNC   50DE
50D4:  BNZ   50DC
50D6:  MOVF   xA1,W
50D8:  SUBLW  D0
50DA:  BNC   50DE
....................       { 
....................          CONTINUE; 
50DC:  BRA    4F56
....................       } 
....................        
....................       ground_missing_state = 0; 
50DE:  CLRF   xA0
....................    } 
....................     
....................     
....................    //if obstacles on the right and on the left, stops 
....................    if( KJunior_get_proximity(FRONTLEFT) > MT_PROXIMITY && KJunior_get_proximity(FRONTRIGHT) > MT_PROXIMITY )  
50E0:  MOVLW  01
50E2:  MOVWF  xA3
50E4:  MOVLB  0
50E6:  RCALL  49E6
50E8:  MOVFF  02,1A2
50EC:  MOVFF  01,1A1
50F0:  MOVLB  1
50F2:  BTFSC  02.7
50F4:  BRA    5138
50F6:  MOVF   xA2,W
50F8:  SUBLW  03
50FA:  BC    5138
50FC:  XORLW  FF
50FE:  BNZ   5106
5100:  MOVF   xA1,W
5102:  SUBLW  B0
5104:  BC    5138
5106:  MOVLW  03
5108:  MOVWF  xA3
510A:  MOVLB  0
510C:  RCALL  49E6
510E:  MOVFF  02,1A2
5112:  MOVFF  01,1A1
5116:  MOVLB  1
5118:  BTFSC  02.7
511A:  BRA    5138
511C:  MOVF   xA2,W
511E:  SUBLW  03
5120:  BC    5138
5122:  XORLW  FF
5124:  BNZ   512C
5126:  MOVF   xA1,W
5128:  SUBLW  B0
512A:  BC    5138
....................    { 
....................       KJunior_set_speed(0, 0);    
512C:  CLRF   xA1
512E:  CLRF   xA2
5130:  MOVLB  0
5132:  RCALL  4A08
....................    } 
....................    //if obstacle to the left, turns right 
....................    else if( KJunior_get_proximity(LEFT) > MT_PROXIMITY || KJunior_get_proximity(FRONTLEFT) > MT_PROXIMITY ) 
5134:  BRA    5262
5136:  MOVLB  1
5138:  CLRF   xA3
513A:  MOVLB  0
513C:  RCALL  49E6
513E:  MOVFF  02,1A2
5142:  MOVFF  01,1A1
5146:  MOVLB  1
5148:  BTFSC  02.7
514A:  BRA    515C
514C:  MOVF   xA2,W
514E:  SUBLW  03
5150:  BC    515C
5152:  XORLW  FF
5154:  BNZ   5182
5156:  MOVF   xA1,W
5158:  SUBLW  B0
515A:  BNC   5182
515C:  MOVLW  01
515E:  MOVWF  xA3
5160:  MOVLB  0
5162:  RCALL  49E6
5164:  MOVFF  02,1A2
5168:  MOVFF  01,1A1
516C:  MOVLB  1
516E:  BTFSC  02.7
5170:  BRA    518A
5172:  MOVF   xA2,W
5174:  SUBLW  03
5176:  BC    518A
5178:  XORLW  FF
517A:  BNZ   5182
517C:  MOVF   xA1,W
517E:  SUBLW  B0
5180:  BC    518A
....................    { 
....................       mt_turn_right(); 
5182:  MOVLB  0
5184:  RCALL  4F18
....................     
....................    } 
....................    //if obstacle to the right, turns left 
....................    else if( KJunior_get_proximity(RIGHT) > MT_PROXIMITY || KJunior_get_proximity(FRONTRIGHT) > MT_PROXIMITY )  
5186:  BRA    5262
5188:  MOVLB  1
518A:  MOVLW  04
518C:  MOVWF  xA3
518E:  MOVLB  0
5190:  RCALL  49E6
5192:  MOVFF  02,1A2
5196:  MOVFF  01,1A1
519A:  MOVLB  1
519C:  BTFSC  02.7
519E:  BRA    51B0
51A0:  MOVF   xA2,W
51A2:  SUBLW  03
51A4:  BC    51B0
51A6:  XORLW  FF
51A8:  BNZ   51D6
51AA:  MOVF   xA1,W
51AC:  SUBLW  B0
51AE:  BNC   51D6
51B0:  MOVLW  03
51B2:  MOVWF  xA3
51B4:  MOVLB  0
51B6:  RCALL  49E6
51B8:  MOVFF  02,1A2
51BC:  MOVFF  01,1A1
51C0:  MOVLB  1
51C2:  BTFSC  02.7
51C4:  BRA    51DE
51C6:  MOVF   xA2,W
51C8:  SUBLW  03
51CA:  BC    51DE
51CC:  XORLW  FF
51CE:  BNZ   51D6
51D0:  MOVF   xA1,W
51D2:  SUBLW  B0
51D4:  BC    51DE
....................    { 
....................       mt_turn_left(); 
51D6:  MOVLB  0
51D8:  RCALL  4F08
....................    } 
....................    //if obstacle to the front, checks the sides proximity to choose where to go 
....................    else if( KJunior_get_proximity(FRONT) > MT_PROXIMITY )  
51DA:  BRA    5262
51DC:  MOVLB  1
51DE:  MOVLW  02
51E0:  MOVWF  xA3
51E2:  MOVLB  0
51E4:  RCALL  49E6
51E6:  MOVFF  02,1A2
51EA:  MOVFF  01,1A1
51EE:  MOVLB  1
51F0:  BTFSC  02.7
51F2:  BRA    5256
51F4:  MOVF   xA2,W
51F6:  SUBLW  03
51F8:  BC    5256
51FA:  XORLW  FF
51FC:  BNZ   5204
51FE:  MOVF   xA1,W
5200:  SUBLW  B0
5202:  BC    5256
....................    { 
....................       if( KJunior_get_proximity(LEFT) > KJunior_get_proximity(RIGHT) )  
5204:  CLRF   xA3
5206:  MOVLB  0
5208:  CALL   49E6
520C:  MOVFF  02,1A2
5210:  MOVFF  01,1A1
5214:  MOVLW  04
5216:  MOVLB  1
5218:  MOVWF  xA3
521A:  MOVLB  0
521C:  CALL   49E6
5220:  MOVFF  02,03
5224:  MOVF   01,W
5226:  BTFSS  02.7
5228:  BRA    5232
522A:  MOVLB  1
522C:  BTFSS  xA2.7
522E:  BRA    5246
5230:  BRA    5238
5232:  MOVLB  1
5234:  BTFSC  xA2.7
5236:  BRA    524E
5238:  MOVF   03,W
523A:  SUBWF  xA2,W
523C:  BNC   524E
523E:  BNZ   5246
5240:  MOVF   xA1,W
5242:  SUBWF  01,W
5244:  BC    524E
....................       { 
....................          mt_turn_right(); 
5246:  MOVLB  0
5248:  RCALL  4F18
....................       } 
....................       else 
524A:  BRA    5252
524C:  MOVLB  1
....................       { 
....................          mt_turn_left(); 
524E:  MOVLB  0
5250:  RCALL  4F08
....................       } 
....................    } 
....................    //else, go forward 
....................    else 
5252:  BRA    5262
5254:  MOVLB  1
....................    { 
....................       KJunior_set_speed( MT_NORMAL_SPEED, MT_NORMAL_SPEED ); 
5256:  MOVLW  05
5258:  MOVWF  xA1
525A:  MOVWF  xA2
525C:  MOVLB  0
525E:  CALL   4A08
....................    } 
....................     
....................    //sleeps a while to avoid changing rotor speed to quickly 
....................    sleep_ms(100); 
5262:  MOVLB  1
5264:  CLRF   xA5
5266:  CLRF   xA4
5268:  CLRF   xA3
526A:  MOVLW  64
526C:  MOVWF  xA2
526E:  MOVLB  0
5270:  RCALL  4AC4
....................        
....................  }// end while 
5272:  BRA    4F58
....................  
.................... }// end multitasking 
5274:  RETURN 0
....................  
....................  
.................... #endif 
....................  
....................  
.................... // The Follow Hand Program 
.................... #include "follow_hand.h"  
.................... /** 
....................  * @file 
....................  *  
....................  * @brief The Follow Hand program 
....................  * 
....................  * This program makes the robot follow a hand or an object. IF the object is detected 
....................  * by the front captor, the robot will move forward until the object either disappear or come too close. 
....................  * If the robot detects that the floor is missing, it will hurriedly move backward and stop. 
....................  * If the object is detected to the left or to the right of the robot, the latter will rotate 
....................  * in its direction. 
....................  * The robot will finally go backward and follow the hand IF it is detected by the robot's 
....................  * rear captor. 
....................  * 
....................  * Note : there is plenty of room FOR improvement. For example, the robot is not really fast  
....................  * nor smooth, and sometimes the hand is not correctly detected.  
....................  * When an object is detected by the front and sides captors, the robot should normally 
....................  * either move forward or stop. but it will aslo sometimes rotate left to right repeatedly. 
....................  *  
....................  * @version : 1 
....................  * @author : Lucy Linder 
....................  * @date : 02.12.2012 
....................  * 
....................  **/ 
....................   
....................   
.................... #ifndef FOLLOW_HAND_bla 
.................... #define FOLLOW_HAND_bla  
....................  
....................  
.................... #define fh_low_prox 500 //!< limit under which the hand is not followed 
.................... #define fh_high_prox 3200 //!< limit up to which the hand is followed 
.................... #define fh_low_prox_side 400 //!< limit under which the hand is not followed [on the sides] 
.................... #define fh_high_prox_side 3500 //!< limit up to which the hand is followed [on the sides] 
.................... #define fh_speed 10 //!< normal speed 
.................... #define fh_quick_rear_speed 20 //!< rear speed 
.................... #define fh_ground_missing_limit 2800 //!< limit under which we interpret the ground as missing 
....................  
....................  
.................... void follow_hand(); //!< contains the main method 
.................... int1 fh_ground_is_missing(void); //!< returns true if the ground is missing 
....................  
.................... #include "follow_hand.c" 
.................... /******************************************************************************* 
....................  * @file 
....................  *  
....................  * @brief The Follow Hand program 
....................  * See the follow_hand.h file for more informations... 
....................  * 
....................  *******************************************************************************/ 
....................   
....................   
....................  /** 
....................  * this function checks the two ground front captors and return true (1) is the floor is missing, 
....................  * false (0) otherwise. 
....................  **/ 
....................   
.................... int1 fh_ground_is_missing() 
.................... { 
....................    RETURN (KJunior_get_proximity (GROUNDFRONTLEFT) < fh_ground_missing_limit || 
....................        KJunior_get_proximity (GROUNDFRONTLEFT) < fh_ground_missing_limit ); 
*
4A5A:  MOVLW  07
4A5C:  MOVLB  1
4A5E:  MOVWF  xA3
4A60:  MOVLB  0
4A62:  RCALL  49E6
4A64:  MOVFF  02,195
4A68:  MOVFF  01,194
4A6C:  MOVLB  1
4A6E:  BTFSC  02.7
4A70:  BRA    4AA8
4A72:  MOVF   x95,W
4A74:  SUBLW  0A
4A76:  BNC   4A80
4A78:  BNZ   4AA8
4A7A:  MOVF   x94,W
4A7C:  SUBLW  EF
4A7E:  BC    4AA8
4A80:  MOVLW  07
4A82:  MOVWF  xA3
4A84:  MOVLB  0
4A86:  RCALL  49E6
4A88:  MOVFF  02,195
4A8C:  MOVFF  01,194
4A90:  MOVLB  1
4A92:  BTFSC  02.7
4A94:  BRA    4AA8
4A96:  MOVF   x95,W
4A98:  SUBLW  0A
4A9A:  BNC   4AA4
4A9C:  BNZ   4AA8
4A9E:  MOVF   x94,W
4AA0:  SUBLW  EF
4AA2:  BC    4AA8
4AA4:  MOVLW  00
4AA6:  BRA    4AAA
4AA8:  MOVLW  01
4AAA:  MOVWF  01
.................... } 
4AAC:  MOVLB  0
4AAE:  GOTO   4BB2 (RETURN)
....................  
....................  
.................... /******************** main method *********************************************/ 
.................... void follow_hand() 
.................... { 
....................    //moves forward 
....................    if( KJunior_get_proximity (FRONT) > fh_low_prox )  
*
4B34:  MOVLW  02
4B36:  MOVLB  1
4B38:  MOVWF  xA3
4B3A:  MOVLB  0
4B3C:  RCALL  49E6
4B3E:  MOVFF  02,195
4B42:  MOVFF  01,194
4B46:  MOVLB  1
4B48:  BTFSC  02.7
4B4A:  BRA    4BE8
4B4C:  MOVF   x95,W
4B4E:  SUBLW  00
4B50:  BC    4BE8
4B52:  XORLW  FF
4B54:  BNZ   4B5C
4B56:  MOVF   x94,W
4B58:  SUBLW  F4
4B5A:  BC    4BE8
....................    { 
....................       //moves forward as LONG as the hand is in sight but not too close 
....................       while( KJunior_get_proximity (FRONT) > fh_low_prox && 
....................              KJunior_get_proximity (FRONT) < fh_high_prox ) 
....................       { 
4B5C:  MOVLW  02
4B5E:  MOVWF  xA3
4B60:  MOVLB  0
4B62:  RCALL  49E6
4B64:  MOVFF  02,195
4B68:  MOVFF  01,194
4B6C:  MOVLB  1
4B6E:  BTFSC  02.7
4B70:  BRA    4BDC
4B72:  MOVF   x95,W
4B74:  SUBLW  00
4B76:  BC    4BDC
4B78:  XORLW  FF
4B7A:  BNZ   4B82
4B7C:  MOVF   x94,W
4B7E:  SUBLW  F4
4B80:  BC    4BDC
4B82:  MOVLW  02
4B84:  MOVWF  xA3
4B86:  MOVLB  0
4B88:  RCALL  49E6
4B8A:  MOVFF  02,195
4B8E:  MOVFF  01,194
4B92:  MOVLB  1
4B94:  BTFSC  02.7
4B96:  BRA    4BA6
4B98:  MOVF   x95,W
4B9A:  SUBLW  0C
4B9C:  BNC   4BDC
4B9E:  BNZ   4BA6
4BA0:  MOVF   x94,W
4BA2:  SUBLW  7F
4BA4:  BNC   4BDC
....................          KJunior_set_speed (fh_speed, fh_speed); 
4BA6:  MOVLW  0A
4BA8:  MOVWF  xA1
4BAA:  MOVWF  xA2
4BAC:  MOVLB  0
4BAE:  RCALL  4A08
....................  
....................          //IF the ground is missing, moves hurrieldy backward and stops. 
....................          if( fh_ground_is_missing () ) 
4BB0:  BRA    4A5A
4BB2:  MOVF   01,F
4BB4:  BZ    4BD8
....................          { 
....................             KJunior_set_speed ( - 20, - 20); 
4BB6:  MOVLW  EC
4BB8:  MOVLB  1
4BBA:  MOVWF  xA1
4BBC:  MOVWF  xA2
4BBE:  MOVLB  0
4BC0:  RCALL  4A08
....................             sleep_ms (400); 
4BC2:  MOVLB  1
4BC4:  CLRF   xA5
4BC6:  CLRF   xA4
4BC8:  MOVLW  01
4BCA:  MOVWF  xA3
4BCC:  MOVLW  90
4BCE:  MOVWF  xA2
4BD0:  MOVLB  0
4BD2:  RCALL  4AC4
....................             break; 
4BD4:  MOVLB  1
4BD6:  BRA    4BDC
....................          } 
....................       } 
4BD8:  MOVLB  1
4BDA:  BRA    4B5C
....................       KJunior_set_speed (0, 0); 
4BDC:  CLRF   xA1
4BDE:  CLRF   xA2
4BE0:  MOVLB  0
4BE2:  RCALL  4A08
....................        
....................    } 
....................    //moves backwards 
....................    else if( KJunior_get_proximity (REAR) > fh_low_prox )  
4BE4:  BRA    4E0E
4BE6:  MOVLB  1
4BE8:  MOVLW  05
4BEA:  MOVWF  xA3
4BEC:  MOVLB  0
4BEE:  RCALL  49E6
4BF0:  MOVFF  02,195
4BF4:  MOVFF  01,194
4BF8:  MOVLB  1
4BFA:  BTFSC  02.7
4BFC:  BRA    4C72
4BFE:  MOVF   x95,W
4C00:  SUBLW  00
4C02:  BC    4C72
4C04:  XORLW  FF
4C06:  BNZ   4C0E
4C08:  MOVF   x94,W
4C0A:  SUBLW  F4
4C0C:  BC    4C72
....................    { 
....................       while( KJunior_get_proximity (REAR) > fh_low_prox &&  
....................              KJunior_get_proximity (REAR) < fh_high_prox ) 
....................       { 
4C0E:  MOVLW  05
4C10:  MOVWF  xA3
4C12:  MOVLB  0
4C14:  RCALL  49E6
4C16:  MOVFF  02,195
4C1A:  MOVFF  01,194
4C1E:  MOVLB  1
4C20:  BTFSC  02.7
4C22:  BRA    4C66
4C24:  MOVF   x95,W
4C26:  SUBLW  00
4C28:  BC    4C66
4C2A:  XORLW  FF
4C2C:  BNZ   4C34
4C2E:  MOVF   x94,W
4C30:  SUBLW  F4
4C32:  BC    4C66
4C34:  MOVLW  05
4C36:  MOVWF  xA3
4C38:  MOVLB  0
4C3A:  RCALL  49E6
4C3C:  MOVFF  02,195
4C40:  MOVFF  01,194
4C44:  MOVLB  1
4C46:  BTFSC  02.7
4C48:  BRA    4C58
4C4A:  MOVF   x95,W
4C4C:  SUBLW  0C
4C4E:  BNC   4C66
4C50:  BNZ   4C58
4C52:  MOVF   x94,W
4C54:  SUBLW  7F
4C56:  BNC   4C66
....................          KJunior_set_speed (-fh_speed, -fh_speed); 
4C58:  MOVLW  F6
4C5A:  MOVWF  xA1
4C5C:  MOVWF  xA2
4C5E:  MOVLB  0
4C60:  RCALL  4A08
....................       } 
4C62:  MOVLB  1
4C64:  BRA    4C0E
....................  
....................       KJunior_set_speed (0, 0); 
4C66:  CLRF   xA1
4C68:  CLRF   xA2
4C6A:  MOVLB  0
4C6C:  RCALL  4A08
....................        
....................    } 
....................    //rotates left 
....................    else if( KJunior_get_proximity (LEFT) > fh_low_prox_side )  
4C6E:  BRA    4E0E
4C70:  MOVLB  1
4C72:  CLRF   xA3
4C74:  MOVLB  0
4C76:  RCALL  49E6
4C78:  MOVFF  02,195
4C7C:  MOVFF  01,194
4C80:  MOVLB  1
4C82:  BTFSC  02.7
4C84:  BRA    4D38
4C86:  MOVF   x95,W
4C88:  SUBLW  00
4C8A:  BC    4D38
4C8C:  XORLW  FF
4C8E:  BNZ   4C96
4C90:  MOVF   x94,W
4C92:  SUBLW  90
4C94:  BC    4D38
....................    { 
....................       //while a hand is in sight of one of the front left or left captor (but not too close), rotates left 
....................       while(( KJunior_get_proximity (LEFT) > fh_low_prox_side && 
....................               KJunior_get_proximity (LEFT) < fh_high_prox_side )|| 
....................             ( KJunior_get_proximity (FRONTLEFT) > fh_low_prox_side &&  
....................               KJunior_get_proximity (FRONTLEFT) < fh_high_prox_side ) ) 
....................       { 
4C96:  CLRF   xA3
4C98:  MOVLB  0
4C9A:  RCALL  49E6
4C9C:  MOVFF  02,195
4CA0:  MOVFF  01,194
4CA4:  MOVLB  1
4CA6:  BTFSC  02.7
4CA8:  BRA    4CDC
4CAA:  MOVF   x95,W
4CAC:  SUBLW  00
4CAE:  BC    4CDC
4CB0:  XORLW  FF
4CB2:  BNZ   4CBA
4CB4:  MOVF   x94,W
4CB6:  SUBLW  90
4CB8:  BC    4CDC
4CBA:  CLRF   xA3
4CBC:  MOVLB  0
4CBE:  RCALL  49E6
4CC0:  MOVFF  02,195
4CC4:  MOVFF  01,194
4CC8:  MOVLB  1
4CCA:  BTFSC  02.7
4CCC:  BRA    4D26
4CCE:  MOVF   x95,W
4CD0:  SUBLW  0D
4CD2:  BNC   4CDC
4CD4:  BNZ   4D26
4CD6:  MOVF   x94,W
4CD8:  SUBLW  AB
4CDA:  BC    4D26
4CDC:  MOVLW  01
4CDE:  MOVWF  xA3
4CE0:  MOVLB  0
4CE2:  RCALL  49E6
4CE4:  MOVFF  02,195
4CE8:  MOVFF  01,194
4CEC:  MOVLB  1
4CEE:  BTFSC  02.7
4CF0:  BRA    4D36
4CF2:  MOVF   x95,W
4CF4:  SUBLW  00
4CF6:  BC    4D36
4CF8:  XORLW  FF
4CFA:  BNZ   4D02
4CFC:  MOVF   x94,W
4CFE:  SUBLW  90
4D00:  BC    4D36
4D02:  MOVLW  01
4D04:  MOVWF  xA3
4D06:  MOVLB  0
4D08:  RCALL  49E6
4D0A:  MOVFF  02,195
4D0E:  MOVFF  01,194
4D12:  MOVLB  1
4D14:  BTFSC  02.7
4D16:  BRA    4D26
4D18:  MOVF   x95,W
4D1A:  SUBLW  0D
4D1C:  BNC   4D36
4D1E:  BNZ   4D26
4D20:  MOVF   x94,W
4D22:  SUBLW  AB
4D24:  BNC   4D36
....................          KJunior_set_speed ( - fh_speed, fh_speed); 
4D26:  MOVLW  F6
4D28:  MOVWF  xA1
4D2A:  MOVLW  0A
4D2C:  MOVWF  xA2
4D2E:  MOVLB  0
4D30:  RCALL  4A08
....................       } 
4D32:  MOVLB  1
4D34:  BRA    4C96
....................  
....................    } 
....................    //rotates right 
....................    else if( KJunior_get_proximity (RIGHT) > fh_low_prox_side )  
4D36:  BRA    4E10
4D38:  MOVLW  04
4D3A:  MOVWF  xA3
4D3C:  MOVLB  0
4D3E:  RCALL  49E6
4D40:  MOVFF  02,195
4D44:  MOVFF  01,194
4D48:  MOVLB  1
4D4A:  BTFSC  02.7
4D4C:  BRA    4E06
4D4E:  MOVF   x95,W
4D50:  SUBLW  00
4D52:  BTFSC  FD8.0
4D54:  BRA    4E06
4D56:  XORLW  FF
4D58:  BNZ   4D60
4D5A:  MOVF   x94,W
4D5C:  SUBLW  90
4D5E:  BC    4E06
....................    { 
....................       //while a hand is in sight of one of the front right or right captor (but not too close), rotates right 
....................       while(( KJunior_get_proximity (RIGHT) > fh_low_prox_side && 
....................               KJunior_get_proximity (RIGHT) < fh_high_prox_side )|| 
....................             ( KJunior_get_proximity (FRONTRIGHT) > fh_low_prox_side && 
....................               KJunior_get_proximity (FRONTRIGHT) < fh_high_prox_side) ) 
....................       { 
4D60:  MOVLW  04
4D62:  MOVWF  xA3
4D64:  MOVLB  0
4D66:  RCALL  49E6
4D68:  MOVFF  02,195
4D6C:  MOVFF  01,194
4D70:  MOVLB  1
4D72:  BTFSC  02.7
4D74:  BRA    4DAA
4D76:  MOVF   x95,W
4D78:  SUBLW  00
4D7A:  BC    4DAA
4D7C:  XORLW  FF
4D7E:  BNZ   4D86
4D80:  MOVF   x94,W
4D82:  SUBLW  90
4D84:  BC    4DAA
4D86:  MOVLW  04
4D88:  MOVWF  xA3
4D8A:  MOVLB  0
4D8C:  RCALL  49E6
4D8E:  MOVFF  02,195
4D92:  MOVFF  01,194
4D96:  MOVLB  1
4D98:  BTFSC  02.7
4D9A:  BRA    4DF4
4D9C:  MOVF   x95,W
4D9E:  SUBLW  0D
4DA0:  BNC   4DAA
4DA2:  BNZ   4DF4
4DA4:  MOVF   x94,W
4DA6:  SUBLW  AB
4DA8:  BC    4DF4
4DAA:  MOVLW  03
4DAC:  MOVWF  xA3
4DAE:  MOVLB  0
4DB0:  RCALL  49E6
4DB2:  MOVFF  02,195
4DB6:  MOVFF  01,194
4DBA:  MOVLB  1
4DBC:  BTFSC  02.7
4DBE:  BRA    4E04
4DC0:  MOVF   x95,W
4DC2:  SUBLW  00
4DC4:  BC    4E04
4DC6:  XORLW  FF
4DC8:  BNZ   4DD0
4DCA:  MOVF   x94,W
4DCC:  SUBLW  90
4DCE:  BC    4E04
4DD0:  MOVLW  03
4DD2:  MOVWF  xA3
4DD4:  MOVLB  0
4DD6:  RCALL  49E6
4DD8:  MOVFF  02,195
4DDC:  MOVFF  01,194
4DE0:  MOVLB  1
4DE2:  BTFSC  02.7
4DE4:  BRA    4DF4
4DE6:  MOVF   x95,W
4DE8:  SUBLW  0D
4DEA:  BNC   4E04
4DEC:  BNZ   4DF4
4DEE:  MOVF   x94,W
4DF0:  SUBLW  AB
4DF2:  BNC   4E04
....................          KJunior_set_speed (fh_speed, - fh_speed); 
4DF4:  MOVLW  0A
4DF6:  MOVWF  xA1
4DF8:  MOVLW  F6
4DFA:  MOVWF  xA2
4DFC:  MOVLB  0
4DFE:  RCALL  4A08
....................       } 
4E00:  MOVLB  1
4E02:  BRA    4D60
....................    } 
....................    //else, be sure that the robot stops 
....................    else  
4E04:  BRA    4E10
....................    { 
....................       KJunior_set_speed (0, 0); 
4E06:  CLRF   xA1
4E08:  CLRF   xA2
4E0A:  MOVLB  0
4E0C:  RCALL  4A08
4E0E:  MOVLB  1
....................    } 
....................     
.................... }//end follow_hand 
4E10:  MOVLB  0
4E12:  GOTO   719A (RETURN)
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... // The program to find the 5 stripes barcode 
.................... #include "barcode_finder.h" 
.................... #ifndef BARCODE_FINDER_H 
.................... #define BARCODE_FINDER_H 
....................  
.................... void barcode_finder(void); 
....................  
.................... int1 bf_is_barcode_in_view(char* array); 
....................  
.................... #include "barcode_finder.c" 
.................... /** 
....................  * @file 
....................  *  
....................  * @brief Barcode Finder Program 
....................  */ 
....................  
.................... #include "simple_camera_reading.h" 
.................... /** 
....................  * @file 
....................  *  
....................  * @brief Utilities to read and print pixels from the linear camera 
....................  */ 
....................  
.................... #ifndef SIMPLE_CAMERA_READING_H 
.................... #define SIMPLE_CAMERA_READING_H 
....................  
.................... // Aliases for arrays named by HemLinCam library 
.................... #define LEFT_PIXELS   HemLinCam_Pixels_Zone1 
.................... #define CENTER_PIXELS HemLinCam_Pixels_Zone2 
.................... #define RIGHT_PIXELS  HemLinCam_Pixels_Zone3 
....................  
.................... int1 cr_threshold_enabled = 0; ///< is camera threshold enabled? 
.................... int8 cr_threshold = 120; ///< default camera threshold 
.................... int8 cr_exposition_time = 1; ///< camera exposition time defaults to 1 
....................  
.................... void  cr_print_pixels(unsigned char *array34); 
.................... char* cr_make_single_pixels_array(); 
.................... void  cr_print_pixels_bluetooth(); 
....................  
.................... #include "simple_camera_reading.c" 
....................  
.................... #endif 
....................  
....................  
.................... /** 
....................  * The Barcode Finder looks for a five stripes barcode and moves to it. 
....................  *  
....................  */ 
.................... void barcode_finder(void) 
.................... { 
*
538E:  BRA    5276
5390:  MOVFF  02,195
5394:  MOVFF  01,194
....................       // Build entire_pixels_array 
....................       char* entire_pixels_array = cr_make_single_pixels_array(); 
....................       
....................       if(bf_is_barcode_in_view(entire_pixels_array)) 
5398:  MOVFF  195,197
539C:  MOVFF  194,196
53A0:  BRA    5348
53A2:  MOVF   01,F
53A4:  BZ    53B6
....................       { 
....................    // Move forward 
....................    KJunior_set_speed(3,3); 
53A6:  MOVLW  03
53A8:  MOVLB  1
53AA:  MOVWF  xA1
53AC:  MOVWF  xA2
53AE:  MOVLB  0
53B0:  CALL   4A08
....................       } 
....................       else 
53B4:  BRA    53C6
....................       { 
....................    // Rotate left. Maybe next time we look for it, we'll find it. 
....................    KJunior_set_speed(-3,3); 
53B6:  MOVLW  FD
53B8:  MOVLB  1
53BA:  MOVWF  xA1
53BC:  MOVLW  03
53BE:  MOVWF  xA2
53C0:  MOVLB  0
53C2:  CALL   4A08
....................       } 
.................... } 
53C6:  GOTO   71E0 (RETURN)
....................  
.................... /** 
....................  * Returns true if the camera (whose output reference is passed in array parameter) has a five 
....................  * stripes barcode in view. 
....................  *  
....................  * @param array An array of 102 (char) pixels values 
....................  * @return true if the camera (whose output reference is passed in array parameter) has a five 
....................  * stripes barcode in view. 
....................  */ 
.................... int1 bf_is_barcode_in_view(char* array) 
.................... { 
*
5348:  MOVLB  1
534A:  CLRF   x98
534C:  CLRF   x99
....................    // Initialize some variables 
....................    int black_lines = 0; 
....................    int into_black_line = 0; 
....................     
....................    // Iterate through array 
....................    // Pseudo code: 
....................    // if pixel is black: into_black_line = 1 
....................    // if pixel is white: if into_black_line == 1, then increment black_lines, into_black_lines = 0 
....................    int i; 
....................    for (i = 0; i<102; i++) 
534E:  CLRF   x9A
5350:  MOVF   x9A,W
5352:  SUBLW  65
5354:  BNC   537A
....................    { 
....................       if (array[i] == 0) 
5356:  CLRF   03
5358:  MOVF   x9A,W
535A:  ADDWF  x96,W
535C:  MOVWF  FE9
535E:  MOVF   x97,W
5360:  ADDWFC 03,W
5362:  MOVWF  FEA
5364:  MOVF   FEF,F
5366:  BNZ   536E
....................       { 
....................          into_black_line = 1; 
5368:  MOVLW  01
536A:  MOVWF  x99
....................       }  
....................       else  
536C:  BRA    5376
....................       { 
....................          if (into_black_line) 
536E:  MOVF   x99,F
5370:  BZ    5374
....................          { 
....................             black_lines++; 
5372:  INCF   x98,F
....................          } 
....................          into_black_line = 0; 
5374:  CLRF   x99
....................       } // end else 
....................    } // end for 
5376:  INCF   x9A,F
5378:  BRA    5350
....................    return black_lines >= 5; // check there are five stripes in camera view 
537A:  MOVF   x98,W
537C:  SUBLW  04
537E:  BNC   5384
5380:  MOVLW  00
5382:  BRA    5386
5384:  MOVLW  01
5386:  MOVWF  01
.................... } 
5388:  MOVLB  0
538A:  GOTO   53A2 (RETURN)
....................  
....................  
.................... #endif 
....................  
....................  
.................... void main(void) 
.................... { 
*
707C:  CLRF   FF8
707E:  BCF    FD0.7
7080:  BSF    07.7
7082:  CLRF   FEA
7084:  CLRF   FE9
7086:  MOVLW  72
7088:  MOVWF  FD3
708A:  CLRF   F9B
708C:  CLRF   F64
708E:  BSF    F65.3
7090:  MOVLW  44
7092:  MOVWF  FAF
7094:  MOVLW  00
7096:  MOVWF  FD4
7098:  MOVLW  A6
709A:  MOVWF  FAC
709C:  MOVLW  90
709E:  MOVWF  FAB
70A0:  MOVLB  F
70A2:  BSF    x20.3
70A4:  MOVLW  44
70A6:  MOVWF  x1E
70A8:  MOVLW  00
70AA:  MOVWF  x1F
70AC:  MOVLW  A6
70AE:  MOVWF  x21
70B0:  MOVLW  90
70B2:  MOVWF  x22
70B4:  BSF    F94.3
70B6:  BSF    F94.4
70B8:  MOVLW  27
70BA:  MOVWF  FC8
70BC:  MOVLW  29
70BE:  MOVWF  FC6
70C0:  BSF    FC7.7
70C2:  BCF    FC7.6
70C4:  SETF   FC8
70C6:  MOVLW  28
70C8:  MOVWF  FC6
70CA:  CLRF   1A
70CC:  CLRF   1B
70CE:  CLRF   1C
70D0:  CLRF   1D
70D2:  CLRF   1E
70D4:  CLRF   1F
70D6:  CLRF   20
70D8:  CLRF   21
70DA:  BSF    22.0
70DC:  BSF    22.1
70DE:  BSF    22.2
70E0:  BSF    22.3
70E2:  BCF    22.4
70E4:  MOVLB  0
70E6:  CLRF   x73
70E8:  CLRF   x74
70EA:  BCF    22.5
70EC:  CLRF   x83
70EE:  CLRF   x84
70F0:  CLRF   x85
70F2:  BCF    22.6
70F4:  CLRF   x86
70F6:  CLRF   x87
70F8:  BCF    22.7
70FA:  BCF    x88.0
70FC:  BCF    x88.1
70FE:  BCF    x88.2
7100:  CLRF   x89
7102:  BCF    x88.3
7104:  CLRF   x8D
7106:  CLRF   x8C
7108:  CLRF   x8B
710A:  CLRF   x8A
710C:  CLRF   x8E
710E:  CLRF   x8F
7110:  CLRF   x90
7112:  CLRF   xF1
7114:  CLRF   xF2
7116:  BCF    x88.4
7118:  MOVLB  1
711A:  CLRF   x00
711C:  MOVLB  0
711E:  CLRF   xFF
7120:  MOVLW  10
7122:  MOVLB  1
7124:  MOVWF  x02
7126:  CLRF   x04
7128:  CLRF   x03
712A:  CLRF   x05
712C:  CLRF   x07
712E:  CLRF   x06
7130:  CLRF   x22
7132:  MOVLB  0
7134:  BCF    x88.5
7136:  MOVLW  78
7138:  MOVLB  1
713A:  MOVWF  x8F
713C:  MOVLW  01
713E:  MOVWF  x90
7140:  CLRF   x91
7142:  MOVLB  0
7144:  BCF    x88.6
7146:  MOVLB  1
7148:  MOVWF  x92
714A:  CLRF   x93
714C:  MOVLB  0
714E:  BCF    x88.7
7150:  MOVLW  00
7152:  MOVLB  F
7154:  MOVWF  x23
7156:  MOVWF  x24
7158:  MOVWF  x25
715A:  BCF    FC1.3
715C:  BCF    FC1.4
715E:  BCF    FC1.5
7160:  MOVLB  1
7162:  CLRF   x88
7164:  MOVLB  F
7166:  CLRF   x2E
7168:  CLRF   x2F
716A:  CLRF   x54
716C:  MOVLB  1
716E:  CLRF   x23
7170:  CLRF   x24
....................    // Initialization 
....................    KJunior_init () ; 
7172:  MOVLB  0
7174:  GOTO   1670
....................    HemLinCam_Init (); // currently all this does is sleeping for 1 second... 
7178:  GOTO   1A24
....................    cs_init(); // Init camera settings and TV remote control 
717C:  GOTO   1BC4
....................    Enable_RS232_Control = 1; // Enable robot control over the serial connection 
7180:  BSF    22.2
....................     
....................    // Main loop 
....................    while (1) 
....................    { 
....................       if ( (SerialCommandOK == 1)&& (Enable_RS232_Control == 1) ) 
7182:  BTFSS  22.4
7184:  BRA    718E
7186:  BTFSS  22.2
7188:  BRA    718E
....................          SerialCommandHandler () ; 
718A:  GOTO   4734
....................        
....................        
....................       // Read dip switch value 
....................       if (KJunior_get_switch_state () == 1) 
718E:  CALL   49DC
7192:  DECFSZ 01,W
7194:  BRA    719C
....................       { 
....................          follow_hand () ; 
7196:  GOTO   4B34
....................       }  
....................       else if (KJunior_get_switch_state () == 2 ) 
719A:  BRA    720E
719C:  CALL   49DC
71A0:  MOVF   01,W
71A2:  SUBLW  02
71A4:  BNZ   71AC
....................       { 
....................     // Multitasking Program with sound 
....................          multitasking(); 
71A6:  CALL   4F28
....................       }  
....................       else if (KJunior_get_switch_state () == 5)  
71AA:  BRA    720E
71AC:  CALL   49DC
71B0:  MOVF   01,W
71B2:  SUBLW  05
71B4:  BNZ   71BE
....................       { 
....................     // Multitasking Program *without* sound 
....................          mt_be_silent_please = 1; 
71B6:  BSF    x88.7
....................          multitasking(); 
71B8:  CALL   4F28
....................       }  
....................       else if (KJunior_get_switch_state () == 3 || KJunior_get_switch_state () == 7) 
71BC:  BRA    720E
71BE:  CALL   49DC
71C2:  MOVF   01,W
71C4:  SUBLW  03
71C6:  BZ    71D2
71C8:  CALL   49DC
71CC:  MOVF   01,W
71CE:  SUBLW  07
71D0:  BNZ   7200
....................       { 
....................          // With switch state 7 program reads TV remote to set Linear camera settings 
....................          // With switch state 3 programs does the same AND looks for a barcode then moves to it. 
....................           
....................          if (KJunior_get_switch_state () == 3) 
71D2:  CALL   49DC
71D6:  MOVF   01,W
71D8:  SUBLW  03
71DA:  BNZ   71E0
....................          { 
....................             // Barcode Finder Program 
....................             barcode_finder(); 
71DC:  GOTO   538E
....................          } 
....................           
....................          // Read remote control presses and set camera settings accordingly 
....................          cs_set_camera_with_tv_remote();          
71E0:  GOTO   54E2
....................           
....................     // Print values read by the linear camera on Bluetooth serial port 
....................     // (for live view on a computer or smartphone) 
....................          cr_print_pixels_bluetooth(); 
71E4:  GOTO   5804
....................           
....................     // Reset TV remote last pressed key (this is to detect multiple key presses 
....................     // on the very same key, which otherwise would not be detected) 
....................          cs_reset_tv_remote(); 
71E8:  GOTO   5850
....................      
....................     // Hold on for a moment (200 ms) 
....................     sleep_ms (200) ; 
71EC:  MOVLB  1
71EE:  CLRF   xA5
71F0:  CLRF   xA4
71F2:  CLRF   xA3
71F4:  MOVLW  C8
71F6:  MOVWF  xA2
71F8:  MOVLB  0
71FA:  CALL   4AC4
....................       } 
....................       else if (KJunior_get_switch_state () == 4) 
71FE:  BRA    720E
7200:  CALL   49DC
7204:  MOVF   01,W
7206:  SUBLW  04
7208:  BNZ   720E
....................       { 
....................     // Play Bach's Badinerie tune 
....................          beep_badinerie () ; 
720A:  GOTO   5D78
....................       } 
....................    } // end while 
720E:  BRA    7182
.................... } // end main 
7210:  SLEEP 

Configuration Fuses:
   Word  1: C915   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC NOPLLEN FCMEN IESO
   Word  2: 7C7E   PUT BROWNOUT BORV18 ZPBORM NOWDT WDT1048576
   Word  3: 8901   RTCOSC_T1 CCP2C1 MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
